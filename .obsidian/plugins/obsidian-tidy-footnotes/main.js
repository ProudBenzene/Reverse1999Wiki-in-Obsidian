/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TidyFootnotes
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/tidyFootnotes.ts
var reKey = /\[\^(.+?(?=\]))\]/gi;
var reDefinition = /^\[\^([^\]]+)\]\:/;
function isNumeric(value) {
  return !isNaN(value - parseFloat(value));
}
function tidyFootnotes(editor) {
  let markers = [];
  let definitions = /* @__PURE__ */ new Map();
  let firstDefinitionLine = -1;
  let definitionsIndexed = /* @__PURE__ */ new Map();
  const lineCount = editor.lineCount();
  let prevKey = "";
  for (let i = 0; i < lineCount; i++) {
    const line = editor.getLine(i);
    let isDefinition = false;
    let match;
    if (prevKey.length) {
      const hasIndent = /^[ \t]/.test(line);
      const isLastLine = i === lineCount - 1;
      if (hasIndent || line.length === 0 && !isLastLine) {
        const value = definitions.get(prevKey);
        definitions.set(prevKey, value + "\n" + line);
        markers[markers.length - 1].length++;
        continue;
      } else {
        prevKey = "";
      }
    }
    while ((match = reDefinition.exec(line)) !== null) {
      if (match.length < 1)
        return;
      isDefinition = true;
      let key = match[1];
      let value = line.substring(match[0].length);
      definitions.set(key, value);
      prevKey = key;
      let marker = {
        key,
        line: i,
        index: 0,
        length: 0,
        isDefinition: true
      };
      markers.push(marker);
      if (firstDefinitionLine === -1) {
        firstDefinitionLine = i;
      }
      break;
    }
    if (isDefinition)
      continue;
    while ((match = reKey.exec(line)) !== null) {
      if (match.length < 1)
        return;
      let key = match[1];
      let marker = {
        key,
        line: i,
        index: match.index,
        length: match[0].length,
        isDefinition: false
      };
      markers.push(marker);
      if (!definitionsIndexed.has(key)) {
        definitionsIndexed.set(key, {
          key,
          newKey: key,
          isNumber: isNumeric(key),
          value: ""
        });
      }
    }
  }
  definitions.forEach((value, key) => {
    definitionsIndexed.set(key, {
      key,
      newKey: key,
      isNumber: isNumeric(key),
      value
    });
  });
  let count = 1;
  let definitionsStr = "";
  definitionsIndexed.forEach((definition, marker) => {
    let key = definition.key;
    if (definition.isNumber) {
      const current = definitionsIndexed.get(marker);
      key = count.toString();
      definitionsIndexed.set(marker, {
        ...current,
        newKey: key
      });
      count++;
    }
    definitionsStr += `[^${key}]:${definition.value}
`;
  });
  const markersCount = markers.length;
  for (let i = markersCount - 1; i >= 0; i--) {
    const marker = markers[i];
    const markerLine = marker.line;
    if (marker.isDefinition) {
      let rangeStart, rangeEnd;
      const lineEnd = markerLine + 1 + marker.length;
      if (lineEnd === editor.lineCount()) {
        rangeStart = { line: markerLine, ch: 0 };
        rangeEnd = { line: lineEnd - 1, ch: Infinity };
      } else {
        rangeStart = { line: markerLine, ch: 0 };
        rangeEnd = { line: lineEnd, ch: 0 };
      }
      if (markerLine === firstDefinitionLine) {
        editor.replaceRange(definitionsStr, rangeStart, rangeEnd);
        continue;
      }
      editor.replaceRange("", rangeStart, rangeEnd);
      continue;
    }
    const definition = definitionsIndexed.get(marker.key);
    const newKey = definition.newKey;
    if (marker.key === newKey)
      continue;
    const line = editor.getLine(markerLine);
    const prefix = line.substring(0, marker.index);
    const newMarker = `[^${newKey}]`;
    const suffix = line.substr(marker.index + marker.length);
    const newLine = prefix + newMarker + suffix;
    editor.replaceRange(
      newLine,
      { line: markerLine, ch: 0 },
      { line: markerLine, ch: Infinity }
    );
  }
  if (firstDefinitionLine == -1) {
    const lineCount2 = editor.lineCount();
    editor.replaceRange(
      "\n\n" + definitionsStr,
      { line: lineCount2, ch: 0 },
      { line: lineCount2, ch: Infinity }
    );
  }
}

// src/main.ts
var TidyFootnotes = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "tidy-footnotes",
      name: "Tidy Footnotes",
      editorCallback: (editor, view) => {
        tidyFootnotes(editor);
      }
    });
  }
};
