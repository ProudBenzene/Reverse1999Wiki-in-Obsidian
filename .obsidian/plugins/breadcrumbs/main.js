/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/feather-icons/dist/feather.js
var require_feather = __commonJS({
  "node_modules/feather-icons/dist/feather.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["feather"] = factory();
      else
        root2["feather"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.r = function(exports2) {
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 0);
        }({
          /***/
          "./dist/icons.json": (
            /*!*************************!*\
              !*** ./dist/icons.json ***!
              \*************************/
            /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, table, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
            /***/
            function(module3) {
              module3.exports = { "activity": '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', "airplay": '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', "anchor": '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', "aperture": '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', "archive": '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', "award": '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', "battery": '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "bell": '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', "bluetooth": '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', "bold": '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', "book": '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', "bookmark": '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', "box": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "briefcase": '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', "calendar": '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', "camera": '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', "cast": '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', "check": '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', "chrome": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', "circle": '<circle cx="12" cy="12" r="10"></circle>', "clipboard": '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', "clock": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', "cloud": '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', "code": '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', "codepen": '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', "codesandbox": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "coffee": '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', "columns": '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', "command": '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', "compass": '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', "copy": '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', "cpu": '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', "crop": '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', "crosshair": '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', "database": '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', "delete": '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', "disc": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', "divide": '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', "download": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', "dribbble": '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', "droplet": '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', "edit": '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "eye": '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', "facebook": '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', "feather": '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', "figma": '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', "file": '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', "film": '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', "filter": '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', "flag": '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', "folder": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', "framer": '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', "frown": '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "gift": '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', "github": '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', "gitlab": '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', "globe": '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', "grid": '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', "hash": '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', "headphones": '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', "heart": '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', "hexagon": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', "home": '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', "image": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', "inbox": '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', "info": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', "instagram": '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', "italic": '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', "key": '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', "layers": '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', "layout": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', "link": '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', "linkedin": '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', "list": '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', "loader": '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', "lock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', "mail": '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', "map": '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "maximize": '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', "meh": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "menu": '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "mic": '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "minimize": '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', "minus": '<line x1="5" y1="12" x2="19" y2="12"></line>', "monitor": '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', "moon": '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', "move": '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', "music": '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', "navigation": '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', "octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', "package": '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "paperclip": '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', "pause": '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', "percent": '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone": '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', "play": '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus": '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', "pocket": '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', "power": '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', "printer": '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', "radio": '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', "repeat": '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', "rewind": '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', "rss": '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', "save": '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', "scissors": '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', "search": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', "send": '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', "server": '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', "settings": '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', "share": '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "shield": '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', "shuffle": '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', "sidebar": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', "slack": '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', "slash": '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', "sliders": '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', "smartphone": '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "smile": '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "speaker": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', "square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', "star": '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', "sun": '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', "sunrise": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', "sunset": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', "table": '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>', "tablet": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "tag": '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', "target": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', "terminal": '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', "thermometer": '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', "tool": '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', "trash": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', "trello": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', "triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', "truck": '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', "tv": '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', "twitch": '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zM11 11V7M16 11V7"></path>', "twitter": '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', "type": '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', "umbrella": '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', "underline": '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', "unlock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', "upload": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', "user": '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', "users": '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "video": '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', "voicemail": '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', "volume": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', "watch": '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wifi": '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wind": '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', "x": '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', "youtube": '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', "zap": '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
            }
          ),
          /***/
          "./node_modules/classnames/dedupe.js": (
            /*!*******************************************!*\
              !*** ./node_modules/classnames/dedupe.js ***!
              \*******************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
              (function() {
                "use strict";
                var classNames = function() {
                  function StorageObject() {
                  }
                  StorageObject.prototype = /* @__PURE__ */ Object.create(null);
                  function _parseArray(resultSet, array) {
                    var length = array.length;
                    for (var i = 0; i < length; ++i) {
                      _parse(resultSet, array[i]);
                    }
                  }
                  var hasOwn = {}.hasOwnProperty;
                  function _parseNumber(resultSet, num) {
                    resultSet[num] = true;
                  }
                  function _parseObject(resultSet, object) {
                    for (var k in object) {
                      if (hasOwn.call(object, k)) {
                        resultSet[k] = !!object[k];
                      }
                    }
                  }
                  var SPACE = /\s+/;
                  function _parseString(resultSet, str) {
                    var array = str.split(SPACE);
                    var length = array.length;
                    for (var i = 0; i < length; ++i) {
                      resultSet[array[i]] = true;
                    }
                  }
                  function _parse(resultSet, arg) {
                    if (!arg)
                      return;
                    var argType = typeof arg;
                    if (argType === "string") {
                      _parseString(resultSet, arg);
                    } else if (Array.isArray(arg)) {
                      _parseArray(resultSet, arg);
                    } else if (argType === "object") {
                      _parseObject(resultSet, arg);
                    } else if (argType === "number") {
                      _parseNumber(resultSet, arg);
                    }
                  }
                  function _classNames() {
                    var len = arguments.length;
                    var args = Array(len);
                    for (var i = 0; i < len; i++) {
                      args[i] = arguments[i];
                    }
                    var classSet = new StorageObject();
                    _parseArray(classSet, args);
                    var list = [];
                    for (var k in classSet) {
                      if (classSet[k]) {
                        list.push(k);
                      }
                    }
                    return list.join(" ");
                  }
                  return _classNames;
                }();
                if (typeof module3 !== "undefined" && module3.exports) {
                  module3.exports = classNames;
                } else if (true) {
                  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return classNames;
                  }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                }
              })();
            }
          ),
          /***/
          "./node_modules/core-js/es/array/from.js": (
            /*!***********************************************!*\
              !*** ./node_modules/core-js/es/array/from.js ***!
              \***********************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              __webpack_require__(
                /*! ../../modules/es.string.iterator */
                "./node_modules/core-js/modules/es.string.iterator.js"
              );
              __webpack_require__(
                /*! ../../modules/es.array.from */
                "./node_modules/core-js/modules/es.array.from.js"
              );
              var path2 = __webpack_require__(
                /*! ../../internals/path */
                "./node_modules/core-js/internals/path.js"
              );
              module3.exports = path2.Array.from;
            }
          ),
          /***/
          "./node_modules/core-js/internals/a-function.js": (
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/a-function.js ***!
              \******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = function(it) {
                if (typeof it != "function") {
                  throw TypeError(String(it) + " is not a function");
                }
                return it;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/an-object.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/an-object.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var isObject = __webpack_require__(
                /*! ../internals/is-object */
                "./node_modules/core-js/internals/is-object.js"
              );
              module3.exports = function(it) {
                if (!isObject(it)) {
                  throw TypeError(String(it) + " is not an object");
                }
                return it;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/array-from.js": (
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/array-from.js ***!
              \******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var bind = __webpack_require__(
                /*! ../internals/bind-context */
                "./node_modules/core-js/internals/bind-context.js"
              );
              var toObject = __webpack_require__(
                /*! ../internals/to-object */
                "./node_modules/core-js/internals/to-object.js"
              );
              var callWithSafeIterationClosing = __webpack_require__(
                /*! ../internals/call-with-safe-iteration-closing */
                "./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
              );
              var isArrayIteratorMethod = __webpack_require__(
                /*! ../internals/is-array-iterator-method */
                "./node_modules/core-js/internals/is-array-iterator-method.js"
              );
              var toLength = __webpack_require__(
                /*! ../internals/to-length */
                "./node_modules/core-js/internals/to-length.js"
              );
              var createProperty = __webpack_require__(
                /*! ../internals/create-property */
                "./node_modules/core-js/internals/create-property.js"
              );
              var getIteratorMethod = __webpack_require__(
                /*! ../internals/get-iterator-method */
                "./node_modules/core-js/internals/get-iterator-method.js"
              );
              module3.exports = function from(arrayLike) {
                var O = toObject(arrayLike);
                var C2 = typeof this == "function" ? this : Array;
                var argumentsLength = arguments.length;
                var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                var mapping = mapfn !== void 0;
                var index2 = 0;
                var iteratorMethod = getIteratorMethod(O);
                var length, result, step, iterator;
                if (mapping)
                  mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
                if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
                  iterator = iteratorMethod.call(O);
                  result = new C2();
                  for (; !(step = iterator.next()).done; index2++) {
                    createProperty(
                      result,
                      index2,
                      mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value
                    );
                  }
                } else {
                  length = toLength(O.length);
                  result = new C2(length);
                  for (; length > index2; index2++) {
                    createProperty(result, index2, mapping ? mapfn(O[index2], index2) : O[index2]);
                  }
                }
                result.length = index2;
                return result;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/array-includes.js": (
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/array-includes.js ***!
              \**********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var toIndexedObject = __webpack_require__(
                /*! ../internals/to-indexed-object */
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var toLength = __webpack_require__(
                /*! ../internals/to-length */
                "./node_modules/core-js/internals/to-length.js"
              );
              var toAbsoluteIndex = __webpack_require__(
                /*! ../internals/to-absolute-index */
                "./node_modules/core-js/internals/to-absolute-index.js"
              );
              module3.exports = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O = toIndexedObject($this);
                  var length = toLength(O.length);
                  var index2 = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index2) {
                      value = O[index2++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index2; index2++)
                      if (IS_INCLUDES || index2 in O) {
                        if (O[index2] === el)
                          return IS_INCLUDES || index2 || 0;
                      }
                  return !IS_INCLUDES && -1;
                };
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/bind-context.js": (
            /*!********************************************************!*\
              !*** ./node_modules/core-js/internals/bind-context.js ***!
              \********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var aFunction = __webpack_require__(
                /*! ../internals/a-function */
                "./node_modules/core-js/internals/a-function.js"
              );
              module3.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === void 0)
                  return fn;
                switch (length) {
                  case 0:
                    return function() {
                      return fn.call(that);
                    };
                  case 1:
                    return function(a2) {
                      return fn.call(that, a2);
                    };
                  case 2:
                    return function(a2, b) {
                      return fn.call(that, a2, b);
                    };
                  case 3:
                    return function(a2, b, c3) {
                      return fn.call(that, a2, b, c3);
                    };
                }
                return function() {
                  return fn.apply(that, arguments);
                };
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": (
            /*!****************************************************************************!*\
              !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
              \****************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              module3.exports = function(iterator, fn, value, ENTRIES) {
                try {
                  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                } catch (error6) {
                  var returnMethod = iterator["return"];
                  if (returnMethod !== void 0)
                    anObject(returnMethod.call(iterator));
                  throw error6;
                }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/check-correctness-of-iteration.js": (
            /*!**************************************************************************!*\
              !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
              \**************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var SAFE_CLOSING = false;
              try {
                var called = 0;
                var iteratorWithReturn = {
                  next: function() {
                    return { done: !!called++ };
                  },
                  "return": function() {
                    SAFE_CLOSING = true;
                  }
                };
                iteratorWithReturn[ITERATOR] = function() {
                  return this;
                };
                Array.from(iteratorWithReturn, function() {
                  throw 2;
                });
              } catch (error6) {
              }
              module3.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING)
                  return false;
                var ITERATION_SUPPORT = false;
                try {
                  var object = {};
                  object[ITERATOR] = function() {
                    return {
                      next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      }
                    };
                  };
                  exec(object);
                } catch (error6) {
                }
                return ITERATION_SUPPORT;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/classof-raw.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/classof-raw.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              var toString = {}.toString;
              module3.exports = function(it) {
                return toString.call(it).slice(8, -1);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/classof.js": (
            /*!***************************************************!*\
              !*** ./node_modules/core-js/internals/classof.js ***!
              \***************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var classofRaw = __webpack_require__(
                /*! ../internals/classof-raw */
                "./node_modules/core-js/internals/classof-raw.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var CORRECT_ARGUMENTS = classofRaw(function() {
                return arguments;
              }()) == "Arguments";
              var tryGet = function(it, key) {
                try {
                  return it[key];
                } catch (error6) {
                }
              };
              module3.exports = function(it) {
                var O, tag, result;
                return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/copy-constructor-properties.js": (
            /*!***********************************************************************!*\
              !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
              \***********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var ownKeys = __webpack_require__(
                /*! ../internals/own-keys */
                "./node_modules/core-js/internals/own-keys.js"
              );
              var getOwnPropertyDescriptorModule = __webpack_require__(
                /*! ../internals/object-get-own-property-descriptor */
                "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
              );
              var definePropertyModule = __webpack_require__(
                /*! ../internals/object-define-property */
                "./node_modules/core-js/internals/object-define-property.js"
              );
              module3.exports = function(target, source) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (!has(target, key))
                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/correct-prototype-getter.js": (
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
              \********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              module3.exports = !fails(function() {
                function F() {
                }
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/create-iterator-constructor.js": (
            /*!***********************************************************************!*\
              !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
              \***********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var IteratorPrototype = __webpack_require__(
                /*! ../internals/iterators-core */
                "./node_modules/core-js/internals/iterators-core.js"
              ).IteratorPrototype;
              var create2 = __webpack_require__(
                /*! ../internals/object-create */
                "./node_modules/core-js/internals/object-create.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /*! ../internals/create-property-descriptor */
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              var setToStringTag = __webpack_require__(
                /*! ../internals/set-to-string-tag */
                "./node_modules/core-js/internals/set-to-string-tag.js"
              );
              var Iterators = __webpack_require__(
                /*! ../internals/iterators */
                "./node_modules/core-js/internals/iterators.js"
              );
              var returnThis = function() {
                return this;
              };
              module3.exports = function(IteratorConstructor, NAME, next) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/create-property-descriptor.js": (
            /*!**********************************************************************!*\
              !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
              \**********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & 1),
                  configurable: !(bitmap & 2),
                  writable: !(bitmap & 4),
                  value
                };
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/create-property.js": (
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/create-property.js ***!
              \***********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var toPrimitive = __webpack_require__(
                /*! ../internals/to-primitive */
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var definePropertyModule = __webpack_require__(
                /*! ../internals/object-define-property */
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /*! ../internals/create-property-descriptor */
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              module3.exports = function(object, key, value) {
                var propertyKey = toPrimitive(key);
                if (propertyKey in object)
                  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                else
                  object[propertyKey] = value;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/define-iterator.js": (
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/define-iterator.js ***!
              \***********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var $ = __webpack_require__(
                /*! ../internals/export */
                "./node_modules/core-js/internals/export.js"
              );
              var createIteratorConstructor = __webpack_require__(
                /*! ../internals/create-iterator-constructor */
                "./node_modules/core-js/internals/create-iterator-constructor.js"
              );
              var getPrototypeOf = __webpack_require__(
                /*! ../internals/object-get-prototype-of */
                "./node_modules/core-js/internals/object-get-prototype-of.js"
              );
              var setPrototypeOf = __webpack_require__(
                /*! ../internals/object-set-prototype-of */
                "./node_modules/core-js/internals/object-set-prototype-of.js"
              );
              var setToStringTag = __webpack_require__(
                /*! ../internals/set-to-string-tag */
                "./node_modules/core-js/internals/set-to-string-tag.js"
              );
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              var redefine = __webpack_require__(
                /*! ../internals/redefine */
                "./node_modules/core-js/internals/redefine.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var IS_PURE = __webpack_require__(
                /*! ../internals/is-pure */
                "./node_modules/core-js/internals/is-pure.js"
              );
              var Iterators = __webpack_require__(
                /*! ../internals/iterators */
                "./node_modules/core-js/internals/iterators.js"
              );
              var IteratorsCore = __webpack_require__(
                /*! ../internals/iterators-core */
                "./node_modules/core-js/internals/iterators-core.js"
              );
              var IteratorPrototype = IteratorsCore.IteratorPrototype;
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
              var ITERATOR = wellKnownSymbol("iterator");
              var KEYS = "keys";
              var VALUES = "values";
              var ENTRIES = "entries";
              var returnThis = function() {
                return this;
              };
              module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = function(KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator;
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND];
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND);
                      };
                  }
                  return function() {
                    return new IteratorConstructor(this);
                  };
                };
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                  if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                    if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                      if (setPrototypeOf) {
                        setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                      } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                        hide(CurrentIteratorPrototype, ITERATOR, returnThis);
                      }
                    }
                    setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                    if (IS_PURE)
                      Iterators[TO_STRING_TAG] = returnThis;
                  }
                }
                if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                  INCORRECT_VALUES_NAME = true;
                  defaultIterator = function values() {
                    return nativeIterator.call(this);
                  };
                }
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                  hide(IterablePrototype, ITERATOR, defaultIterator);
                }
                Iterators[NAME] = defaultIterator;
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  };
                  if (FORCED)
                    for (KEY in methods) {
                      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                        redefine(IterablePrototype, KEY, methods[KEY]);
                      }
                    }
                  else
                    $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                }
                return methods;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/descriptors.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/descriptors.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              module3.exports = !fails(function() {
                return Object.defineProperty({}, "a", { get: function() {
                  return 7;
                } }).a != 7;
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/document-create-element.js": (
            /*!*******************************************************************!*\
              !*** ./node_modules/core-js/internals/document-create-element.js ***!
              \*******************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var isObject = __webpack_require__(
                /*! ../internals/is-object */
                "./node_modules/core-js/internals/is-object.js"
              );
              var document2 = global2.document;
              var exist = isObject(document2) && isObject(document2.createElement);
              module3.exports = function(it) {
                return exist ? document2.createElement(it) : {};
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/enum-bug-keys.js": (
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
              \*********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
              ];
            }
          ),
          /***/
          "./node_modules/core-js/internals/export.js": (
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/export.js ***!
              \**************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var getOwnPropertyDescriptor = __webpack_require__(
                /*! ../internals/object-get-own-property-descriptor */
                "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
              ).f;
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              var redefine = __webpack_require__(
                /*! ../internals/redefine */
                "./node_modules/core-js/internals/redefine.js"
              );
              var setGlobal = __webpack_require__(
                /*! ../internals/set-global */
                "./node_modules/core-js/internals/set-global.js"
              );
              var copyConstructorProperties = __webpack_require__(
                /*! ../internals/copy-constructor-properties */
                "./node_modules/core-js/internals/copy-constructor-properties.js"
              );
              var isForced = __webpack_require__(
                /*! ../internals/is-forced */
                "./node_modules/core-js/internals/is-forced.js"
              );
              module3.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) {
                  target = global2;
                } else if (STATIC) {
                  target = global2[TARGET] || setGlobal(TARGET, {});
                } else {
                  target = (global2[TARGET] || {}).prototype;
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key];
                    if (options.noTargetGet) {
                      descriptor = getOwnPropertyDescriptor(target, key);
                      targetProperty = descriptor && descriptor.value;
                    } else
                      targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                    if (!FORCED && targetProperty !== void 0) {
                      if (typeof sourceProperty === typeof targetProperty)
                        continue;
                      copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    if (options.sham || targetProperty && targetProperty.sham) {
                      hide(sourceProperty, "sham", true);
                    }
                    redefine(target, key, sourceProperty, options);
                  }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/fails.js": (
            /*!*************************************************!*\
              !*** ./node_modules/core-js/internals/fails.js ***!
              \*************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error6) {
                  return true;
                }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/function-to-string.js": (
            /*!**************************************************************!*\
              !*** ./node_modules/core-js/internals/function-to-string.js ***!
              \**************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var shared = __webpack_require__(
                /*! ../internals/shared */
                "./node_modules/core-js/internals/shared.js"
              );
              module3.exports = shared("native-function-to-string", Function.toString);
            }
          ),
          /***/
          "./node_modules/core-js/internals/get-iterator-method.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
              \***************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var classof = __webpack_require__(
                /*! ../internals/classof */
                "./node_modules/core-js/internals/classof.js"
              );
              var Iterators = __webpack_require__(
                /*! ../internals/iterators */
                "./node_modules/core-js/internals/iterators.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              module3.exports = function(it) {
                if (it != void 0)
                  return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/global.js": (
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/global.js ***!
              \**************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              (function(global2) {
                var O = "object";
                var check = function(it) {
                  return it && it.Math == Math && it;
                };
                module3.exports = // eslint-disable-next-line no-undef
                check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof global2 == O && global2) || // eslint-disable-next-line no-new-func
                Function("return this")();
              }).call(this, __webpack_require__(
                /*! ./../../webpack/buildin/global.js */
                "./node_modules/webpack/buildin/global.js"
              ));
            }
          ),
          /***/
          "./node_modules/core-js/internals/has.js": (
            /*!***********************************************!*\
              !*** ./node_modules/core-js/internals/has.js ***!
              \***********************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              var hasOwnProperty2 = {}.hasOwnProperty;
              module3.exports = function(it, key) {
                return hasOwnProperty2.call(it, key);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/hidden-keys.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/hidden-keys.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = {};
            }
          ),
          /***/
          "./node_modules/core-js/internals/hide.js": (
            /*!************************************************!*\
              !*** ./node_modules/core-js/internals/hide.js ***!
              \************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /*! ../internals/descriptors */
                "./node_modules/core-js/internals/descriptors.js"
              );
              var definePropertyModule = __webpack_require__(
                /*! ../internals/object-define-property */
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /*! ../internals/create-property-descriptor */
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              module3.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/html.js": (
            /*!************************************************!*\
              !*** ./node_modules/core-js/internals/html.js ***!
              \************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var document2 = global2.document;
              module3.exports = document2 && document2.documentElement;
            }
          ),
          /***/
          "./node_modules/core-js/internals/ie8-dom-define.js": (
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
              \**********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /*! ../internals/descriptors */
                "./node_modules/core-js/internals/descriptors.js"
              );
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              var createElement = __webpack_require__(
                /*! ../internals/document-create-element */
                "./node_modules/core-js/internals/document-create-element.js"
              );
              module3.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                    return 7;
                  }
                }).a != 7;
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/indexed-object.js": (
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/indexed-object.js ***!
              \**********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              var classof = __webpack_require__(
                /*! ../internals/classof-raw */
                "./node_modules/core-js/internals/classof-raw.js"
              );
              var split = "".split;
              module3.exports = fails(function() {
                return !Object("z").propertyIsEnumerable(0);
              }) ? function(it) {
                return classof(it) == "String" ? split.call(it, "") : Object(it);
              } : Object;
            }
          ),
          /***/
          "./node_modules/core-js/internals/internal-state.js": (
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/internal-state.js ***!
              \**********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var NATIVE_WEAK_MAP = __webpack_require__(
                /*! ../internals/native-weak-map */
                "./node_modules/core-js/internals/native-weak-map.js"
              );
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var isObject = __webpack_require__(
                /*! ../internals/is-object */
                "./node_modules/core-js/internals/is-object.js"
              );
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              var objectHas = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var sharedKey = __webpack_require__(
                /*! ../internals/shared-key */
                "./node_modules/core-js/internals/shared-key.js"
              );
              var hiddenKeys = __webpack_require__(
                /*! ../internals/hidden-keys */
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var WeakMap2 = global2.WeakMap;
              var set3, get3, has;
              var enforce = function(it) {
                return has(it) ? get3(it) : set3(it, {});
              };
              var getterFor = function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get3(it)).type !== TYPE) {
                    throw TypeError("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              };
              if (NATIVE_WEAK_MAP) {
                var store = new WeakMap2();
                var wmget = store.get;
                var wmhas = store.has;
                var wmset = store.set;
                set3 = function(it, metadata) {
                  wmset.call(store, it, metadata);
                  return metadata;
                };
                get3 = function(it) {
                  return wmget.call(store, it) || {};
                };
                has = function(it) {
                  return wmhas.call(store, it);
                };
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set3 = function(it, metadata) {
                  hide(it, STATE, metadata);
                  return metadata;
                };
                get3 = function(it) {
                  return objectHas(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                  return objectHas(it, STATE);
                };
              }
              module3.exports = {
                set: set3,
                get: get3,
                has,
                enforce,
                getterFor
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/is-array-iterator-method.js": (
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
              \********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var Iterators = __webpack_require__(
                /*! ../internals/iterators */
                "./node_modules/core-js/internals/iterators.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var ArrayPrototype = Array.prototype;
              module3.exports = function(it) {
                return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/is-forced.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/is-forced.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              var replacement = /#|\.prototype\./;
              var isForced = function(feature, detection) {
                var value = data[normalize2(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
              };
              var normalize2 = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module3.exports = isForced;
            }
          ),
          /***/
          "./node_modules/core-js/internals/is-object.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/is-object.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = function(it) {
                return typeof it === "object" ? it !== null : typeof it === "function";
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/is-pure.js": (
            /*!***************************************************!*\
              !*** ./node_modules/core-js/internals/is-pure.js ***!
              \***************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = false;
            }
          ),
          /***/
          "./node_modules/core-js/internals/iterators-core.js": (
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/iterators-core.js ***!
              \**********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var getPrototypeOf = __webpack_require__(
                /*! ../internals/object-get-prototype-of */
                "./node_modules/core-js/internals/object-get-prototype-of.js"
              );
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var IS_PURE = __webpack_require__(
                /*! ../internals/is-pure */
                "./node_modules/core-js/internals/is-pure.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var BUGGY_SAFARI_ITERATORS = false;
              var returnThis = function() {
                return this;
              };
              var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
              if ([].keys) {
                arrayIterator = [].keys();
                if (!("next" in arrayIterator))
                  BUGGY_SAFARI_ITERATORS = true;
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
              }
              if (IteratorPrototype == void 0)
                IteratorPrototype = {};
              if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
                hide(IteratorPrototype, ITERATOR, returnThis);
              module3.exports = {
                IteratorPrototype,
                BUGGY_SAFARI_ITERATORS
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/iterators.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/iterators.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = {};
            }
          ),
          /***/
          "./node_modules/core-js/internals/native-symbol.js": (
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/native-symbol.js ***!
              \*********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var fails = __webpack_require__(
                /*! ../internals/fails */
                "./node_modules/core-js/internals/fails.js"
              );
              module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                return !String(Symbol());
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/native-weak-map.js": (
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/native-weak-map.js ***!
              \***********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var nativeFunctionToString = __webpack_require__(
                /*! ../internals/function-to-string */
                "./node_modules/core-js/internals/function-to-string.js"
              );
              var WeakMap2 = global2.WeakMap;
              module3.exports = typeof WeakMap2 === "function" && /native code/.test(nativeFunctionToString.call(WeakMap2));
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-create.js": (
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/object-create.js ***!
              \*********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              var defineProperties = __webpack_require__(
                /*! ../internals/object-define-properties */
                "./node_modules/core-js/internals/object-define-properties.js"
              );
              var enumBugKeys = __webpack_require__(
                /*! ../internals/enum-bug-keys */
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              var hiddenKeys = __webpack_require__(
                /*! ../internals/hidden-keys */
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var html = __webpack_require__(
                /*! ../internals/html */
                "./node_modules/core-js/internals/html.js"
              );
              var documentCreateElement = __webpack_require__(
                /*! ../internals/document-create-element */
                "./node_modules/core-js/internals/document-create-element.js"
              );
              var sharedKey = __webpack_require__(
                /*! ../internals/shared-key */
                "./node_modules/core-js/internals/shared-key.js"
              );
              var IE_PROTO = sharedKey("IE_PROTO");
              var PROTOTYPE = "prototype";
              var Empty = function() {
              };
              var createDict = function() {
                var iframe = documentCreateElement("iframe");
                var length = enumBugKeys.length;
                var lt = "<";
                var script = "script";
                var gt = ">";
                var js = "java" + script + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                iframe.src = String(js);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(lt + script + gt + "document.F=Object" + lt + "/" + script + gt);
                iframeDocument.close();
                createDict = iframeDocument.F;
                while (length--)
                  delete createDict[PROTOTYPE][enumBugKeys[length]];
                return createDict();
              };
              module3.exports = Object.create || function create2(O, Properties) {
                var result;
                if (O !== null) {
                  Empty[PROTOTYPE] = anObject(O);
                  result = new Empty();
                  Empty[PROTOTYPE] = null;
                  result[IE_PROTO] = O;
                } else
                  result = createDict();
                return Properties === void 0 ? result : defineProperties(result, Properties);
              };
              hiddenKeys[IE_PROTO] = true;
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-define-properties.js": (
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/object-define-properties.js ***!
              \********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /*! ../internals/descriptors */
                "./node_modules/core-js/internals/descriptors.js"
              );
              var definePropertyModule = __webpack_require__(
                /*! ../internals/object-define-property */
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              var objectKeys = __webpack_require__(
                /*! ../internals/object-keys */
                "./node_modules/core-js/internals/object-keys.js"
              );
              module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var i = 0;
                var key;
                while (length > i)
                  definePropertyModule.f(O, key = keys[i++], Properties[key]);
                return O;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-define-property.js": (
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/internals/object-define-property.js ***!
              \******************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /*! ../internals/descriptors */
                "./node_modules/core-js/internals/descriptors.js"
              );
              var IE8_DOM_DEFINE = __webpack_require__(
                /*! ../internals/ie8-dom-define */
                "./node_modules/core-js/internals/ie8-dom-define.js"
              );
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              var toPrimitive = __webpack_require__(
                /*! ../internals/to-primitive */
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var nativeDefineProperty = Object.defineProperty;
              exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPrimitive(P, true);
                anObject(Attributes);
                if (IE8_DOM_DEFINE)
                  try {
                    return nativeDefineProperty(O, P, Attributes);
                  } catch (error6) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw TypeError("Accessors not supported");
                if ("value" in Attributes)
                  O[P] = Attributes.value;
                return O;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-get-own-property-descriptor.js": (
            /*!******************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
              \******************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /*! ../internals/descriptors */
                "./node_modules/core-js/internals/descriptors.js"
              );
              var propertyIsEnumerableModule = __webpack_require__(
                /*! ../internals/object-property-is-enumerable */
                "./node_modules/core-js/internals/object-property-is-enumerable.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /*! ../internals/create-property-descriptor */
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              var toIndexedObject = __webpack_require__(
                /*! ../internals/to-indexed-object */
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var toPrimitive = __webpack_require__(
                /*! ../internals/to-primitive */
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var IE8_DOM_DEFINE = __webpack_require__(
                /*! ../internals/ie8-dom-define */
                "./node_modules/core-js/internals/ie8-dom-define.js"
              );
              var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPrimitive(P, true);
                if (IE8_DOM_DEFINE)
                  try {
                    return nativeGetOwnPropertyDescriptor(O, P);
                  } catch (error6) {
                  }
                if (has(O, P))
                  return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-get-own-property-names.js": (
            /*!*************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
              \*************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var internalObjectKeys = __webpack_require__(
                /*! ../internals/object-keys-internal */
                "./node_modules/core-js/internals/object-keys-internal.js"
              );
              var enumBugKeys = __webpack_require__(
                /*! ../internals/enum-bug-keys */
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              var hiddenKeys = enumBugKeys.concat("length", "prototype");
              exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-get-own-property-symbols.js": (
            /*!***************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
              \***************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              exports2.f = Object.getOwnPropertySymbols;
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-get-prototype-of.js": (
            /*!*******************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
              \*******************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var toObject = __webpack_require__(
                /*! ../internals/to-object */
                "./node_modules/core-js/internals/to-object.js"
              );
              var sharedKey = __webpack_require__(
                /*! ../internals/shared-key */
                "./node_modules/core-js/internals/shared-key.js"
              );
              var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
                /*! ../internals/correct-prototype-getter */
                "./node_modules/core-js/internals/correct-prototype-getter.js"
              );
              var IE_PROTO = sharedKey("IE_PROTO");
              var ObjectPrototype = Object.prototype;
              module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                O = toObject(O);
                if (has(O, IE_PROTO))
                  return O[IE_PROTO];
                if (typeof O.constructor == "function" && O instanceof O.constructor) {
                  return O.constructor.prototype;
                }
                return O instanceof Object ? ObjectPrototype : null;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-keys-internal.js": (
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
              \****************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var toIndexedObject = __webpack_require__(
                /*! ../internals/to-indexed-object */
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var arrayIncludes = __webpack_require__(
                /*! ../internals/array-includes */
                "./node_modules/core-js/internals/array-includes.js"
              );
              var hiddenKeys = __webpack_require__(
                /*! ../internals/hidden-keys */
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var arrayIndexOf = arrayIncludes(false);
              module3.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = 0;
                var result = [];
                var key;
                for (key in O)
                  !has(hiddenKeys, key) && has(O, key) && result.push(key);
                while (names.length > i)
                  if (has(O, key = names[i++])) {
                    ~arrayIndexOf(result, key) || result.push(key);
                  }
                return result;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-keys.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/object-keys.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var internalObjectKeys = __webpack_require__(
                /*! ../internals/object-keys-internal */
                "./node_modules/core-js/internals/object-keys-internal.js"
              );
              var enumBugKeys = __webpack_require__(
                /*! ../internals/enum-bug-keys */
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              module3.exports = Object.keys || function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-property-is-enumerable.js": (
            /*!*************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
              \*************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
              exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
              } : nativePropertyIsEnumerable;
            }
          ),
          /***/
          "./node_modules/core-js/internals/object-set-prototype-of.js": (
            /*!*******************************************************************!*\
              !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
              \*******************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var validateSetPrototypeOfArguments = __webpack_require__(
                /*! ../internals/validate-set-prototype-of-arguments */
                "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
              );
              module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var correctSetter = false;
                var test = {};
                var setter;
                try {
                  setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                  setter.call(test, []);
                  correctSetter = test instanceof Array;
                } catch (error6) {
                }
                return function setPrototypeOf(O, proto) {
                  validateSetPrototypeOfArguments(O, proto);
                  if (correctSetter)
                    setter.call(O, proto);
                  else
                    O.__proto__ = proto;
                  return O;
                };
              }() : void 0);
            }
          ),
          /***/
          "./node_modules/core-js/internals/own-keys.js": (
            /*!****************************************************!*\
              !*** ./node_modules/core-js/internals/own-keys.js ***!
              \****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var getOwnPropertyNamesModule = __webpack_require__(
                /*! ../internals/object-get-own-property-names */
                "./node_modules/core-js/internals/object-get-own-property-names.js"
              );
              var getOwnPropertySymbolsModule = __webpack_require__(
                /*! ../internals/object-get-own-property-symbols */
                "./node_modules/core-js/internals/object-get-own-property-symbols.js"
              );
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              var Reflect2 = global2.Reflect;
              module3.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/path.js": (
            /*!************************************************!*\
              !*** ./node_modules/core-js/internals/path.js ***!
              \************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              module3.exports = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
            }
          ),
          /***/
          "./node_modules/core-js/internals/redefine.js": (
            /*!****************************************************!*\
              !*** ./node_modules/core-js/internals/redefine.js ***!
              \****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var shared = __webpack_require__(
                /*! ../internals/shared */
                "./node_modules/core-js/internals/shared.js"
              );
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var setGlobal = __webpack_require__(
                /*! ../internals/set-global */
                "./node_modules/core-js/internals/set-global.js"
              );
              var nativeFunctionToString = __webpack_require__(
                /*! ../internals/function-to-string */
                "./node_modules/core-js/internals/function-to-string.js"
              );
              var InternalStateModule = __webpack_require__(
                /*! ../internals/internal-state */
                "./node_modules/core-js/internals/internal-state.js"
              );
              var getInternalState = InternalStateModule.get;
              var enforceInternalState = InternalStateModule.enforce;
              var TEMPLATE = String(nativeFunctionToString).split("toString");
              shared("inspectSource", function(it) {
                return nativeFunctionToString.call(it);
              });
              (module3.exports = function(O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false;
                var simple2 = options ? !!options.enumerable : false;
                var noTargetGet = options ? !!options.noTargetGet : false;
                if (typeof value == "function") {
                  if (typeof key == "string" && !has(value, "name"))
                    hide(value, "name", key);
                  enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
                }
                if (O === global2) {
                  if (simple2)
                    O[key] = value;
                  else
                    setGlobal(key, value);
                  return;
                } else if (!unsafe) {
                  delete O[key];
                } else if (!noTargetGet && O[key]) {
                  simple2 = true;
                }
                if (simple2)
                  O[key] = value;
                else
                  hide(O, key, value);
              })(Function.prototype, "toString", function toString() {
                return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/require-object-coercible.js": (
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
              \********************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              module3.exports = function(it) {
                if (it == void 0)
                  throw TypeError("Can't call method on " + it);
                return it;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/set-global.js": (
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/set-global.js ***!
              \******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var hide = __webpack_require__(
                /*! ../internals/hide */
                "./node_modules/core-js/internals/hide.js"
              );
              module3.exports = function(key, value) {
                try {
                  hide(global2, key, value);
                } catch (error6) {
                  global2[key] = value;
                }
                return value;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/set-to-string-tag.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
              \*************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var defineProperty = __webpack_require__(
                /*! ../internals/object-define-property */
                "./node_modules/core-js/internals/object-define-property.js"
              ).f;
              var has = __webpack_require__(
                /*! ../internals/has */
                "./node_modules/core-js/internals/has.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /*! ../internals/well-known-symbol */
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              module3.exports = function(it, TAG, STATIC) {
                if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                  defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
                }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/shared-key.js": (
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/shared-key.js ***!
              \******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var shared = __webpack_require__(
                /*! ../internals/shared */
                "./node_modules/core-js/internals/shared.js"
              );
              var uid = __webpack_require__(
                /*! ../internals/uid */
                "./node_modules/core-js/internals/uid.js"
              );
              var keys = shared("keys");
              module3.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/shared.js": (
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/shared.js ***!
              \**************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var setGlobal = __webpack_require__(
                /*! ../internals/set-global */
                "./node_modules/core-js/internals/set-global.js"
              );
              var IS_PURE = __webpack_require__(
                /*! ../internals/is-pure */
                "./node_modules/core-js/internals/is-pure.js"
              );
              var SHARED = "__core-js_shared__";
              var store = global2[SHARED] || setGlobal(SHARED, {});
              (module3.exports = function(key, value) {
                return store[key] || (store[key] = value !== void 0 ? value : {});
              })("versions", []).push({
                version: "3.1.3",
                mode: IS_PURE ? "pure" : "global",
                copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
              });
            }
          ),
          /***/
          "./node_modules/core-js/internals/string-at.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/string-at.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var toInteger = __webpack_require__(
                /*! ../internals/to-integer */
                "./node_modules/core-js/internals/to-integer.js"
              );
              var requireObjectCoercible = __webpack_require__(
                /*! ../internals/require-object-coercible */
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module3.exports = function(that, pos, CONVERT_TO_STRING) {
                var S = String(requireObjectCoercible(that));
                var position = toInteger(pos);
                var size = S.length;
                var first, second;
                if (position < 0 || position >= size)
                  return CONVERT_TO_STRING ? "" : void 0;
                first = S.charCodeAt(position);
                return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-absolute-index.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
              \*************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var toInteger = __webpack_require__(
                /*! ../internals/to-integer */
                "./node_modules/core-js/internals/to-integer.js"
              );
              var max4 = Math.max;
              var min3 = Math.min;
              module3.exports = function(index2, length) {
                var integer = toInteger(index2);
                return integer < 0 ? max4(integer + length, 0) : min3(integer, length);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-indexed-object.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
              \*************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var IndexedObject = __webpack_require__(
                /*! ../internals/indexed-object */
                "./node_modules/core-js/internals/indexed-object.js"
              );
              var requireObjectCoercible = __webpack_require__(
                /*! ../internals/require-object-coercible */
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module3.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-integer.js": (
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/to-integer.js ***!
              \******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module3.exports = function(argument) {
                return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-length.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/to-length.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var toInteger = __webpack_require__(
                /*! ../internals/to-integer */
                "./node_modules/core-js/internals/to-integer.js"
              );
              var min3 = Math.min;
              module3.exports = function(argument) {
                return argument > 0 ? min3(toInteger(argument), 9007199254740991) : 0;
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-object.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/to-object.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var requireObjectCoercible = __webpack_require__(
                /*! ../internals/require-object-coercible */
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module3.exports = function(argument) {
                return Object(requireObjectCoercible(argument));
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/to-primitive.js": (
            /*!********************************************************!*\
              !*** ./node_modules/core-js/internals/to-primitive.js ***!
              \********************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var isObject = __webpack_require__(
                /*! ../internals/is-object */
                "./node_modules/core-js/internals/is-object.js"
              );
              module3.exports = function(it, S) {
                if (!isObject(it))
                  return it;
                var fn, val;
                if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
                  return val;
                if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
                  return val;
                if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
                  return val;
                throw TypeError("Can't convert object to primitive value");
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/uid.js": (
            /*!***********************************************!*\
              !*** ./node_modules/core-js/internals/uid.js ***!
              \***********************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              var id2 = 0;
              var postfix = Math.random();
              module3.exports = function(key) {
                return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id2 + postfix).toString(36));
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": (
            /*!*******************************************************************************!*\
              !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
              \*******************************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var isObject = __webpack_require__(
                /*! ../internals/is-object */
                "./node_modules/core-js/internals/is-object.js"
              );
              var anObject = __webpack_require__(
                /*! ../internals/an-object */
                "./node_modules/core-js/internals/an-object.js"
              );
              module3.exports = function(O, proto) {
                anObject(O);
                if (!isObject(proto) && proto !== null) {
                  throw TypeError("Can't set " + String(proto) + " as a prototype");
                }
              };
            }
          ),
          /***/
          "./node_modules/core-js/internals/well-known-symbol.js": (
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
              \*************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var global2 = __webpack_require__(
                /*! ../internals/global */
                "./node_modules/core-js/internals/global.js"
              );
              var shared = __webpack_require__(
                /*! ../internals/shared */
                "./node_modules/core-js/internals/shared.js"
              );
              var uid = __webpack_require__(
                /*! ../internals/uid */
                "./node_modules/core-js/internals/uid.js"
              );
              var NATIVE_SYMBOL = __webpack_require__(
                /*! ../internals/native-symbol */
                "./node_modules/core-js/internals/native-symbol.js"
              );
              var Symbol2 = global2.Symbol;
              var store = shared("wks");
              module3.exports = function(name) {
                return store[name] || (store[name] = NATIVE_SYMBOL && Symbol2[name] || (NATIVE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
              };
            }
          ),
          /***/
          "./node_modules/core-js/modules/es.array.from.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/modules/es.array.from.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              var $ = __webpack_require__(
                /*! ../internals/export */
                "./node_modules/core-js/internals/export.js"
              );
              var from = __webpack_require__(
                /*! ../internals/array-from */
                "./node_modules/core-js/internals/array-from.js"
              );
              var checkCorrectnessOfIteration = __webpack_require__(
                /*! ../internals/check-correctness-of-iteration */
                "./node_modules/core-js/internals/check-correctness-of-iteration.js"
              );
              var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                Array.from(iterable);
              });
              $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
                from
              });
            }
          ),
          /***/
          "./node_modules/core-js/modules/es.string.iterator.js": (
            /*!************************************************************!*\
              !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
              \************************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var codePointAt = __webpack_require__(
                /*! ../internals/string-at */
                "./node_modules/core-js/internals/string-at.js"
              );
              var InternalStateModule = __webpack_require__(
                /*! ../internals/internal-state */
                "./node_modules/core-js/internals/internal-state.js"
              );
              var defineIterator = __webpack_require__(
                /*! ../internals/define-iterator */
                "./node_modules/core-js/internals/define-iterator.js"
              );
              var STRING_ITERATOR = "String Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
              defineIterator(String, "String", function(iterated) {
                setInternalState(this, {
                  type: STRING_ITERATOR,
                  string: String(iterated),
                  index: 0
                });
              }, function next() {
                var state = getInternalState(this);
                var string = state.string;
                var index2 = state.index;
                var point3;
                if (index2 >= string.length)
                  return { value: void 0, done: true };
                point3 = codePointAt(string, index2, true);
                state.index += point3.length;
                return { value: point3, done: false };
              });
            }
          ),
          /***/
          "./node_modules/webpack/buildin/global.js": (
            /*!***********************************!*\
              !*** (webpack)/buildin/global.js ***!
              \***********************************/
            /*! no static exports found */
            /***/
            function(module3, exports2) {
              var g;
              g = function() {
                return this;
              }();
              try {
                g = g || Function("return this")() || (1, eval)("this");
              } catch (e) {
                if (typeof window === "object")
                  g = window;
              }
              module3.exports = g;
            }
          ),
          /***/
          "./src/default-attrs.json": (
            /*!********************************!*\
              !*** ./src/default-attrs.json ***!
              \********************************/
            /*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */
            /***/
            function(module3) {
              module3.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
            }
          ),
          /***/
          "./src/icon.js": (
            /*!*********************!*\
              !*** ./src/icon.js ***!
              \*********************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              var _createClass = function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _dedupe = __webpack_require__(
                /*! classnames/dedupe */
                "./node_modules/classnames/dedupe.js"
              );
              var _dedupe2 = _interopRequireDefault(_dedupe);
              var _defaultAttrs = __webpack_require__(
                /*! ./default-attrs.json */
                "./src/default-attrs.json"
              );
              var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function _classCallCheck(instance24, Constructor) {
                if (!(instance24 instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Icon = function() {
                function Icon2(name, contents) {
                  var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                  _classCallCheck(this, Icon2);
                  this.name = name;
                  this.contents = contents;
                  this.tags = tags;
                  this.attrs = _extends({}, _defaultAttrs2.default, { class: "feather feather-" + name });
                }
                _createClass(Icon2, [{
                  key: "toSvg",
                  value: function toSvg() {
                    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });
                    return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
                  }
                  /**
                   * Return string representation of an `Icon`.
                   *
                   * Added for backward compatibility. If old code expects `feather.icons.<name>`
                   * to be a string, `toString()` will get implicitly called.
                   *
                   * @returns {string}
                   */
                }, {
                  key: "toString",
                  value: function toString() {
                    return this.contents;
                  }
                }]);
                return Icon2;
              }();
              function attrsToString(attrs) {
                return Object.keys(attrs).map(function(key) {
                  return key + '="' + attrs[key] + '"';
                }).join(" ");
              }
              exports2.default = Icon;
            }
          ),
          /***/
          "./src/icons.js": (
            /*!**********************!*\
              !*** ./src/icons.js ***!
              \**********************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              var _icon = __webpack_require__(
                /*! ./icon */
                "./src/icon.js"
              );
              var _icon2 = _interopRequireDefault(_icon);
              var _icons = __webpack_require__(
                /*! ../dist/icons.json */
                "./dist/icons.json"
              );
              var _icons2 = _interopRequireDefault(_icons);
              var _tags = __webpack_require__(
                /*! ./tags.json */
                "./src/tags.json"
              );
              var _tags2 = _interopRequireDefault(_tags);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              exports2.default = Object.keys(_icons2.default).map(function(key) {
                return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
              }).reduce(function(object, icon) {
                object[icon.name] = icon;
                return object;
              }, {});
            }
          ),
          /***/
          "./src/index.js": (
            /*!**********************!*\
              !*** ./src/index.js ***!
              \**********************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              var _icons = __webpack_require__(
                /*! ./icons */
                "./src/icons.js"
              );
              var _icons2 = _interopRequireDefault(_icons);
              var _toSvg = __webpack_require__(
                /*! ./to-svg */
                "./src/to-svg.js"
              );
              var _toSvg2 = _interopRequireDefault(_toSvg);
              var _replace = __webpack_require__(
                /*! ./replace */
                "./src/replace.js"
              );
              var _replace2 = _interopRequireDefault(_replace);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              module3.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };
            }
          ),
          /***/
          "./src/replace.js": (
            /*!************************!*\
              !*** ./src/replace.js ***!
              \************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              var _dedupe = __webpack_require__(
                /*! classnames/dedupe */
                "./node_modules/classnames/dedupe.js"
              );
              var _dedupe2 = _interopRequireDefault(_dedupe);
              var _icons = __webpack_require__(
                /*! ./icons */
                "./src/icons.js"
              );
              var _icons2 = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function replace() {
                var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                if (typeof document === "undefined") {
                  throw new Error("`feather.replace()` only works in a browser environment.");
                }
                var elementsToReplace = document.querySelectorAll("[data-feather]");
                Array.from(elementsToReplace).forEach(function(element2) {
                  return replaceElement(element2, attrs);
                });
              }
              function replaceElement(element2) {
                var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var elementAttrs = getAttrs(element2);
                var name = elementAttrs["data-feather"];
                delete elementAttrs["data-feather"];
                var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
                var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
                var svgElement = svgDocument.querySelector("svg");
                element2.parentNode.replaceChild(svgElement, element2);
              }
              function getAttrs(element2) {
                return Array.from(element2.attributes).reduce(function(attrs, attr2) {
                  attrs[attr2.name] = attr2.value;
                  return attrs;
                }, {});
              }
              exports2.default = replace;
            }
          ),
          /***/
          "./src/tags.json": (
            /*!***********************!*\
              !*** ./src/tags.json ***!
              \***********************/
            /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-2, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, chevron-down, chevron-up, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-buoy, link, link-2, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-2, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-2, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
            /***/
            function(module3) {
              module3.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-buoy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-2": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-2": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
            }
          ),
          /***/
          "./src/to-svg.js": (
            /*!***********************!*\
              !*** ./src/to-svg.js ***!
              \***********************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              var _icons = __webpack_require__(
                /*! ./icons */
                "./src/icons.js"
              );
              var _icons2 = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function toSvg(name) {
                var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
                if (!name) {
                  throw new Error("The required `key` (icon name) parameter is missing.");
                }
                if (!_icons2.default[name]) {
                  throw new Error("No icon matching '" + name + "'. See the complete list of icons at https://feathericons.com");
                }
                return _icons2.default[name].toSvg(attrs);
              }
              exports2.default = toSvg;
            }
          ),
          /***/
          0: (
            /*!**************************************************!*\
              !*** multi core-js/es/array/from ./src/index.js ***!
              \**************************************************/
            /*! no static exports found */
            /***/
            function(module3, exports2, __webpack_require__) {
              __webpack_require__(
                /*! core-js/es/array/from */
                "./node_modules/core-js/es/array/from.js"
              );
              module3.exports = __webpack_require__(
                /*! /home/runner/work/feather/feather/src/index.js */
                "./src/index.js"
              );
            }
          )
          /******/
        })
      );
    });
  }
});

// node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "node_modules/loglevel/lib/loglevel.js"(exports, module2) {
    (function(root2, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root2.log = definition();
      }
    })(exports, function() {
      "use strict";
      var noop3 = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop3;
        }
      }
      function replaceLoggingMethods(level, loggerName) {
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop3 : this.methodFactory(methodName, level, loggerName);
        }
        this.log = this.debug;
      }
      function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this, level, loggerName);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, level, loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, defaultLevel, factory) {
        var self2 = this;
        var currentLevel;
        defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var location = cookie.indexOf(
                encodeURIComponent(storageKey) + "="
              );
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          return currentLevel;
        };
        self2.setLevel = function(level, persist) {
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            currentLevel = level;
            if (persist !== false) {
              persistLevelIfPossible(level);
            }
            replaceLoggingMethods.call(self2, level, name);
            if (typeof console === undefinedType && level < self2.levels.SILENT) {
              return "No console available for logging";
            }
          } else {
            throw "log.setLevel() called with invalid level: " + level;
          }
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          self2.setLevel(defaultLevel, false);
          clearPersistedLevel();
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        var initialLevel = getPersistedLevel();
        if (initialLevel == null) {
          initialLevel = defaultLevel;
        }
        self2.setLevel(initialLevel, false);
      }
      var defaultLogger = new Logger();
      var _loggersByName = {};
      defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger.getLevel(),
            defaultLogger.methodFactory
          );
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  }
});

// node_modules/graphology/dist/graphology.umd.min.js
var require_graphology_umd_min = __commonJS({
  "node_modules/graphology/dist/graphology.umd.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).graphology = e();
    }(exports, function() {
      "use strict";
      function t(e3) {
        return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
          return typeof t2;
        } : function(t2) {
          return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
        }, t(e3);
      }
      function e(t2, e3) {
        t2.prototype = Object.create(e3.prototype), t2.prototype.constructor = t2, r(t2, e3);
      }
      function n2(t2) {
        return n2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        }, n2(t2);
      }
      function r(t2, e3) {
        return r = Object.setPrototypeOf || function(t3, e4) {
          return t3.__proto__ = e4, t3;
        }, r(t2, e3);
      }
      function i() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function o(t2, e3, n3) {
        return o = i() ? Reflect.construct : function(t3, e4, n4) {
          var i2 = [null];
          i2.push.apply(i2, e4);
          var o2 = new (Function.bind.apply(t3, i2))();
          return n4 && r(o2, n4.prototype), o2;
        }, o.apply(null, arguments);
      }
      function a2(t2) {
        var e3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return a2 = function(t3) {
          if (null === t3 || (i2 = t3, -1 === Function.toString.call(i2).indexOf("[native code]")))
            return t3;
          var i2;
          if ("function" != typeof t3)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e3) {
            if (e3.has(t3))
              return e3.get(t3);
            e3.set(t3, a3);
          }
          function a3() {
            return o(t3, arguments, n2(this).constructor);
          }
          return a3.prototype = Object.create(t3.prototype, { constructor: { value: a3, enumerable: false, writable: true, configurable: true } }), r(a3, t3);
        }, a2(t2);
      }
      function u(t2) {
        if (void 0 === t2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      var c3 = function() {
        for (var t2 = arguments[0], e3 = 1, n3 = arguments.length; e3 < n3; e3++)
          if (arguments[e3])
            for (var r2 in arguments[e3])
              t2[r2] = arguments[e3][r2];
        return t2;
      };
      function d(t2, e3, n3, r2) {
        var i2 = t2._nodes.get(e3), o2 = null;
        return i2 ? o2 = "mixed" === r2 ? i2.out && i2.out[n3] || i2.undirected && i2.undirected[n3] : "directed" === r2 ? i2.out && i2.out[n3] : i2.undirected && i2.undirected[n3] : o2;
      }
      function s2(e3) {
        return null !== e3 && "object" === t(e3) && "function" == typeof e3.addUndirectedEdgeWithKey && "function" == typeof e3.dropNode;
      }
      function h(e3) {
        return "object" === t(e3) && null !== e3 && e3.constructor === Object;
      }
      function f(t2) {
        var e3;
        for (e3 in t2)
          return false;
        return true;
      }
      function p(t2, e3, n3) {
        Object.defineProperty(t2, e3, { enumerable: false, configurable: false, writable: true, value: n3 });
      }
      function l2(t2, e3, n3) {
        var r2 = { enumerable: true, configurable: true };
        "function" == typeof n3 ? r2.get = n3 : (r2.value = n3, r2.writable = false), Object.defineProperty(t2, e3, r2);
      }
      function g(t2) {
        return !!h(t2) && !(t2.attributes && !Array.isArray(t2.attributes));
      }
      "function" == typeof Object.assign && (c3 = Object.assign);
      var y4, v = { exports: {} }, b = "object" == typeof Reflect ? Reflect : null, w = b && "function" == typeof b.apply ? b.apply : function(t2, e3, n3) {
        return Function.prototype.apply.call(t2, e3, n3);
      };
      y4 = b && "function" == typeof b.ownKeys ? b.ownKeys : Object.getOwnPropertySymbols ? function(t2) {
        return Object.getOwnPropertyNames(t2).concat(Object.getOwnPropertySymbols(t2));
      } : function(t2) {
        return Object.getOwnPropertyNames(t2);
      };
      var m2 = Number.isNaN || function(t2) {
        return t2 != t2;
      };
      function _() {
        _.init.call(this);
      }
      v.exports = _, v.exports.once = function(t2, e3) {
        return new Promise(function(n3, r2) {
          function i2(n4) {
            t2.removeListener(e3, o2), r2(n4);
          }
          function o2() {
            "function" == typeof t2.removeListener && t2.removeListener("error", i2), n3([].slice.call(arguments));
          }
          U(t2, e3, o2, { once: true }), "error" !== e3 && function(t3, e4, n4) {
            "function" == typeof t3.on && U(t3, "error", e4, n4);
          }(t2, i2, { once: true });
        });
      }, _.EventEmitter = _, _.prototype._events = void 0, _.prototype._eventsCount = 0, _.prototype._maxListeners = void 0;
      var k = 10;
      function G(t2) {
        if ("function" != typeof t2)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t2);
      }
      function x4(t2) {
        return void 0 === t2._maxListeners ? _.defaultMaxListeners : t2._maxListeners;
      }
      function E2(t2, e3, n3, r2) {
        var i2, o2, a3, u2;
        if (G(n3), void 0 === (o2 = t2._events) ? (o2 = t2._events = /* @__PURE__ */ Object.create(null), t2._eventsCount = 0) : (void 0 !== o2.newListener && (t2.emit("newListener", e3, n3.listener ? n3.listener : n3), o2 = t2._events), a3 = o2[e3]), void 0 === a3)
          a3 = o2[e3] = n3, ++t2._eventsCount;
        else if ("function" == typeof a3 ? a3 = o2[e3] = r2 ? [n3, a3] : [a3, n3] : r2 ? a3.unshift(n3) : a3.push(n3), (i2 = x4(t2)) > 0 && a3.length > i2 && !a3.warned) {
          a3.warned = true;
          var c4 = new Error("Possible EventEmitter memory leak detected. " + a3.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          c4.name = "MaxListenersExceededWarning", c4.emitter = t2, c4.type = e3, c4.count = a3.length, u2 = c4, console && console.warn && console.warn(u2);
        }
        return t2;
      }
      function S() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function A2(t2, e3, n3) {
        var r2 = { fired: false, wrapFn: void 0, target: t2, type: e3, listener: n3 }, i2 = S.bind(r2);
        return i2.listener = n3, r2.wrapFn = i2, i2;
      }
      function L(t2, e3, n3) {
        var r2 = t2._events;
        if (void 0 === r2)
          return [];
        var i2 = r2[e3];
        return void 0 === i2 ? [] : "function" == typeof i2 ? n3 ? [i2.listener || i2] : [i2] : n3 ? function(t3) {
          for (var e4 = new Array(t3.length), n4 = 0; n4 < e4.length; ++n4)
            e4[n4] = t3[n4].listener || t3[n4];
          return e4;
        }(i2) : N(i2, i2.length);
      }
      function D2(t2) {
        var e3 = this._events;
        if (void 0 !== e3) {
          var n3 = e3[t2];
          if ("function" == typeof n3)
            return 1;
          if (void 0 !== n3)
            return n3.length;
        }
        return 0;
      }
      function N(t2, e3) {
        for (var n3 = new Array(e3), r2 = 0; r2 < e3; ++r2)
          n3[r2] = t2[r2];
        return n3;
      }
      function U(t2, e3, n3, r2) {
        if ("function" == typeof t2.on)
          r2.once ? t2.once(e3, n3) : t2.on(e3, n3);
        else {
          if ("function" != typeof t2.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t2);
          t2.addEventListener(e3, function i2(o2) {
            r2.once && t2.removeEventListener(e3, i2), n3(o2);
          });
        }
      }
      function j(t2) {
        if ("function" != typeof t2)
          throw new Error("obliterator/iterator: expecting a function!");
        this.next = t2;
      }
      Object.defineProperty(_, "defaultMaxListeners", { enumerable: true, get: function() {
        return k;
      }, set: function(t2) {
        if ("number" != typeof t2 || t2 < 0 || m2(t2))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        k = t2;
      } }), _.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, _.prototype.setMaxListeners = function(t2) {
        if ("number" != typeof t2 || t2 < 0 || m2(t2))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        return this._maxListeners = t2, this;
      }, _.prototype.getMaxListeners = function() {
        return x4(this);
      }, _.prototype.emit = function(t2) {
        for (var e3 = [], n3 = 1; n3 < arguments.length; n3++)
          e3.push(arguments[n3]);
        var r2 = "error" === t2, i2 = this._events;
        if (void 0 !== i2)
          r2 = r2 && void 0 === i2.error;
        else if (!r2)
          return false;
        if (r2) {
          var o2;
          if (e3.length > 0 && (o2 = e3[0]), o2 instanceof Error)
            throw o2;
          var a3 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
          throw a3.context = o2, a3;
        }
        var u2 = i2[t2];
        if (void 0 === u2)
          return false;
        if ("function" == typeof u2)
          w(u2, this, e3);
        else {
          var c4 = u2.length, d2 = N(u2, c4);
          for (n3 = 0; n3 < c4; ++n3)
            w(d2[n3], this, e3);
        }
        return true;
      }, _.prototype.addListener = function(t2, e3) {
        return E2(this, t2, e3, false);
      }, _.prototype.on = _.prototype.addListener, _.prototype.prependListener = function(t2, e3) {
        return E2(this, t2, e3, true);
      }, _.prototype.once = function(t2, e3) {
        return G(e3), this.on(t2, A2(this, t2, e3)), this;
      }, _.prototype.prependOnceListener = function(t2, e3) {
        return G(e3), this.prependListener(t2, A2(this, t2, e3)), this;
      }, _.prototype.removeListener = function(t2, e3) {
        var n3, r2, i2, o2, a3;
        if (G(e3), void 0 === (r2 = this._events))
          return this;
        if (void 0 === (n3 = r2[t2]))
          return this;
        if (n3 === e3 || n3.listener === e3)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[t2], r2.removeListener && this.emit("removeListener", t2, n3.listener || e3));
        else if ("function" != typeof n3) {
          for (i2 = -1, o2 = n3.length - 1; o2 >= 0; o2--)
            if (n3[o2] === e3 || n3[o2].listener === e3) {
              a3 = n3[o2].listener, i2 = o2;
              break;
            }
          if (i2 < 0)
            return this;
          0 === i2 ? n3.shift() : function(t3, e4) {
            for (; e4 + 1 < t3.length; e4++)
              t3[e4] = t3[e4 + 1];
            t3.pop();
          }(n3, i2), 1 === n3.length && (r2[t2] = n3[0]), void 0 !== r2.removeListener && this.emit("removeListener", t2, a3 || e3);
        }
        return this;
      }, _.prototype.off = _.prototype.removeListener, _.prototype.removeAllListeners = function(t2) {
        var e3, n3, r2;
        if (void 0 === (n3 = this._events))
          return this;
        if (void 0 === n3.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[t2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[t2]), this;
        if (0 === arguments.length) {
          var i2, o2 = Object.keys(n3);
          for (r2 = 0; r2 < o2.length; ++r2)
            "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e3 = n3[t2]))
          this.removeListener(t2, e3);
        else if (void 0 !== e3)
          for (r2 = e3.length - 1; r2 >= 0; r2--)
            this.removeListener(t2, e3[r2]);
        return this;
      }, _.prototype.listeners = function(t2) {
        return L(this, t2, true);
      }, _.prototype.rawListeners = function(t2) {
        return L(this, t2, false);
      }, _.listenerCount = function(t2, e3) {
        return "function" == typeof t2.listenerCount ? t2.listenerCount(e3) : D2.call(t2, e3);
      }, _.prototype.listenerCount = D2, _.prototype.eventNames = function() {
        return this._eventsCount > 0 ? y4(this._events) : [];
      }, "undefined" != typeof Symbol && (j.prototype[Symbol.iterator] = function() {
        return this;
      }), j.of = function() {
        var t2 = arguments, e3 = t2.length, n3 = 0;
        return new j(function() {
          return n3 >= e3 ? { done: true } : { done: false, value: t2[n3++] };
        });
      }, j.empty = function() {
        return new j(function() {
          return { done: true };
        });
      }, j.fromSequence = function(t2) {
        var e3 = 0, n3 = t2.length;
        return new j(function() {
          return e3 >= n3 ? { done: true } : { done: false, value: t2[e3++] };
        });
      }, j.is = function(t2) {
        return t2 instanceof j || "object" == typeof t2 && null !== t2 && "function" == typeof t2.next;
      };
      var O = j, C2 = {};
      C2.ARRAY_BUFFER_SUPPORT = "undefined" != typeof ArrayBuffer, C2.SYMBOL_SUPPORT = "undefined" != typeof Symbol;
      var z = O, M = C2, P = M.ARRAY_BUFFER_SUPPORT, T = M.SYMBOL_SUPPORT;
      var R = function(t2) {
        var e3 = function(t3) {
          return "string" == typeof t3 || Array.isArray(t3) || P && ArrayBuffer.isView(t3) ? z.fromSequence(t3) : "object" != typeof t3 || null === t3 ? null : T && "function" == typeof t3[Symbol.iterator] ? t3[Symbol.iterator]() : "function" == typeof t3.next ? t3 : null;
        }(t2);
        if (!e3)
          throw new Error("obliterator: target is not iterable nor a valid iterator.");
        return e3;
      }, W = R, K = function(t2, e3) {
        for (var n3, r2 = arguments.length > 1 ? e3 : 1 / 0, i2 = r2 !== 1 / 0 ? new Array(r2) : [], o2 = 0, a3 = W(t2); ; ) {
          if (o2 === r2)
            return i2;
          if ((n3 = a3.next()).done)
            return o2 !== e3 && (i2.length = o2), i2;
          i2[o2++] = n3.value;
        }
      }, I = function(t2) {
        function n3(e3) {
          var n4;
          return (n4 = t2.call(this) || this).name = "GraphError", n4.message = e3, n4;
        }
        return e(n3, t2), n3;
      }(a2(Error)), F = function(t2) {
        function n3(e3) {
          var r2;
          return (r2 = t2.call(this, e3) || this).name = "InvalidArgumentsGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(u(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(I), Y2 = function(t2) {
        function n3(e3) {
          var r2;
          return (r2 = t2.call(this, e3) || this).name = "NotFoundGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(u(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(I), B2 = function(t2) {
        function n3(e3) {
          var r2;
          return (r2 = t2.call(this, e3) || this).name = "UsageGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(u(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(I);
      function q(t2, e3) {
        this.key = t2, this.attributes = e3, this.clear();
      }
      function J(t2, e3) {
        this.key = t2, this.attributes = e3, this.clear();
      }
      function V(t2, e3) {
        this.key = t2, this.attributes = e3, this.clear();
      }
      function H(t2, e3, n3, r2, i2) {
        this.key = e3, this.attributes = i2, this.undirected = t2, this.source = n3, this.target = r2;
      }
      function Q(t2, e3, n3, r2, i2, o2, a3) {
        var u2, c4, d2 = "out", s3 = "in";
        if (e3 && (d2 = s3 = "undirected"), t2.multi) {
          if (void 0 === (c4 = (u2 = o2[d2])[i2]) && (c4 = /* @__PURE__ */ new Set(), u2[i2] = c4), c4.add(n3), r2 === i2 && e3)
            return;
          void 0 === (u2 = a3[s3])[r2] && (u2[r2] = c4);
        } else {
          if (o2[d2][i2] = n3, r2 === i2 && e3)
            return;
          a3[s3][r2] = n3;
        }
      }
      function X2(t2, e3, n3) {
        var r2 = t2.multi, i2 = n3.source, o2 = n3.target, a3 = i2.key, u2 = o2.key, c4 = i2[e3 ? "undirected" : "out"], d2 = e3 ? "undirected" : "in";
        if (u2 in c4)
          if (r2) {
            var s3 = c4[u2];
            1 === s3.size ? (delete c4[u2], delete o2[d2][a3]) : s3.delete(n3);
          } else
            delete c4[u2];
        r2 || delete o2[d2][a3];
      }
      q.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.directedSelfLoops = 0, this.undirectedSelfLoops = 0, this.in = {}, this.out = {}, this.undirected = {};
      }, J.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.directedSelfLoops = 0, this.in = {}, this.out = {};
      }, J.prototype.upgradeToMixed = function() {
        this.undirectedDegree = 0, this.undirectedSelfLoops = 0, this.undirected = {};
      }, V.prototype.clear = function() {
        this.undirectedDegree = 0, this.undirectedSelfLoops = 0, this.undirected = {};
      }, V.prototype.upgradeToMixed = function() {
        this.inDegree = 0, this.outDegree = 0, this.directedSelfLoops = 0, this.in = {}, this.out = {};
      };
      function Z(t2, e3, n3, r2, i2, o2, a3) {
        var u2, c4, d2, s3;
        if (r2 = "" + r2, 0 === n3) {
          if (!(u2 = t2._nodes.get(r2)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(r2, '" node in the graph.'));
          d2 = i2, s3 = o2;
        } else if (3 === n3) {
          if (i2 = "" + i2, !(c4 = t2._edges.get(i2)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(i2, '" edge in the graph.'));
          var h2 = c4.source.key, f2 = c4.target.key;
          if (r2 === h2)
            u2 = c4.target;
          else {
            if (r2 !== f2)
              throw new Y2("Graph.".concat(e3, ': the "').concat(r2, '" node is not attached to the "').concat(i2, '" edge (').concat(h2, ", ").concat(f2, ")."));
            u2 = c4.source;
          }
          d2 = o2, s3 = a3;
        } else {
          if (!(c4 = t2._edges.get(r2)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(r2, '" edge in the graph.'));
          u2 = 1 === n3 ? c4.source : c4.target, d2 = i2, s3 = o2;
        }
        return [u2, d2, s3];
      }
      var $ = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          return a3.attributes[u2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          return Z(this, e3, n3, t3, r2)[0].attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          return a3.attributes.hasOwnProperty(u2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2, o2) {
          var a3 = Z(this, e3, n3, t3, r2, i2, o2), u2 = a3[0], c4 = a3[1], d2 = a3[2];
          return u2.attributes[c4] = d2, this.emit("nodeAttributesUpdated", { key: u2.key, type: "set", attributes: u2.attributes, name: c4 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2, o2) {
          var a3 = Z(this, e3, n3, t3, r2, i2, o2), u2 = a3[0], c4 = a3[1], d2 = a3[2];
          if ("function" != typeof d2)
            throw new F("Graph.".concat(e3, ": updater should be a function."));
          var s3 = u2.attributes, h2 = d2(s3[c4]);
          return s3[c4] = h2, this.emit("nodeAttributesUpdated", { key: u2.key, type: "set", attributes: u2.attributes, name: c4 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          return delete a3.attributes[u2], this.emit("nodeAttributesUpdated", { key: a3.key, type: "remove", attributes: a3.attributes, name: u2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          if (!h(u2))
            throw new F("Graph.".concat(e3, ": provided attributes are not a plain object."));
          return a3.attributes = u2, this.emit("nodeAttributesUpdated", { key: a3.key, type: "replace", attributes: a3.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          if (!h(u2))
            throw new F("Graph.".concat(e3, ": provided attributes are not a plain object."));
          return c3(a3.attributes, u2), this.emit("nodeAttributesUpdated", { key: a3.key, type: "merge", attributes: a3.attributes, data: u2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2 = Z(this, e3, n3, t3, r2, i2), a3 = o2[0], u2 = o2[1];
          if ("function" != typeof u2)
            throw new F("Graph.".concat(e3, ": provided updater is not a function."));
          return a3.attributes = u2(a3.attributes), this.emit("nodeAttributesUpdated", { key: a3.key, type: "update", attributes: a3.attributes }), this;
        };
      } }];
      var tt = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return i2.attributes[r2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3) {
          var r2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 1) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var i2 = "" + t3, o2 = "" + arguments[1];
            if (!(r2 = d(this, i2, o2, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(i2, '" - "').concat(o2, '").'));
          } else if (t3 = "" + t3, !(r2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("mixed" !== n3 && r2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return r2.attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return i2.attributes.hasOwnProperty(r2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a3 = "" + t3, u2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a3, u2, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(a3, '" - "').concat(u2, '").'));
          } else if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("mixed" !== n3 && o2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return o2.attributes[r2] = i2, this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a3 = "" + t3, u2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a3, u2, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(a3, '" - "').concat(u2, '").'));
          } else if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("function" != typeof i2)
            throw new F("Graph.".concat(e3, ": updater should be a function."));
          if ("mixed" !== n3 && o2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return o2.attributes[r2] = i2(o2.attributes[r2]), this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return delete i2.attributes[r2], this.emit("edgeAttributesUpdated", { key: i2.key, type: "remove", attributes: i2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if (!h(r2))
            throw new F("Graph.".concat(e3, ": provided attributes are not a plain object."));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return i2.attributes = r2, this.emit("edgeAttributesUpdated", { key: i2.key, type: "replace", attributes: i2.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if (!h(r2))
            throw new F("Graph.".concat(e3, ": provided attributes are not a plain object."));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return c3(i2.attributes, r2), this.emit("edgeAttributesUpdated", { key: i2.key, type: "merge", attributes: i2.attributes, data: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e3, n3) {
        t2.prototype[e3] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new B2("Graph.".concat(e3, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new B2("Graph.".concat(e3, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a3 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a3, n3)))
              throw new Y2("Graph.".concat(e3, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a3, '").'));
          } else if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" edge in the graph.'));
          if ("function" != typeof r2)
            throw new F("Graph.".concat(e3, ": provided updater is not a function."));
          if ("mixed" !== n3 && i2.undirected !== ("undirected" === n3))
            throw new Y2("Graph.".concat(e3, ': could not find the "').concat(t3, '" ').concat(n3, " edge in the graph."));
          return i2.attributes = r2(i2.attributes), this.emit("edgeAttributesUpdated", { key: i2.key, type: "update", attributes: i2.attributes }), this;
        };
      } }];
      var et = O, nt = R, rt = function() {
        var t2 = arguments, e3 = null, n3 = -1;
        return new et(function r2() {
          if (null === e3) {
            if (++n3 >= t2.length)
              return { done: true };
            e3 = nt(t2[n3]);
          }
          var i2 = e3.next();
          return i2.done ? (e3 = null, r2()) : i2;
        });
      }, it = [{ name: "edges", type: "mixed" }, { name: "inEdges", type: "directed", direction: "in" }, { name: "outEdges", type: "directed", direction: "out" }, { name: "inboundEdges", type: "mixed", direction: "in" }, { name: "outboundEdges", type: "mixed", direction: "out" }, { name: "directedEdges", type: "directed" }, { name: "undirectedEdges", type: "undirected" }];
      function ot(t2, e3) {
        for (var n3 in e3)
          t2.push(e3[n3].key);
      }
      function at(t2, e3) {
        for (var n3 in e3)
          e3[n3].forEach(function(e4) {
            return t2.push(e4.key);
          });
      }
      function ut(t2, e3, n3) {
        for (var r2 in t2)
          if (r2 !== n3) {
            var i2 = t2[r2];
            e3(i2.key, i2.attributes, i2.source.key, i2.target.key, i2.source.attributes, i2.target.attributes, i2.undirected);
          }
      }
      function ct(t2, e3, n3) {
        for (var r2 in t2)
          r2 !== n3 && t2[r2].forEach(function(t3) {
            return e3(t3.key, t3.attributes, t3.source.key, t3.target.key, t3.source.attributes, t3.target.attributes, t3.undirected);
          });
      }
      function dt(t2, e3, n3) {
        for (var r2 in t2)
          if (r2 !== n3) {
            var i2 = t2[r2];
            if (e3(i2.key, i2.attributes, i2.source.key, i2.target.key, i2.source.attributes, i2.target.attributes, i2.undirected))
              return i2.key;
          }
      }
      function st(t2, e3, n3) {
        var r2, i2, o2, a3, u2;
        for (var c4 in t2)
          if (c4 !== n3) {
            for (r2 = t2[c4].values(); true !== (i2 = r2.next()).done; )
              if (a3 = (o2 = i2.value).source, u2 = o2.target, e3(o2.key, o2.attributes, a3.key, u2.key, a3.attributes, u2.attributes, o2.undirected))
                return o2.key;
          }
      }
      function ht(t2, e3) {
        var n3 = Object.keys(t2), r2 = n3.length, i2 = null, o2 = 0;
        return new O(function a3() {
          var u2;
          if (i2) {
            var c4 = i2.next();
            if (c4.done)
              return i2 = null, o2++, a3();
            u2 = c4.value;
          } else {
            if (o2 >= r2)
              return { done: true };
            var d2 = n3[o2];
            if (d2 === e3)
              return o2++, a3();
            if ((u2 = t2[d2]) instanceof Set)
              return i2 = u2.values(), a3();
            o2++;
          }
          return { done: false, value: { edge: u2.key, attributes: u2.attributes, source: u2.source.key, target: u2.target.key, sourceAttributes: u2.source.attributes, targetAttributes: u2.target.attributes, undirected: u2.undirected } };
        });
      }
      function ft(t2, e3, n3) {
        var r2 = e3[n3];
        r2 && t2.push(r2.key);
      }
      function pt(t2, e3, n3) {
        var r2 = e3[n3];
        r2 && r2.forEach(function(e4) {
          return t2.push(e4.key);
        });
      }
      function lt(t2, e3, n3) {
        var r2 = t2[e3];
        if (r2) {
          var i2 = r2.source, o2 = r2.target;
          n3(r2.key, r2.attributes, i2.key, o2.key, i2.attributes, o2.attributes, r2.undirected);
        }
      }
      function gt(t2, e3, n3) {
        var r2 = t2[e3];
        r2 && r2.forEach(function(t3) {
          return n3(t3.key, t3.attributes, t3.source.key, t3.target.key, t3.source.attributes, t3.target.attributes, t3.undirected);
        });
      }
      function yt(t2, e3, n3) {
        var r2 = t2[e3];
        if (r2) {
          var i2 = r2.source, o2 = r2.target;
          return n3(r2.key, r2.attributes, i2.key, o2.key, i2.attributes, o2.attributes, r2.undirected) ? r2.key : void 0;
        }
      }
      function vt(t2, e3, n3) {
        var r2 = t2[e3];
        if (r2) {
          for (var i2, o2, a3 = r2.values(); true !== (i2 = a3.next()).done; )
            if (n3((o2 = i2.value).key, o2.attributes, o2.source.key, o2.target.key, o2.source.attributes, o2.target.attributes, o2.undirected))
              return o2.key;
        }
      }
      function bt(t2, e3) {
        var n3 = t2[e3];
        if (n3 instanceof Set) {
          var r2 = n3.values();
          return new O(function() {
            var t3 = r2.next();
            if (t3.done)
              return t3;
            var e4 = t3.value;
            return { done: false, value: { edge: e4.key, attributes: e4.attributes, source: e4.source.key, target: e4.target.key, sourceAttributes: e4.source.attributes, targetAttributes: e4.target.attributes, undirected: e4.undirected } };
          });
        }
        return O.of([n3.key, n3.attributes, n3.source.key, n3.target.key, n3.source.attributes, n3.target.attributes]);
      }
      function wt(t2, e3) {
        if (0 === t2.size)
          return [];
        if ("mixed" === e3 || e3 === t2.type)
          return "function" == typeof Array.from ? Array.from(t2._edges.keys()) : K(t2._edges.keys(), t2._edges.size);
        for (var n3, r2, i2 = "undirected" === e3 ? t2.undirectedSize : t2.directedSize, o2 = new Array(i2), a3 = "undirected" === e3, u2 = t2._edges.values(), c4 = 0; true !== (n3 = u2.next()).done; )
          (r2 = n3.value).undirected === a3 && (o2[c4++] = r2.key);
        return o2;
      }
      function mt(t2, e3, n3) {
        if (0 !== t2.size) {
          for (var r2, i2, o2 = "mixed" !== e3 && e3 !== t2.type, a3 = "undirected" === e3, u2 = t2._edges.values(); true !== (r2 = u2.next()).done; )
            if (i2 = r2.value, !o2 || i2.undirected === a3) {
              var c4 = i2, d2 = c4.key, s3 = c4.attributes, h2 = c4.source, f2 = c4.target;
              n3(d2, s3, h2.key, f2.key, h2.attributes, f2.attributes, i2.undirected);
            }
        }
      }
      function _t(t2, e3, n3) {
        if (0 !== t2.size) {
          for (var r2, i2, o2 = "mixed" !== e3 && e3 !== t2.type, a3 = "undirected" === e3, u2 = t2._edges.values(); true !== (r2 = u2.next()).done; )
            if (i2 = r2.value, !o2 || i2.undirected === a3) {
              var c4 = i2, d2 = c4.key, s3 = c4.attributes, h2 = c4.source, f2 = c4.target;
              if (n3(d2, s3, h2.key, f2.key, h2.attributes, f2.attributes, i2.undirected))
                return d2;
            }
        }
      }
      function kt(t2, e3) {
        if (0 === t2.size)
          return O.empty();
        var n3 = "mixed" !== e3 && e3 !== t2.type, r2 = "undirected" === e3, i2 = t2._edges.values();
        return new O(function() {
          for (var t3, e4; ; ) {
            if ((t3 = i2.next()).done)
              return t3;
            if (e4 = t3.value, !n3 || e4.undirected === r2)
              break;
          }
          return { value: { edge: e4.key, attributes: e4.attributes, source: e4.source.key, target: e4.target.key, sourceAttributes: e4.source.attributes, targetAttributes: e4.target.attributes, undirected: e4.undirected }, done: false };
        });
      }
      function Gt(t2, e3, n3, r2) {
        var i2 = [], o2 = t2 ? at : ot;
        return "undirected" !== e3 && ("out" !== n3 && o2(i2, r2.in), "in" !== n3 && o2(i2, r2.out), !n3 && r2.directedSelfLoops > 0 && i2.splice(i2.lastIndexOf(r2.key), 1)), "directed" !== e3 && o2(i2, r2.undirected), i2;
      }
      function xt(t2, e3, n3, r2, i2) {
        var o2 = t2 ? ct : ut;
        "undirected" !== e3 && ("out" !== n3 && o2(r2.in, i2), "in" !== n3 && o2(r2.out, i2, n3 ? null : r2.key)), "directed" !== e3 && o2(r2.undirected, i2);
      }
      function Et(t2, e3, n3, r2, i2) {
        var o2, a3 = t2 ? st : dt;
        if ("undirected" !== e3) {
          if ("out" !== n3 && (o2 = a3(r2.in, i2)))
            return o2;
          if ("in" !== n3 && (o2 = a3(r2.out, i2, n3 ? null : r2.key)))
            return o2;
        }
        if ("directed" !== e3 && (o2 = a3(r2.undirected, i2)))
          return o2;
      }
      function St(t2, e3, n3) {
        var r2 = O.empty();
        return "undirected" !== t2 && ("out" !== e3 && void 0 !== n3.in && (r2 = rt(r2, ht(n3.in))), "in" !== e3 && void 0 !== n3.out && (r2 = rt(r2, ht(n3.out, e3 ? null : n3.key)))), "directed" !== t2 && void 0 !== n3.undirected && (r2 = rt(r2, ht(n3.undirected))), r2;
      }
      function At(t2, e3, n3, r2, i2) {
        var o2 = e3 ? pt : ft, a3 = [];
        return "undirected" !== t2 && (void 0 !== r2.in && "out" !== n3 && o2(a3, r2.in, i2), void 0 !== r2.out && "in" !== n3 && o2(a3, r2.out, i2), !n3 && r2.directedSelfLoops > 0 && a3.splice(a3.lastIndexOf(r2.key), 1)), "directed" !== t2 && void 0 !== r2.undirected && o2(a3, r2.undirected, i2), a3;
      }
      function Lt(t2, e3, n3, r2, i2, o2) {
        var a3 = e3 ? gt : lt;
        "undirected" !== t2 && (void 0 !== r2.in && "out" !== n3 && a3(r2.in, i2, o2), r2.key !== i2 && void 0 !== r2.out && "in" !== n3 && a3(r2.out, i2, o2)), "directed" !== t2 && void 0 !== r2.undirected && a3(r2.undirected, i2, o2);
      }
      function Dt(t2, e3, n3, r2, i2, o2) {
        var a3, u2 = e3 ? vt : yt;
        if ("undirected" !== t2) {
          if (void 0 !== r2.in && "out" !== n3 && (a3 = u2(r2.in, i2, o2)))
            return a3;
          if (r2.key !== i2 && void 0 !== r2.out && "in" !== n3 && (a3 = u2(r2.out, i2, o2, n3 ? null : r2.key)))
            return a3;
        }
        if ("directed" !== t2 && void 0 !== r2.undirected && (a3 = u2(r2.undirected, i2, o2)))
          return a3;
      }
      function Nt(t2, e3, n3, r2) {
        var i2 = O.empty();
        return "undirected" !== t2 && (void 0 !== n3.in && "out" !== e3 && r2 in n3.in && (i2 = rt(i2, bt(n3.in, r2))), void 0 !== n3.out && "in" !== e3 && r2 in n3.out && (i2 = rt(i2, bt(n3.out, r2)))), "directed" !== t2 && void 0 !== n3.undirected && r2 in n3.undirected && (i2 = rt(i2, bt(n3.undirected, r2))), i2;
      }
      var Ut = [{ name: "neighbors", type: "mixed" }, { name: "inNeighbors", type: "directed", direction: "in" }, { name: "outNeighbors", type: "directed", direction: "out" }, { name: "inboundNeighbors", type: "mixed", direction: "in" }, { name: "outboundNeighbors", type: "mixed", direction: "out" }, { name: "directedNeighbors", type: "directed" }, { name: "undirectedNeighbors", type: "undirected" }];
      function jt(t2, e3) {
        if (void 0 !== e3)
          for (var n3 in e3)
            t2.add(n3);
      }
      function Ot(t2, e3, n3) {
        for (var r2 in e3) {
          var i2 = e3[r2];
          i2 instanceof Set && (i2 = i2.values().next().value);
          var o2 = i2.source, a3 = i2.target, u2 = o2 === t2 ? a3 : o2;
          n3(u2.key, u2.attributes);
        }
      }
      function Ct(t2, e3, n3, r2) {
        for (var i2 in n3) {
          var o2 = n3[i2];
          o2 instanceof Set && (o2 = o2.values().next().value);
          var a3 = o2.source, u2 = o2.target, c4 = a3 === e3 ? u2 : a3;
          t2.has(c4.key) || (t2.add(c4.key), r2(c4.key, c4.attributes));
        }
      }
      function zt(t2, e3, n3) {
        for (var r2 in e3) {
          var i2 = e3[r2];
          i2 instanceof Set && (i2 = i2.values().next().value);
          var o2 = i2.source, a3 = i2.target, u2 = o2 === t2 ? a3 : o2;
          if (n3(u2.key, u2.attributes))
            return u2.key;
        }
      }
      function Mt(t2, e3, n3, r2) {
        for (var i2 in n3) {
          var o2 = n3[i2];
          o2 instanceof Set && (o2 = o2.values().next().value);
          var a3 = o2.source, u2 = o2.target, c4 = a3 === e3 ? u2 : a3;
          if (!t2.has(c4.key)) {
            if (t2.add(c4.key), r2(c4.key, c4.attributes))
              return c4.key;
          }
        }
      }
      function Pt(t2, e3) {
        var n3 = Object.keys(e3), r2 = n3.length, i2 = 0;
        return new O(function() {
          if (i2 >= r2)
            return { done: true };
          var o2 = e3[n3[i2++]];
          o2 instanceof Set && (o2 = o2.values().next().value);
          var a3 = o2.source, u2 = o2.target, c4 = a3 === t2 ? u2 : a3;
          return { done: false, value: { neighbor: c4.key, attributes: c4.attributes } };
        });
      }
      function Tt(t2, e3, n3) {
        var r2 = Object.keys(n3), i2 = r2.length, o2 = 0;
        return new O(function a3() {
          if (o2 >= i2)
            return { done: true };
          var u2 = n3[r2[o2++]];
          u2 instanceof Set && (u2 = u2.values().next().value);
          var c4 = u2.source, d2 = u2.target, s3 = c4 === e3 ? d2 : c4;
          return t2.has(s3.key) ? a3() : (t2.add(s3.key), { done: false, value: { neighbor: s3.key, attributes: s3.attributes } });
        });
      }
      function Rt(t2, e3) {
        var n3 = e3.name, r2 = e3.type, i2 = e3.direction;
        t2.prototype[n3] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return [];
          t3 = "" + t3;
          var e4 = this._nodes.get(t3);
          if (void 0 === e4)
            throw new Y2("Graph.".concat(n3, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e6, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return Object.keys(n4.undirected);
              if ("string" == typeof e6)
                return Object.keys(n4[e6]);
            }
            var r3 = /* @__PURE__ */ new Set();
            return "undirected" !== t4 && ("out" !== e6 && jt(r3, n4.in), "in" !== e6 && jt(r3, n4.out)), "directed" !== t4 && jt(r3, n4.undirected), K(r3.values(), r3.size);
          }("mixed" === r2 ? this.type : r2, i2, e4);
        };
      }
      function Wt(t2, e3) {
        var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
        t2.prototype[o2] = function(t3, e4) {
          if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
            t3 = "" + t3;
            var n4 = this._nodes.get(t3);
            if (void 0 === n4)
              throw new Y2("Graph.".concat(o2, ': could not find the "').concat(t3, '" node in the graph.'));
            !function(t4, e6, n5, r3) {
              if ("mixed" !== t4) {
                if ("undirected" === t4)
                  return Ot(n5, n5.undirected, r3);
                if ("string" == typeof e6)
                  return Ot(n5, n5[e6], r3);
              }
              var i3 = /* @__PURE__ */ new Set();
              "undirected" !== t4 && ("out" !== e6 && Ct(i3, n5, n5.in, r3), "in" !== e6 && Ct(i3, n5, n5.out, r3)), "directed" !== t4 && Ct(i3, n5, n5.undirected, r3);
            }("mixed" === r2 ? this.type : r2, i2, n4, e4);
          }
        };
        var a3 = "map" + n3[0].toUpperCase() + n3.slice(1);
        t2.prototype[a3] = function(t3, e4) {
          var n4 = [];
          return this[o2](t3, function(t4, r3) {
            n4.push(e4(t4, r3));
          }), n4;
        };
        var u2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
        t2.prototype[u2] = function(t3, e4) {
          var n4 = [];
          return this[o2](t3, function(t4, r3) {
            e4(t4, r3) && n4.push(t4);
          }), n4;
        };
        var c4 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
        t2.prototype[c4] = function(t3, e4, n4) {
          if (arguments.length < 3)
            throw new F("Graph.".concat(c4, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
          var r3 = n4;
          return this[o2](t3, function(t4, n5) {
            r3 = e4(r3, t4, n5);
          }), r3;
        };
      }
      function Kt(t2, e3) {
        var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3[0].toUpperCase() + n3.slice(1, -1), a3 = "find" + o2;
        t2.prototype[a3] = function(t3, e4) {
          if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
            t3 = "" + t3;
            var n4 = this._nodes.get(t3);
            if (void 0 === n4)
              throw new Y2("Graph.".concat(a3, ': could not find the "').concat(t3, '" node in the graph.'));
            return function(t4, e6, n5, r3) {
              if ("mixed" !== t4) {
                if ("undirected" === t4)
                  return zt(n5, n5.undirected, r3);
                if ("string" == typeof e6)
                  return zt(n5, n5[e6], r3);
              }
              var i3, o3 = /* @__PURE__ */ new Set();
              if ("undirected" !== t4) {
                if ("out" !== e6 && (i3 = Mt(o3, n5, n5.in, r3)))
                  return i3;
                if ("in" !== e6 && (i3 = Mt(o3, n5, n5.out, r3)))
                  return i3;
              }
              if ("directed" !== t4 && (i3 = Mt(o3, n5, n5.undirected, r3)))
                return i3;
            }("mixed" === r2 ? this.type : r2, i2, n4, e4);
          }
        };
        var u2 = "some" + o2;
        t2.prototype[u2] = function(t3, e4) {
          return !!this[a3](t3, e4);
        };
        var c4 = "every" + o2;
        t2.prototype[c4] = function(t3, e4) {
          return !this[a3](t3, function(t4, n4) {
            return !e4(t4, n4);
          });
        };
      }
      function It(t2, e3) {
        var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3.slice(0, -1) + "Entries";
        t2.prototype[o2] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return O.empty();
          t3 = "" + t3;
          var e4 = this._nodes.get(t3);
          if (void 0 === e4)
            throw new Y2("Graph.".concat(o2, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e6, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return Pt(n4, n4.undirected);
              if ("string" == typeof e6)
                return Pt(n4, n4[e6]);
            }
            var r3 = O.empty(), i3 = /* @__PURE__ */ new Set();
            return "undirected" !== t4 && ("out" !== e6 && (r3 = rt(r3, Tt(i3, n4, n4.in))), "in" !== e6 && (r3 = rt(r3, Tt(i3, n4, n4.out)))), "directed" !== t4 && (r3 = rt(r3, Tt(i3, n4, n4.undirected))), r3;
          }("mixed" === r2 ? this.type : r2, i2, e4);
        };
      }
      function Ft(t2, e3, n3, r2, i2) {
        for (var o2, a3, u2, c4, d2, s3, h2, f2 = r2._nodes.values(), p2 = r2.type; true !== (o2 = f2.next()).done; ) {
          var l3 = false;
          if (a3 = o2.value, "undirected" !== p2) {
            for (u2 in c4 = a3.out)
              if (s3 = (d2 = c4[u2]).target, l3 = true, h2 = i2(a3.key, s3.key, a3.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2)
                return d2;
          }
          if ("directed" !== p2) {
            for (u2 in c4 = a3.undirected)
              if (!(e3 && a3.key > u2) && ((s3 = (d2 = c4[u2]).target).key !== u2 && (s3 = d2.source), l3 = true, h2 = i2(a3.key, s3.key, a3.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2))
                return d2;
          }
          if (n3 && !l3 && (h2 = i2(a3.key, null, a3.attributes, null, null, null, null), t2 && h2))
            return null;
        }
      }
      function Yt(t2, e3, n3, r2, i2) {
        for (var o2, a3, u2, c4, d2, s3, h2, f2, p2, l3 = r2._nodes.values(), g2 = r2.type; true !== (o2 = l3.next()).done; ) {
          var y5 = false;
          if (a3 = o2.value, "undirected" !== g2) {
            for (u2 in s3 = a3.out)
              for (c4 = s3[u2].values(); true !== (d2 = c4.next()).done; )
                if (f2 = (h2 = d2.value).target, y5 = true, p2 = i2(a3.key, f2.key, a3.attributes, f2.attributes, h2.key, h2.attributes, h2.undirected), t2 && p2)
                  return h2;
          }
          if ("directed" !== g2) {
            for (u2 in s3 = a3.undirected)
              if (!(e3 && a3.key > u2)) {
                for (c4 = s3[u2].values(); true !== (d2 = c4.next()).done; )
                  if ((f2 = (h2 = d2.value).target).key !== u2 && (f2 = h2.source), y5 = true, p2 = i2(a3.key, f2.key, a3.attributes, f2.attributes, h2.key, h2.attributes, h2.undirected), t2 && p2)
                    return h2;
              }
          }
          if (n3 && !y5 && (p2 = i2(a3.key, null, a3.attributes, null, null, null, null), t2 && p2))
            return null;
        }
      }
      function Bt(t2, e3) {
        var n3 = { key: t2 };
        return f(e3.attributes) || (n3.attributes = c3({}, e3.attributes)), n3;
      }
      function qt(t2, e3) {
        var n3 = { key: t2, source: e3.source.key, target: e3.target.key };
        return f(e3.attributes) || (n3.attributes = c3({}, e3.attributes)), e3.undirected && (n3.undirected = true), n3;
      }
      function Jt(t2) {
        return h(t2) ? "key" in t2 ? !("attributes" in t2) || h(t2.attributes) && null !== t2.attributes ? null : "invalid-attributes" : "no-key" : "not-object";
      }
      function Vt(t2) {
        return h(t2) ? "source" in t2 ? "target" in t2 ? !("attributes" in t2) || h(t2.attributes) && null !== t2.attributes ? "undirected" in t2 && "boolean" != typeof t2.undirected ? "invalid-undirected" : null : "invalid-attributes" : "no-target" : "no-source" : "not-object";
      }
      var Ht, Qt = (Ht = 255 & Math.floor(256 * Math.random()), function() {
        return Ht++;
      }), Xt = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]), Zt = /* @__PURE__ */ new Set(["domain", "_events", "_eventsCount", "_maxListeners"]), $t = { allowSelfLoops: true, multi: false, type: "mixed" };
      function te(t2, e3, n3) {
        var r2 = new t2.NodeDataClass(e3, n3);
        return t2._nodes.set(e3, r2), t2.emit("nodeAdded", { key: e3, attributes: n3 }), r2;
      }
      function ee(t2, e3, n3, r2, i2, o2, a3, u2) {
        if (!r2 && "undirected" === t2.type)
          throw new B2("Graph.".concat(e3, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new B2("Graph.".concat(e3, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));
        if (u2 && !h(u2))
          throw new F("Graph.".concat(e3, ': invalid attributes. Expecting an object but got "').concat(u2, '"'));
        if (o2 = "" + o2, a3 = "" + a3, u2 = u2 || {}, !t2.allowSelfLoops && o2 === a3)
          throw new B2("Graph.".concat(e3, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var c4 = t2._nodes.get(o2), d2 = t2._nodes.get(a3);
        if (!c4)
          throw new Y2("Graph.".concat(e3, ': source node "').concat(o2, '" not found.'));
        if (!d2)
          throw new Y2("Graph.".concat(e3, ': target node "').concat(a3, '" not found.'));
        var s3 = { key: null, undirected: r2, source: o2, target: a3, attributes: u2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new B2("Graph.".concat(e3, ': the "').concat(i2, '" edge already exists in the graph.'));
        if (!t2.multi && (r2 ? void 0 !== c4.undirected[a3] : void 0 !== c4.out[a3]))
          throw new B2("Graph.".concat(e3, ': an edge linking "').concat(o2, '" to "').concat(a3, `" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));
        var f2 = new H(r2, i2, c4, d2, u2);
        return t2._edges.set(i2, f2), o2 === a3 ? r2 ? (c4.undirectedSelfLoops++, t2._undirectedSelfLoopCount++) : (c4.directedSelfLoops++, t2._directedSelfLoopCount++) : r2 ? (c4.undirectedDegree++, d2.undirectedDegree++) : (c4.outDegree++, d2.inDegree++), Q(t2, r2, f2, o2, a3, c4, d2), r2 ? t2._undirectedSize++ : t2._directedSize++, s3.key = i2, t2.emit("edgeAdded", s3), i2;
      }
      function ne(t2, e3, n3, r2, i2, o2, a3, u2, d2) {
        if (!r2 && "undirected" === t2.type)
          throw new B2("Graph.".concat(e3, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new B2("Graph.".concat(e3, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));
        if (u2) {
          if (d2) {
            if ("function" != typeof u2)
              throw new F("Graph.".concat(e3, ': invalid updater function. Expecting a function but got "').concat(u2, '"'));
          } else if (!h(u2))
            throw new F("Graph.".concat(e3, ': invalid attributes. Expecting an object but got "').concat(u2, '"'));
        }
        var s3;
        if (o2 = "" + o2, a3 = "" + a3, d2 && (s3 = u2, u2 = void 0), !t2.allowSelfLoops && o2 === a3)
          throw new B2("Graph.".concat(e3, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var f2, p2, l3 = t2._nodes.get(o2), g2 = t2._nodes.get(a3);
        if (!n3 && (f2 = t2._edges.get(i2))) {
          if (!(f2.source.key === o2 && f2.target.key === a3 || r2 && f2.source.key === a3 && f2.target.key === o2))
            throw new B2("Graph.".concat(e3, ': inconsistency detected when attempting to merge the "').concat(i2, '" edge with "').concat(o2, '" source & "').concat(a3, '" target vs. ("').concat(f2.source.key, '", "').concat(f2.target.key, '").'));
          p2 = f2;
        }
        if (p2 || t2.multi || !l3 || (p2 = r2 ? l3.undirected[a3] : l3.out[a3]), p2) {
          var y5 = [p2.key, false, false, false];
          if (d2 ? !s3 : !u2)
            return y5;
          if (d2) {
            var v2 = p2.attributes;
            p2.attributes = s3(v2), t2.emit("edgeAttributesUpdated", { type: "replace", key: p2.key, attributes: p2.attributes });
          } else
            c3(p2.attributes, u2), t2.emit("edgeAttributesUpdated", { type: "merge", key: p2.key, attributes: p2.attributes, data: u2 });
          return y5;
        }
        u2 = u2 || {}, d2 && s3 && (u2 = s3(u2));
        var b2 = { key: null, undirected: r2, source: o2, target: a3, attributes: u2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new B2("Graph.".concat(e3, ': the "').concat(i2, '" edge already exists in the graph.'));
        var w2 = false, m3 = false;
        return l3 || (l3 = te(t2, o2, {}), w2 = true, o2 === a3 && (g2 = l3, m3 = true)), g2 || (g2 = te(t2, a3, {}), m3 = true), f2 = new H(r2, i2, l3, g2, u2), t2._edges.set(i2, f2), o2 === a3 ? r2 ? (l3.undirectedSelfLoops++, t2._undirectedSelfLoopCount++) : (l3.directedSelfLoops++, t2._directedSelfLoopCount++) : r2 ? (l3.undirectedDegree++, g2.undirectedDegree++) : (l3.outDegree++, g2.inDegree++), Q(t2, r2, f2, o2, a3, l3, g2), r2 ? t2._undirectedSize++ : t2._directedSize++, b2.key = i2, t2.emit("edgeAdded", b2), [i2, true, w2, m3];
      }
      var re2 = function(n3) {
        function r2(t2) {
          var e3;
          if (e3 = n3.call(this) || this, "boolean" != typeof (t2 = c3({}, $t, t2)).multi)
            throw new F(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(t2.multi, '".'));
          if (!Xt.has(t2.type))
            throw new F(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(t2.type, '".'));
          if ("boolean" != typeof t2.allowSelfLoops)
            throw new F(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(t2.allowSelfLoops, '".'));
          var r3 = "mixed" === t2.type ? q : "directed" === t2.type ? J : V;
          p(u(e3), "NodeDataClass", r3);
          var i3 = Qt(), o2 = 0;
          return p(u(e3), "_attributes", {}), p(u(e3), "_nodes", /* @__PURE__ */ new Map()), p(u(e3), "_edges", /* @__PURE__ */ new Map()), p(u(e3), "_directedSize", 0), p(u(e3), "_undirectedSize", 0), p(u(e3), "_directedSelfLoopCount", 0), p(u(e3), "_undirectedSelfLoopCount", 0), p(u(e3), "_edgeKeyGenerator", function() {
            var t3;
            do {
              t3 = "geid_" + i3 + "_" + o2++;
            } while (e3._edges.has(t3));
            return t3;
          }), p(u(e3), "_options", t2), Zt.forEach(function(t3) {
            return p(u(e3), t3, e3[t3]);
          }), l2(u(e3), "order", function() {
            return e3._nodes.size;
          }), l2(u(e3), "size", function() {
            return e3._edges.size;
          }), l2(u(e3), "directedSize", function() {
            return e3._directedSize;
          }), l2(u(e3), "undirectedSize", function() {
            return e3._undirectedSize;
          }), l2(u(e3), "selfLoopCount", function() {
            return e3._directedSelfLoopCount + e3._undirectedSelfLoopCount;
          }), l2(u(e3), "directedSelfLoopCount", function() {
            return e3._directedSelfLoopCount;
          }), l2(u(e3), "undirectedSelfLoopCount", function() {
            return e3._undirectedSelfLoopCount;
          }), l2(u(e3), "multi", e3._options.multi), l2(u(e3), "type", e3._options.type), l2(u(e3), "allowSelfLoops", e3._options.allowSelfLoops), l2(u(e3), "implementation", function() {
            return "graphology";
          }), e3;
        }
        e(r2, n3);
        var i2 = r2.prototype;
        return i2._resetInstanceCounters = function() {
          this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0;
        }, i2.hasNode = function(t2) {
          return this._nodes.has("" + t2);
        }, i2.hasDirectedEdge = function(t2, e3) {
          if ("undirected" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && !r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e3 = "" + e3;
            var i3 = this._nodes.get(t2);
            if (!i3)
              return false;
            var o2 = i3.out[e3];
            return !!o2 && (!this.multi || !!o2.size);
          }
          throw new F("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasUndirectedEdge = function(t2, e3) {
          if ("directed" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e3 = "" + e3;
            var i3 = this._nodes.get(t2);
            if (!i3)
              return false;
            var o2 = i3.undirected[e3];
            return !!o2 && (!this.multi || !!o2.size);
          }
          throw new F("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasEdge = function(t2, e3) {
          if (1 === arguments.length) {
            var n4 = "" + t2;
            return this._edges.has(n4);
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e3 = "" + e3;
            var r3 = this._nodes.get(t2);
            if (!r3)
              return false;
            var i3 = void 0 !== r3.out && r3.out[e3];
            return i3 || (i3 = void 0 !== r3.undirected && r3.undirected[e3]), !!i3 && (!this.multi || !!i3.size);
          }
          throw new F("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.directedEdge = function(t2, e3) {
          if ("undirected" !== this.type) {
            if (t2 = "" + t2, e3 = "" + e3, this.multi)
              throw new B2("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new Y2('Graph.directedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e3))
              throw new Y2('Graph.directedEdge: could not find the "'.concat(e3, '" target node in the graph.'));
            var r3 = n4.out && n4.out[e3] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.undirectedEdge = function(t2, e3) {
          if ("directed" !== this.type) {
            if (t2 = "" + t2, e3 = "" + e3, this.multi)
              throw new B2("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new Y2('Graph.undirectedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e3))
              throw new Y2('Graph.undirectedEdge: could not find the "'.concat(e3, '" target node in the graph.'));
            var r3 = n4.undirected && n4.undirected[e3] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.edge = function(t2, e3) {
          if (this.multi)
            throw new B2("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.edge: could not find the "'.concat(t2, '" source node in the graph.'));
          if (!this._nodes.has(e3))
            throw new Y2('Graph.edge: could not find the "'.concat(e3, '" target node in the graph.'));
          var r3 = n4.out && n4.out[e3] || n4.undirected && n4.undirected[e3] || void 0;
          if (r3)
            return r3.key;
        }, i2.areDirectedNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areDirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e3 in n4.in || e3 in n4.out);
        }, i2.areOutNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areOutNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e3 in n4.out;
        }, i2.areInNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areInNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e3 in n4.in;
        }, i2.areUndirectedNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areUndirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" !== this.type && e3 in n4.undirected;
        }, i2.areNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e3 in n4.in || e3 in n4.out) || "directed" !== this.type && e3 in n4.undirected;
        }, i2.areInboundNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areInboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e3 in n4.in || "directed" !== this.type && e3 in n4.undirected;
        }, i2.areOutboundNeighbors = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.areOutboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e3 in n4.out || "directed" !== this.type && e3 in n4.undirected;
        }, i2.inDegree = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.inDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e3.inDegree + e3.directedSelfLoops;
        }, i2.outDegree = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.outDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e3.outDegree + e3.directedSelfLoops;
        }, i2.directedDegree = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.directedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          if ("undirected" === this.type)
            return 0;
          var n4 = e3.directedSelfLoops;
          return e3.inDegree + n4 + (e3.outDegree + n4);
        }, i2.undirectedDegree = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.undirectedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          if ("directed" === this.type)
            return 0;
          var n4 = e3.undirectedSelfLoops;
          return e3.undirectedDegree + 2 * n4;
        }, i2.degree = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.degree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e3.undirectedDegree + 2 * e3.undirectedSelfLoops), "undirected" !== this.type && (n4 += e3.inDegree + e3.outDegree + 2 * e3.directedSelfLoops), n4;
        }, i2.inDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e3.inDegree;
        }, i2.outDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e3.outDegree;
        }, i2.directedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e3.inDegree + e3.outDegree;
        }, i2.undirectedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" === this.type ? 0 : e3.undirectedDegree;
        }, i2.degreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e3.undirectedDegree), "undirected" !== this.type && (n4 += e3.inDegree + e3.outDegree), n4;
        }, i2.source = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.source: could not find the "'.concat(t2, '" edge in the graph.'));
          return e3.source.key;
        }, i2.target = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.target: could not find the "'.concat(t2, '" edge in the graph.'));
          return e3.target.key;
        }, i2.extremities = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.extremities: could not find the "'.concat(t2, '" edge in the graph.'));
          return [e3.source.key, e3.target.key];
        }, i2.opposite = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._edges.get(e3);
          if (!n4)
            throw new Y2('Graph.opposite: could not find the "'.concat(e3, '" edge in the graph.'));
          var r3 = n4.source.key, i3 = n4.target.key;
          if (t2 === r3)
            return i3;
          if (t2 === i3)
            return r3;
          throw new Y2('Graph.opposite: the "'.concat(t2, '" node is not attached to the "').concat(e3, '" edge (').concat(r3, ", ").concat(i3, ")."));
        }, i2.hasExtremity = function(t2, e3) {
          t2 = "" + t2, e3 = "" + e3;
          var n4 = this._edges.get(t2);
          if (!n4)
            throw new Y2('Graph.hasExtremity: could not find the "'.concat(t2, '" edge in the graph.'));
          return n4.source.key === e3 || n4.target.key === e3;
        }, i2.isUndirected = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.isUndirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return e3.undirected;
        }, i2.isDirected = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.isDirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return !e3.undirected;
        }, i2.isSelfLoop = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.isSelfLoop: could not find the "'.concat(t2, '" edge in the graph.'));
          return e3.source === e3.target;
        }, i2.addNode = function(t2, e3) {
          var n4 = function(t3, e4, n5) {
            if (n5 && !h(n5))
              throw new F('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n5, '"'));
            if (e4 = "" + e4, n5 = n5 || {}, t3._nodes.has(e4))
              throw new B2('Graph.addNode: the "'.concat(e4, '" node already exist in the graph.'));
            var r3 = new t3.NodeDataClass(e4, n5);
            return t3._nodes.set(e4, r3), t3.emit("nodeAdded", { key: e4, attributes: n5 }), r3;
          }(this, t2, e3);
          return n4.key;
        }, i2.mergeNode = function(t2, e3) {
          if (e3 && !h(e3))
            throw new F('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e3, '"'));
          t2 = "" + t2, e3 = e3 || {};
          var n4 = this._nodes.get(t2);
          return n4 ? (e3 && (c3(n4.attributes, e3), this.emit("nodeAttributesUpdated", { type: "merge", key: t2, attributes: n4.attributes, data: e3 })), [t2, false]) : (n4 = new this.NodeDataClass(t2, e3), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: e3 }), [t2, true]);
        }, i2.updateNode = function(t2, e3) {
          if (e3 && "function" != typeof e3)
            throw new F('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e3, '"'));
          t2 = "" + t2;
          var n4 = this._nodes.get(t2);
          if (n4) {
            if (e3) {
              var r3 = n4.attributes;
              n4.attributes = e3(r3), this.emit("nodeAttributesUpdated", { type: "replace", key: t2, attributes: n4.attributes });
            }
            return [t2, false];
          }
          var i3 = e3 ? e3({}) : {};
          return n4 = new this.NodeDataClass(t2, i3), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: i3 }), [t2, true];
        }, i2.dropNode = function(t2) {
          var e3 = this;
          t2 = "" + t2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new Y2('Graph.dropNode: could not find the "'.concat(t2, '" node in the graph.'));
          this.forEachEdge(t2, function(t3) {
            e3.dropEdge(t3);
          }), this._nodes.delete(t2), this.emit("nodeDropped", { key: t2, attributes: n4.attributes });
        }, i2.dropEdge = function(t2) {
          var e3;
          if (arguments.length > 1) {
            var n4 = "" + arguments[0], r3 = "" + arguments[1];
            if (!(e3 = d(this, n4, r3, this.type)))
              throw new Y2('Graph.dropEdge: could not find the "'.concat(n4, '" -> "').concat(r3, '" edge in the graph.'));
          } else if (t2 = "" + t2, !(e3 = this._edges.get(t2)))
            throw new Y2('Graph.dropEdge: could not find the "'.concat(t2, '" edge in the graph.'));
          this._edges.delete(e3.key);
          var i3 = e3, o2 = i3.source, a3 = i3.target, u2 = i3.attributes, c4 = e3.undirected;
          return o2 === a3 ? c4 ? (o2.undirectedSelfLoops--, this._undirectedSelfLoopCount--) : (o2.directedSelfLoops--, this._directedSelfLoopCount--) : c4 ? (o2.undirectedDegree--, a3.undirectedDegree--) : (o2.outDegree--, a3.inDegree--), X2(this, c4, e3), c4 ? this._undirectedSize-- : this._directedSize--, this.emit("edgeDropped", { key: t2, attributes: u2, source: o2.key, target: a3.key, undirected: c4 }), this;
        }, i2.clear = function() {
          this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit("cleared");
        }, i2.clearEdges = function() {
          !function(t2) {
            for (var e3, n4 = t2._nodes.values(); true !== (e3 = n4.next()).done; )
              e3.value.clear();
          }(this), this._edges.clear(), this._resetInstanceCounters(), this.emit("edgesCleared");
        }, i2.getAttribute = function(t2) {
          return this._attributes[t2];
        }, i2.getAttributes = function() {
          return this._attributes;
        }, i2.hasAttribute = function(t2) {
          return this._attributes.hasOwnProperty(t2);
        }, i2.setAttribute = function(t2, e3) {
          return this._attributes[t2] = e3, this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.updateAttribute = function(t2, e3) {
          if ("function" != typeof e3)
            throw new F("Graph.updateAttribute: updater should be a function.");
          var n4 = this._attributes[t2];
          return this._attributes[t2] = e3(n4), this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.removeAttribute = function(t2) {
          return delete this._attributes[t2], this.emit("attributesUpdated", { type: "remove", attributes: this._attributes, name: t2 }), this;
        }, i2.replaceAttributes = function(t2) {
          if (!h(t2))
            throw new F("Graph.replaceAttributes: provided attributes are not a plain object.");
          return this._attributes = t2, this.emit("attributesUpdated", { type: "replace", attributes: this._attributes }), this;
        }, i2.mergeAttributes = function(t2) {
          if (!h(t2))
            throw new F("Graph.mergeAttributes: provided attributes are not a plain object.");
          return c3(this._attributes, t2), this.emit("attributesUpdated", { type: "merge", attributes: this._attributes, data: t2 }), this;
        }, i2.updateAttributes = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.updateAttributes: provided updater is not a function.");
          return this._attributes = t2(this._attributes), this.emit("attributesUpdated", { type: "update", attributes: this._attributes }), this;
        }, i2.updateEachNodeAttributes = function(t2, e3) {
          if ("function" != typeof t2)
            throw new F("Graph.updateEachNodeAttributes: expecting an updater function.");
          if (e3 && !g(e3))
            throw new F("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3 = this._nodes.values(); true !== (n4 = i3.next()).done; )
            (r3 = n4.value).attributes = t2(r3.key, r3.attributes);
          this.emit("eachNodeAttributesUpdated", { hints: e3 || null });
        }, i2.updateEachEdgeAttributes = function(t2, e3) {
          if ("function" != typeof t2)
            throw new F("Graph.updateEachEdgeAttributes: expecting an updater function.");
          if (e3 && !g(e3))
            throw new F("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3, o2, a3 = this._edges.values(); true !== (n4 = a3.next()).done; )
            i3 = (r3 = n4.value).source, o2 = r3.target, r3.attributes = t2(r3.key, r3.attributes, i3.key, o2.key, i3.attributes, o2.attributes, r3.undirected);
          this.emit("eachEdgeAttributesUpdated", { hints: e3 || null });
        }, i2.forEachAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.forEachAdjacencyEntry: expecting a callback.");
          this.multi ? Yt(false, false, false, this, t2) : Ft(false, false, false, this, t2);
        }, i2.forEachAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");
          this.multi ? Yt(false, false, true, this, t2) : Ft(false, false, true, this, t2);
        }, i2.forEachAssymetricAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");
          this.multi ? Yt(false, true, false, this, t2) : Ft(false, true, false, this, t2);
        }, i2.forEachAssymetricAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");
          this.multi ? Yt(false, true, true, this, t2) : Ft(false, true, true, this, t2);
        }, i2.nodes = function() {
          return "function" == typeof Array.from ? Array.from(this._nodes.keys()) : K(this._nodes.keys(), this._nodes.size);
        }, i2.forEachNode = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.forEachNode: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(); true !== (e3 = r3.next()).done; )
            t2((n4 = e3.value).key, n4.attributes);
        }, i2.findNode = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.findNode: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(); true !== (e3 = r3.next()).done; )
            if (t2((n4 = e3.value).key, n4.attributes))
              return n4.key;
        }, i2.mapNodes = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.mapNode: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(), i3 = new Array(this.order), o2 = 0; true !== (e3 = r3.next()).done; )
            n4 = e3.value, i3[o2++] = t2(n4.key, n4.attributes);
          return i3;
        }, i2.someNode = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.someNode: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(); true !== (e3 = r3.next()).done; )
            if (t2((n4 = e3.value).key, n4.attributes))
              return true;
          return false;
        }, i2.everyNode = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.everyNode: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(); true !== (e3 = r3.next()).done; )
            if (!t2((n4 = e3.value).key, n4.attributes))
              return false;
          return true;
        }, i2.filterNodes = function(t2) {
          if ("function" != typeof t2)
            throw new F("Graph.filterNodes: expecting a callback.");
          for (var e3, n4, r3 = this._nodes.values(), i3 = []; true !== (e3 = r3.next()).done; )
            t2((n4 = e3.value).key, n4.attributes) && i3.push(n4.key);
          return i3;
        }, i2.reduceNodes = function(t2, e3) {
          if ("function" != typeof t2)
            throw new F("Graph.reduceNodes: expecting a callback.");
          if (arguments.length < 2)
            throw new F("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");
          for (var n4, r3, i3 = e3, o2 = this._nodes.values(); true !== (n4 = o2.next()).done; )
            i3 = t2(i3, (r3 = n4.value).key, r3.attributes);
          return i3;
        }, i2.nodeEntries = function() {
          var t2 = this._nodes.values();
          return new O(function() {
            var e3 = t2.next();
            if (e3.done)
              return e3;
            var n4 = e3.value;
            return { value: { node: n4.key, attributes: n4.attributes }, done: false };
          });
        }, i2.exportNode = function(t2) {
          t2 = "" + t2;
          var e3 = this._nodes.get(t2);
          if (!e3)
            throw new Y2('Graph.exportNode: could not find the "'.concat(t2, '" node in the graph.'));
          return Bt(t2, e3);
        }, i2.exportEdge = function(t2) {
          t2 = "" + t2;
          var e3 = this._edges.get(t2);
          if (!e3)
            throw new Y2('Graph.exportEdge: could not find the "'.concat(t2, '" edge in the graph.'));
          return qt(t2, e3);
        }, i2.export = function() {
          var t2 = new Array(this._nodes.size), e3 = 0;
          this._nodes.forEach(function(n5, r3) {
            t2[e3++] = Bt(r3, n5);
          });
          var n4 = new Array(this._edges.size);
          return e3 = 0, this._edges.forEach(function(t3, r3) {
            n4[e3++] = qt(r3, t3);
          }), { attributes: this.getAttributes(), nodes: t2, edges: n4, options: { type: this.type, multi: this.multi, allowSelfLoops: this.allowSelfLoops } };
        }, i2.importNode = function(t2) {
          var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n4 = Jt(t2);
          if (n4) {
            if ("not-object" === n4)
              throw new F('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
            if ("no-key" === n4)
              throw new F("Graph.importNode: no key provided.");
            if ("invalid-attributes" === n4)
              throw new F("Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.");
          }
          var r3 = t2.key, i3 = t2.attributes, o2 = void 0 === i3 ? {} : i3;
          return e3 ? this.mergeNode(r3, o2) : this.addNode(r3, o2), this;
        }, i2.importEdge = function(t2) {
          var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n4 = Vt(t2);
          if (n4) {
            if ("not-object" === n4)
              throw new F('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
            if ("no-source" === n4)
              throw new F("Graph.importEdge: missing souce.");
            if ("no-target" === n4)
              throw new F("Graph.importEdge: missing target.");
            if ("invalid-attributes" === n4)
              throw new F("Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.");
            if ("invalid-undirected" === n4)
              throw new F("Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.");
          }
          var r3 = t2.source, i3 = t2.target, o2 = t2.attributes, a3 = void 0 === o2 ? {} : o2, u2 = t2.undirected, c4 = void 0 !== u2 && u2;
          return "key" in t2 ? (e3 ? c4 ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : c4 ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, t2.key, r3, i3, a3) : (e3 ? c4 ? this.mergeUndirectedEdge : this.mergeDirectedEdge : c4 ? this.addUndirectedEdge : this.addDirectedEdge).call(this, r3, i3, a3), this;
        }, i2.import = function(t2) {
          var e3, n4, r3, i3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (s2(t2))
            return this.import(t2.export(), i3), this;
          if (!h(t2))
            throw new F("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
          if (t2.attributes) {
            if (!h(t2.attributes))
              throw new F("Graph.import: invalid attributes. Expecting a plain object.");
            i3 ? this.mergeAttributes(t2.attributes) : this.replaceAttributes(t2.attributes);
          }
          if (t2.nodes) {
            if (r3 = t2.nodes, !Array.isArray(r3))
              throw new F("Graph.import: invalid nodes. Expecting an array.");
            for (e3 = 0, n4 = r3.length; e3 < n4; e3++)
              this.importNode(r3[e3], i3);
          }
          if (t2.edges) {
            if (r3 = t2.edges, !Array.isArray(r3))
              throw new F("Graph.import: invalid edges. Expecting an array.");
            for (e3 = 0, n4 = r3.length; e3 < n4; e3++)
              this.importEdge(r3[e3], i3);
          }
          return this;
        }, i2.nullCopy = function(t2) {
          var e3 = new r2(c3({}, this._options, t2));
          return e3.replaceAttributes(c3({}, this.getAttributes())), e3;
        }, i2.emptyCopy = function(t2) {
          var e3 = this.nullCopy(t2);
          return this._nodes.forEach(function(t3, n4) {
            var r3 = c3({}, t3.attributes);
            t3 = new e3.NodeDataClass(n4, r3), e3._nodes.set(n4, t3);
          }), e3;
        }, i2.copy = function() {
          for (var t2, e3, n4 = this.emptyCopy(), r3 = this._edges.values(); true !== (t2 = r3.next()).done; )
            ee(n4, "copy", false, (e3 = t2.value).undirected, e3.key, e3.source.key, e3.target.key, c3({}, e3.attributes));
          return n4;
        }, i2.upgradeToMixed = function() {
          return "mixed" === this.type || (this._nodes.forEach(function(t2) {
            return t2.upgradeToMixed();
          }), this._options.type = "mixed", l2(this, "type", this._options.type), p(this, "NodeDataClass", q)), this;
        }, i2.upgradeToMulti = function() {
          return this.multi || (this._options.multi = true, l2(this, "multi", true), (t2 = this)._nodes.forEach(function(e3, n4) {
            if (e3.out)
              for (var r3 in e3.out) {
                var i3 = /* @__PURE__ */ new Set();
                i3.add(e3.out[r3]), e3.out[r3] = i3, t2._nodes.get(r3).in[n4] = i3;
              }
            if (e3.undirected) {
              for (var o2 in e3.undirected)
                if (!(o2 > n4)) {
                  var a3 = /* @__PURE__ */ new Set();
                  a3.add(e3.undirected[o2]), e3.undirected[o2] = a3, t2._nodes.get(o2).undirected[n4] = a3;
                }
            }
          })), this;
          var t2;
        }, i2.toJSON = function() {
          return this.export();
        }, i2.toString = function() {
          return "[object Graph]";
        }, i2.inspect = function() {
          var e3 = this, n4 = {};
          this._nodes.forEach(function(t2, e4) {
            n4[e4] = t2.attributes;
          });
          var r3 = {}, i3 = {};
          this._edges.forEach(function(t2, n5) {
            var o3, a4 = t2.undirected ? "--" : "->", u2 = "", c4 = t2.source.key, d2 = t2.target.key;
            t2.undirected && c4 > d2 && (o3 = c4, c4 = d2, d2 = o3);
            var s3 = "(".concat(c4, ")").concat(a4, "(").concat(d2, ")");
            n5.startsWith("geid_") ? e3.multi && (void 0 === i3[s3] ? i3[s3] = 0 : i3[s3]++, u2 += "".concat(i3[s3], ". ")) : u2 += "[".concat(n5, "]: "), r3[u2 += s3] = t2.attributes;
          });
          var o2 = {};
          for (var a3 in this)
            this.hasOwnProperty(a3) && !Zt.has(a3) && "function" != typeof this[a3] && "symbol" !== t(a3) && (o2[a3] = this[a3]);
          return o2.attributes = this._attributes, o2.nodes = n4, o2.edges = r3, p(o2, "constructor", this.constructor), o2;
        }, r2;
      }(v.exports.EventEmitter);
      "undefined" != typeof Symbol && (re2.prototype[Symbol.for("nodejs.util.inspect.custom")] = re2.prototype.inspect), [{ name: function(t2) {
        return "".concat(t2, "Edge");
      }, generateKey: true }, { name: function(t2) {
        return "".concat(t2, "DirectedEdge");
      }, generateKey: true, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdge");
      }, generateKey: true, type: "undirected" }, { name: function(t2) {
        return "".concat(t2, "EdgeWithKey");
      } }, { name: function(t2) {
        return "".concat(t2, "DirectedEdgeWithKey");
      }, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdgeWithKey");
      }, type: "undirected" }].forEach(function(t2) {
        ["add", "merge", "update"].forEach(function(e3) {
          var n3 = t2.name(e3), r2 = "add" === e3 ? ee : ne;
          t2.generateKey ? re2.prototype[n3] = function(i2, o2, a3) {
            return r2(this, n3, true, "undirected" === (t2.type || this.type), null, i2, o2, a3, "update" === e3);
          } : re2.prototype[n3] = function(i2, o2, a3, u2) {
            return r2(this, n3, false, "undirected" === (t2.type || this.type), i2, o2, a3, u2, "update" === e3);
          };
        });
      }), function(t2) {
        $.forEach(function(e3) {
          var n3 = e3.name, r2 = e3.attacher;
          r2(t2, n3("Node"), 0), r2(t2, n3("Source"), 1), r2(t2, n3("Target"), 2), r2(t2, n3("Opposite"), 3);
        });
      }(re2), function(t2) {
        tt.forEach(function(e3) {
          var n3 = e3.name, r2 = e3.attacher;
          r2(t2, n3("Edge"), "mixed"), r2(t2, n3("DirectedEdge"), "directed"), r2(t2, n3("UndirectedEdge"), "undirected");
        });
      }(re2), function(t2) {
        it.forEach(function(e3) {
          !function(t3, e4) {
            var n3 = e4.name, r2 = e4.type, i2 = e4.direction;
            t3.prototype[n3] = function(t4, e6) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return [];
              if (!arguments.length)
                return wt(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var o2 = this._nodes.get(t4);
                if (void 0 === o2)
                  throw new Y2("Graph.".concat(n3, ': could not find the "').concat(t4, '" node in the graph.'));
                return Gt(this.multi, "mixed" === r2 ? this.type : r2, i2, o2);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e6 = "" + e6;
                var a3 = this._nodes.get(t4);
                if (!a3)
                  throw new Y2("Graph.".concat(n3, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e6))
                  throw new Y2("Graph.".concat(n3, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return At(r2, this.multi, i2, a3, e6);
              }
              throw new F("Graph.".concat(n3, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e3), function(t3, e4) {
            var n3 = e4.name, r2 = e4.type, i2 = e4.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e6, n4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                if (1 === arguments.length)
                  return mt(this, r2, n4 = t4);
                if (2 === arguments.length) {
                  t4 = "" + t4, n4 = e6;
                  var a4 = this._nodes.get(t4);
                  if (void 0 === a4)
                    throw new Y2("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                  return xt(this.multi, "mixed" === r2 ? this.type : r2, i2, a4, n4);
                }
                if (3 === arguments.length) {
                  t4 = "" + t4, e6 = "" + e6;
                  var u3 = this._nodes.get(t4);
                  if (!u3)
                    throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                  if (!this._nodes.has(e6))
                    throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(e6, '" target node in the graph.'));
                  return Lt(r2, this.multi, i2, u3, e6, n4);
                }
                throw new F("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
              }
            };
            var a3 = "map" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[a3] = function() {
              var t4, e6 = Array.prototype.slice.call(arguments), n4 = e6.pop();
              if (0 === e6.length) {
                var i3 = 0;
                "directed" !== r2 && (i3 += this.undirectedSize), "undirected" !== r2 && (i3 += this.directedSize), t4 = new Array(i3);
                var a4 = 0;
                e6.push(function(e7, r3, i4, o3, u3, c5, d2) {
                  t4[a4++] = n4(e7, r3, i4, o3, u3, c5, d2);
                });
              } else
                t4 = [], e6.push(function(e7, r3, i4, o3, a5, u3, c5) {
                  t4.push(n4(e7, r3, i4, o3, a5, u3, c5));
                });
              return this[o2].apply(this, e6), t4;
            };
            var u2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[u2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e6 = t4.pop(), n4 = [];
              return t4.push(function(t5, r3, i3, o3, a4, u3, c5) {
                e6(t5, r3, i3, o3, a4, u3, c5) && n4.push(t5);
              }), this[o2].apply(this, t4), n4;
            };
            var c4 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[c4] = function() {
              var t4, e6, n4 = Array.prototype.slice.call(arguments);
              if (n4.length < 2 || n4.length > 4)
                throw new F("Graph.".concat(c4, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n4.length, ")."));
              if ("function" == typeof n4[n4.length - 1] && "function" != typeof n4[n4.length - 2])
                throw new F("Graph.".concat(c4, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              2 === n4.length ? (t4 = n4[0], e6 = n4[1], n4 = []) : 3 === n4.length ? (t4 = n4[1], e6 = n4[2], n4 = [n4[0]]) : 4 === n4.length && (t4 = n4[2], e6 = n4[3], n4 = [n4[0], n4[1]]);
              var r3 = e6;
              return n4.push(function(e7, n5, i3, o3, a4, u3, c5) {
                r3 = t4(r3, e7, n5, i3, o3, a4, u3, c5);
              }), this[o2].apply(this, n4), r3;
            };
          }(t2, e3), function(t3, e4) {
            var n3 = e4.name, r2 = e4.type, i2 = e4.direction, o2 = "find" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e6, n4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return false;
              if (1 === arguments.length)
                return _t(this, r2, n4 = t4);
              if (2 === arguments.length) {
                t4 = "" + t4, n4 = e6;
                var a4 = this._nodes.get(t4);
                if (void 0 === a4)
                  throw new Y2("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return Et(this.multi, "mixed" === r2 ? this.type : r2, i2, a4, n4);
              }
              if (3 === arguments.length) {
                t4 = "" + t4, e6 = "" + e6;
                var u3 = this._nodes.get(t4);
                if (!u3)
                  throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e6))
                  throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return Dt(r2, this.multi, i2, u3, e6, n4);
              }
              throw new F("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
            };
            var a3 = "some" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[a3] = function() {
              var t4 = Array.prototype.slice.call(arguments), e6 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a4, u3) {
                return e6(t5, n4, r3, i3, o3, a4, u3);
              }), !!this[o2].apply(this, t4);
            };
            var u2 = "every" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[u2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e6 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a4, u3) {
                return !e6(t5, n4, r3, i3, o3, a4, u3);
              }), !this[o2].apply(this, t4);
            };
          }(t2, e3), function(t3, e4) {
            var n3 = e4.name, r2 = e4.type, i2 = e4.direction, o2 = n3.slice(0, -1) + "Entries";
            t3.prototype[o2] = function(t4, e6) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return O.empty();
              if (!arguments.length)
                return kt(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (!n4)
                  throw new Y2("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return St(r2, i2, n4);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e6 = "" + e6;
                var a3 = this._nodes.get(t4);
                if (!a3)
                  throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e6))
                  throw new Y2("Graph.".concat(o2, ':  could not find the "').concat(e6, '" target node in the graph.'));
                return Nt(r2, i2, a3, e6);
              }
              throw new F("Graph.".concat(o2, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e3);
        });
      }(re2), function(t2) {
        Ut.forEach(function(e3) {
          Rt(t2, e3), Wt(t2, e3), Kt(t2, e3), It(t2, e3);
        });
      }(re2);
      var ie = function(t2) {
        function n3(e3) {
          var n4 = c3({ type: "directed" }, e3);
          if ("multi" in n4 && false !== n4.multi)
            throw new F("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("directed" !== n4.type)
            throw new F('DirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(re2), oe = function(t2) {
        function n3(e3) {
          var n4 = c3({ type: "undirected" }, e3);
          if ("multi" in n4 && false !== n4.multi)
            throw new F("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("undirected" !== n4.type)
            throw new F('UndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(re2), ae = function(t2) {
        function n3(e3) {
          var n4 = c3({ multi: true }, e3);
          if ("multi" in n4 && true !== n4.multi)
            throw new F("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(re2), ue = function(t2) {
        function n3(e3) {
          var n4 = c3({ type: "directed", multi: true }, e3);
          if ("multi" in n4 && true !== n4.multi)
            throw new F("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("directed" !== n4.type)
            throw new F('MultiDirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(re2), ce = function(t2) {
        function n3(e3) {
          var n4 = c3({ type: "undirected", multi: true }, e3);
          if ("multi" in n4 && true !== n4.multi)
            throw new F("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("undirected" !== n4.type)
            throw new F('MultiUndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(re2);
      function de(t2) {
        t2.from = function(e3, n3) {
          var r2 = c3({}, e3.options, n3), i2 = new t2(r2);
          return i2.import(e3), i2;
        };
      }
      return de(re2), de(ie), de(oe), de(ae), de(ue), de(ce), re2.Graph = re2, re2.DirectedGraph = ie, re2.UndirectedGraph = oe, re2.MultiGraph = ae, re2.MultiDirectedGraph = ue, re2.MultiUndirectedGraph = ce, re2.InvalidArgumentsGraphError = F, re2.NotFoundGraphError = Y2, re2.UsageGraphError = B2, re2;
    });
  }
});

// node_modules/graphology-utils/is-graph.js
var require_is_graph = __commonJS({
  "node_modules/graphology-utils/is-graph.js"(exports, module2) {
    module2.exports = function isGraph(value) {
      return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function" && typeof value.multi === "boolean";
    };
  }
});

// node_modules/obliterator/support.js
var require_support = __commonJS({
  "node_modules/obliterator/support.js"(exports) {
    exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
    exports.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
  }
});

// node_modules/obliterator/foreach.js
var require_foreach = __commonJS({
  "node_modules/obliterator/foreach.js"(exports, module2) {
    var support = require_support();
    var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
    var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
    module2.exports = function forEach(iterable, callback) {
      var iterator, k, i, l2, s2;
      if (!iterable)
        throw new Error("obliterator/forEach: invalid iterable.");
      if (typeof callback !== "function")
        throw new Error("obliterator/forEach: expecting a callback.");
      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
        for (i = 0, l2 = iterable.length; i < l2; i++)
          callback(iterable[i], i);
        return;
      }
      if (typeof iterable.forEach === "function") {
        iterable.forEach(callback);
        return;
      }
      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
        iterable = iterable[Symbol.iterator]();
      }
      if (typeof iterable.next === "function") {
        iterator = iterable;
        i = 0;
        while (s2 = iterator.next(), s2.done !== true) {
          callback(s2.value, i);
          i++;
        }
        return;
      }
      for (k in iterable) {
        if (iterable.hasOwnProperty(k)) {
          callback(iterable[k], k);
        }
      }
      return;
    };
  }
});

// node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS({
  "node_modules/mnemonist/utils/typed-arrays.js"(exports) {
    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
    exports.getPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_8BIT_INTEGER)
        return Uint8Array;
      if (maxIndex <= MAX_16BIT_INTEGER)
        return Uint16Array;
      if (maxIndex <= MAX_32BIT_INTEGER)
        return Uint32Array;
      throw new Error("mnemonist: Pointer Array of size > 4294967295 is not supported.");
    };
    exports.getSignedPointerArray = function(size) {
      var maxIndex = size - 1;
      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
        return Int8Array;
      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
        return Int16Array;
      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
        return Int32Array;
      return Float64Array;
    };
    exports.getNumberType = function(value) {
      if (value === (value | 0)) {
        if (Math.sign(value) === -1) {
          if (value <= 127 && value >= -128)
            return Int8Array;
          if (value <= 32767 && value >= -32768)
            return Int16Array;
          return Int32Array;
        } else {
          if (value <= 255)
            return Uint8Array;
          if (value <= 65535)
            return Uint16Array;
          return Uint32Array;
        }
      }
      return Float64Array;
    };
    var TYPE_PRIORITY = {
      Uint8Array: 1,
      Int8Array: 2,
      Uint16Array: 3,
      Int16Array: 4,
      Uint32Array: 5,
      Int32Array: 6,
      Float32Array: 7,
      Float64Array: 8
    };
    exports.getMinimalRepresentation = function(array, getter) {
      var maxType = null, maxPriority = 0, p, t, v, i, l2;
      for (i = 0, l2 = array.length; i < l2; i++) {
        v = getter ? getter(array[i]) : array[i];
        t = exports.getNumberType(v);
        p = TYPE_PRIORITY[t.name];
        if (p > maxPriority) {
          maxPriority = p;
          maxType = t;
        }
      }
      return maxType;
    };
    exports.isTypedArray = function(value) {
      return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
    };
    exports.concat = function() {
      var length = 0, i, o, l2;
      for (i = 0, l2 = arguments.length; i < l2; i++)
        length += arguments[i].length;
      var array = new arguments[0].constructor(length);
      for (i = 0, o = 0; i < l2; i++) {
        array.set(arguments[i], o);
        o += arguments[i].length;
      }
      return array;
    };
    exports.indices = function(length) {
      var PointerArray = exports.getPointerArray(length);
      var array = new PointerArray(length);
      for (var i = 0; i < length; i++)
        array[i] = i;
      return array;
    };
  }
});

// node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS({
  "node_modules/mnemonist/utils/iterables.js"(exports) {
    var forEach = require_foreach();
    var typed = require_typed_arrays();
    function isArrayLike(target) {
      return Array.isArray(target) || typed.isTypedArray(target);
    }
    function guessLength(target) {
      if (typeof target.length === "number")
        return target.length;
      if (typeof target.size === "number")
        return target.size;
      return;
    }
    function toArray(target) {
      var l2 = guessLength(target);
      var array = typeof l2 === "number" ? new Array(l2) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i++] = value;
      });
      return array;
    }
    function toArrayWithIndices(target) {
      var l2 = guessLength(target);
      var IndexArray = typeof l2 === "number" ? typed.getPointerArray(l2) : Array;
      var array = typeof l2 === "number" ? new Array(l2) : [];
      var indices = typeof l2 === "number" ? new IndexArray(l2) : [];
      var i = 0;
      forEach(target, function(value) {
        array[i] = value;
        indices[i] = i++;
      });
      return [array, indices];
    }
    exports.isArrayLike = isArrayLike;
    exports.guessLength = guessLength;
    exports.toArray = toArray;
    exports.toArrayWithIndices = toArrayWithIndices;
  }
});

// node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "node_modules/obliterator/iterator.js"(exports, module2) {
    function Iterator(next) {
      if (typeof next !== "function")
        throw new Error("obliterator/iterator: expecting a function!");
      this.next = next;
    }
    if (typeof Symbol !== "undefined")
      Iterator.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator.of = function() {
      var args = arguments, l2 = args.length, i = 0;
      return new Iterator(function() {
        if (i >= l2)
          return { done: true };
        return { done: false, value: args[i++] };
      });
    };
    Iterator.empty = function() {
      var iterator = new Iterator(function() {
        return { done: true };
      });
      return iterator;
    };
    Iterator.fromSequence = function(sequence) {
      var i = 0, l2 = sequence.length;
      return new Iterator(function() {
        if (i >= l2)
          return { done: true };
        return { done: false, value: sequence[i++] };
      });
    };
    Iterator.is = function(value) {
      if (value instanceof Iterator)
        return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module2.exports = Iterator;
  }
});

// node_modules/mnemonist/fixed-deque.js
var require_fixed_deque = __commonJS({
  "node_modules/mnemonist/fixed-deque.js"(exports, module2) {
    var iterables = require_iterables();
    var Iterator = require_iterator();
    function FixedDeque(ArrayClass, capacity) {
      if (arguments.length < 2)
        throw new Error("mnemonist/fixed-deque: expecting an Array class and a capacity.");
      if (typeof capacity !== "number" || capacity <= 0)
        throw new Error("mnemonist/fixed-deque: `capacity` should be a positive number.");
      this.ArrayClass = ArrayClass;
      this.capacity = capacity;
      this.items = new ArrayClass(this.capacity);
      this.clear();
    }
    FixedDeque.prototype.clear = function() {
      this.start = 0;
      this.size = 0;
    };
    FixedDeque.prototype.push = function(item) {
      if (this.size === this.capacity)
        throw new Error("mnemonist/fixed-deque.push: deque capacity (" + this.capacity + ") exceeded!");
      var index2 = (this.start + this.size) % this.capacity;
      this.items[index2] = item;
      return ++this.size;
    };
    FixedDeque.prototype.unshift = function(item) {
      if (this.size === this.capacity)
        throw new Error("mnemonist/fixed-deque.unshift: deque capacity (" + this.capacity + ") exceeded!");
      var index2 = this.start - 1;
      if (this.start === 0)
        index2 = this.capacity - 1;
      this.items[index2] = item;
      this.start = index2;
      return ++this.size;
    };
    FixedDeque.prototype.pop = function() {
      if (this.size === 0)
        return;
      const index2 = (this.start + this.size - 1) % this.capacity;
      this.size--;
      return this.items[index2];
    };
    FixedDeque.prototype.shift = function() {
      if (this.size === 0)
        return;
      var index2 = this.start;
      this.size--;
      this.start++;
      if (this.start === this.capacity)
        this.start = 0;
      return this.items[index2];
    };
    FixedDeque.prototype.peekFirst = function() {
      if (this.size === 0)
        return;
      return this.items[this.start];
    };
    FixedDeque.prototype.peekLast = function() {
      if (this.size === 0)
        return;
      var index2 = this.start + this.size - 1;
      if (index2 > this.capacity)
        index2 -= this.capacity;
      return this.items[index2];
    };
    FixedDeque.prototype.get = function(index2) {
      if (this.size === 0)
        return;
      index2 = this.start + index2;
      if (index2 > this.capacity)
        index2 -= this.capacity;
      return this.items[index2];
    };
    FixedDeque.prototype.forEach = function(callback, scope) {
      scope = arguments.length > 1 ? scope : this;
      var c3 = this.capacity, l2 = this.size, i = this.start, j = 0;
      while (j < l2) {
        callback.call(scope, this.items[i], j, this);
        i++;
        j++;
        if (i === c3)
          i = 0;
      }
    };
    FixedDeque.prototype.toArray = function() {
      var offset2 = this.start + this.size;
      if (offset2 < this.capacity)
        return this.items.slice(this.start, offset2);
      var array = new this.ArrayClass(this.size), c3 = this.capacity, l2 = this.size, i = this.start, j = 0;
      while (j < l2) {
        array[j] = this.items[i];
        i++;
        j++;
        if (i === c3)
          i = 0;
      }
      return array;
    };
    FixedDeque.prototype.values = function() {
      var items = this.items, c3 = this.capacity, l2 = this.size, i = this.start, j = 0;
      return new Iterator(function() {
        if (j >= l2)
          return {
            done: true
          };
        var value = items[i];
        i++;
        j++;
        if (i === c3)
          i = 0;
        return {
          value,
          done: false
        };
      });
    };
    FixedDeque.prototype.entries = function() {
      var items = this.items, c3 = this.capacity, l2 = this.size, i = this.start, j = 0;
      return new Iterator(function() {
        if (j >= l2)
          return {
            done: true
          };
        var value = items[i];
        i++;
        if (i === c3)
          i = 0;
        return {
          value: [j++, value],
          done: false
        };
      });
    };
    if (typeof Symbol !== "undefined")
      FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;
    FixedDeque.prototype.inspect = function() {
      var array = this.toArray();
      array.type = this.ArrayClass.name;
      array.capacity = this.capacity;
      Object.defineProperty(array, "constructor", {
        value: FixedDeque,
        enumerable: false
      });
      return array;
    };
    if (typeof Symbol !== "undefined")
      FixedDeque.prototype[Symbol.for("nodejs.util.inspect.custom")] = FixedDeque.prototype.inspect;
    FixedDeque.from = function(iterable, ArrayClass, capacity) {
      if (arguments.length < 3) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== "number")
          throw new Error("mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.");
      }
      var deque = new FixedDeque(ArrayClass, capacity);
      if (iterables.isArrayLike(iterable)) {
        var i, l2;
        for (i = 0, l2 = iterable.length; i < l2; i++)
          deque.items[i] = iterable[i];
        deque.size = l2;
        return deque;
      }
      iterables.forEach(iterable, function(value) {
        deque.push(value);
      });
      return deque;
    };
    module2.exports = FixedDeque;
  }
});

// node_modules/graphology-traversal/utils.js
var require_utils = __commonJS({
  "node_modules/graphology-traversal/utils.js"(exports) {
    function TraversalRecord(node, attr2, depth) {
      this.node = node;
      this.attributes = attr2;
      this.depth = depth;
    }
    exports.TraversalRecord = TraversalRecord;
  }
});

// node_modules/graphology-traversal/bfs.js
var require_bfs = __commonJS({
  "node_modules/graphology-traversal/bfs.js"(exports) {
    var isGraph = require_is_graph();
    var FixedDeque = require_fixed_deque();
    var TraversalRecord = require_utils().TraversalRecord;
    function bfs(graph, callback) {
      if (!isGraph(graph))
        throw new Error("graphology-traversal/bfs: expecting a graphology instance.");
      if (typeof callback !== "function")
        throw new Error("graphology-traversal/bfs: given callback is not a function.");
      if (graph.order === 0)
        return;
      var seen = /* @__PURE__ */ new Set();
      var queue = new FixedDeque(Array, graph.order);
      var record, depth;
      function neighborCallback(neighbor, attr2) {
        if (seen.has(neighbor))
          return;
        seen.add(neighbor);
        queue.push(new TraversalRecord(neighbor, attr2, depth + 1));
      }
      graph.forEachNode(function(node, attr2) {
        if (seen.has(node))
          return;
        seen.add(node);
        queue.push(new TraversalRecord(node, attr2, 0));
        while (queue.size !== 0) {
          record = queue.shift();
          depth = record.depth;
          callback(record.node, record.attributes, depth);
          graph.forEachOutboundNeighbor(record.node, neighborCallback);
        }
      });
    }
    function bfsFromNode(graph, node, callback) {
      if (!isGraph(graph))
        throw new Error("graphology-traversal/dfs: expecting a graphology instance.");
      if (typeof callback !== "function")
        throw new Error("graphology-traversal/dfs: given callback is not a function.");
      if (graph.order === 0)
        return;
      node = "" + node;
      var seen = /* @__PURE__ */ new Set();
      var queue = new FixedDeque(Array, graph.order);
      var depth, record;
      function neighborCallback(neighbor, attr2) {
        if (seen.has(neighbor))
          return;
        seen.add(neighbor);
        queue.push(new TraversalRecord(neighbor, attr2, depth + 1));
      }
      seen.add(node);
      queue.push(new TraversalRecord(node, graph.getNodeAttributes(node), 0));
      while (queue.size !== 0) {
        record = queue.shift();
        depth = record.depth;
        callback(record.node, record.attributes, depth);
        graph.forEachOutboundNeighbor(record.node, neighborCallback);
      }
    }
    exports.bfs = bfs;
    exports.bfsFromNode = bfsFromNode;
  }
});

// node_modules/graphology-traversal/dfs.js
var require_dfs = __commonJS({
  "node_modules/graphology-traversal/dfs.js"(exports) {
    var isGraph = require_is_graph();
    var TraversalRecord = require_utils().TraversalRecord;
    function dfs(graph, callback) {
      if (!isGraph(graph))
        throw new Error("graphology-traversal/dfs: expecting a graphology instance.");
      if (typeof callback !== "function")
        throw new Error("graphology-traversal/dfs: given callback is not a function.");
      if (graph.order === 0)
        return;
      var seen = /* @__PURE__ */ new Set();
      var stack = [];
      var depth, record;
      function neighborCallback(neighbor, attr2) {
        if (seen.has(neighbor))
          return;
        seen.add(neighbor);
        stack.push(new TraversalRecord(neighbor, attr2, depth + 1));
      }
      graph.forEachNode(function(node, attr2) {
        if (seen.has(node))
          return;
        seen.add(node);
        stack.push(new TraversalRecord(node, attr2, 0));
        while (stack.length !== 0) {
          record = stack.pop();
          depth = record.depth;
          callback(record.node, record.attributes, depth);
          graph.forEachOutboundNeighbor(record.node, neighborCallback);
        }
      });
    }
    function dfsFromNode2(graph, node, callback) {
      if (!isGraph(graph))
        throw new Error("graphology-traversal/dfs: expecting a graphology instance.");
      if (typeof callback !== "function")
        throw new Error("graphology-traversal/dfs: given callback is not a function.");
      if (graph.order === 0)
        return;
      node = "" + node;
      var seen = /* @__PURE__ */ new Set();
      var stack = [];
      var depth, record;
      function neighborCallback(neighbor, attr2) {
        if (seen.has(neighbor))
          return;
        seen.add(neighbor);
        stack.push(new TraversalRecord(neighbor, attr2, depth + 1));
      }
      seen.add(node);
      stack.push(new TraversalRecord(node, graph.getNodeAttributes(node), 0));
      while (stack.length !== 0) {
        record = stack.pop();
        depth = record.depth;
        callback(record.node, record.attributes, depth);
        graph.forEachOutboundNeighbor(record.node, neighborCallback);
      }
    }
    exports.dfs = dfs;
    exports.dfsFromNode = dfsFromNode2;
  }
});

// node_modules/graphology-traversal/index.js
var require_graphology_traversal = __commonJS({
  "node_modules/graphology-traversal/index.js"(exports) {
    var bfsModule = require_bfs();
    var dfsModule = require_dfs();
    var k;
    for (k in bfsModule)
      exports[k] = bfsModule[k];
    for (k in dfsModule)
      exports[k] = dfsModule[k];
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset2 = array.length;
        while (++index2 < length) {
          array[offset2 + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set3) {
        var index2 = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set3) {
        var index2 = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined2 : get3(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number3, lower2, upper) {
          if (number3 === number3) {
            if (upper !== undefined2) {
              number3 = number3 <= upper ? number3 : upper;
            }
            if (lower2 !== undefined2) {
              number3 = number3 >= lower2 ? number3 : lower2;
            }
          }
          return number3;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait2, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait2);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end) {
          var length = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start2 > end ? 0 : toLength(end);
          while (start2 < end) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path2) {
          path2 = castPath(path2, object);
          var index2 = 0, length = path2.length;
          while (object != null && index2 < length) {
            object = object[toKey(path2[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number3, start2, end) {
          return number3 >= nativeMin(start2, end) && number3 < nativeMax(start2, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path2, args) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          var func = object == null ? object : object[toKey(last(path2))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity4;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object) {
            var objValue = get3(object, path2);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity4];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path2) {
            return hasIn(object, path2);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path2 = paths[index2], value = baseGet(object, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object) {
            return baseGet(object, path2);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower2, upper) {
          return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
        }
        function baseRange(start2, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity4), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path2, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path2 = castPath(path2, object);
          var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path2[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity4 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity4 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end) {
          var index2 = -1, length = array.length;
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start2 > end ? 0 : end - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity4, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set4 = iteratee2 ? null : createSet(array);
            if (set4) {
              return setToArray(set4);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path2) {
          path2 = castPath(path2, object);
          object = parent(object, path2);
          return object == null || delete object[toKey(last(path2))];
        }
        function baseUpdate(object, path2, updater, customizer) {
          return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity4;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start2 && end >= length ? array : baseSlice(array, start2, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root2.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
              end = step = undefined2;
            }
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
            return baseRange(start2, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number3, precision) {
            number3 = toNumber(number3);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number3)) {
              var pair = (toString(number3) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number3);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end - size2);
                break;
            }
          }
          return { "start": start2, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path2, hasFunc) {
          path2 = castPath(path2, object);
          var index2 = -1, length = path2.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path2[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details2) {
          var length = details2.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details2[lastIndex] = (length > 1 ? "& " : "") + details2[lastIndex];
          details2 = details2.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details2 + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject(object)) {
            return false;
          }
          var type2 = typeof index2;
          if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform3) {
          start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start2 + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index2 < start2) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start2] = transform3(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path2) {
          return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait2) {
          return root2.setTimeout(func, wait2);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match2, number3, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details2, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details2, value)) {
              details2.push(value);
            }
          });
          return details2.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end = length;
          }
          return baseFill(array, value, start2, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
            start2 = 0;
            end = length;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start2, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone4 = wrapperClone(parent2);
            clone4.__index__ = 0;
            clone4.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone4;
            } else {
              result2 = clone4;
            }
            var previous = clone4;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find3 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now3 = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey2 = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait2, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait2 = toNumber(wait2) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait2);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now3();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush2() {
            return timerId === undefined2 ? result2 : trailingEdge(now3());
          }
          function debounced() {
            var time = now3(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait2);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait2);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush2;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait2, args) {
          return baseDelay(func, toNumber(wait2) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait2, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait2, {
            "leading": leading,
            "maxWait": wait2,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone3(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get3(object, path2, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path2);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path2) {
          return object != null && hasPath(object, path2, baseHas);
        }
        function hasIn(object, path2) {
          return object != null && hasPath(object, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity4));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object, path2, defaultValue) {
          path2 = castPath(path2, object);
          var index2 = -1, length = path2.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path2[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set3(object, path2, value) {
          return object == null ? object : baseSet(object, path2, value);
        }
        function setWith(object, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path2, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path2) {
          return object == null ? true : baseUnset(object, path2);
        }
        function update2(object, path2, updater) {
          return object == null ? object : baseUpdate(object, path2, castFunction(updater));
        }
        function updateWith(object, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number3, lower2, upper) {
          if (upper === undefined2) {
            upper = lower2;
            lower2 = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower2 !== undefined2) {
            lower2 = toNumber(lower2);
            lower2 = lower2 === lower2 ? lower2 : 0;
          }
          return baseClamp(toNumber(number3), lower2, upper);
        }
        function inRange(number3, start2, end) {
          start2 = toFinite(start2);
          if (end === undefined2) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          number3 = toNumber(number3);
          return baseInRange(number3, start2, end);
        }
        function random(lower2, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower2 == "boolean") {
              floating = lower2;
              lower2 = undefined2;
            }
          }
          if (lower2 === undefined2 && upper === undefined2) {
            lower2 = 0;
            upper = 1;
          } else {
            lower2 = toFinite(lower2);
            if (upper === undefined2) {
              upper = lower2;
              lower2 = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower2 > upper) {
            var temp = lower2;
            lower2 = upper;
            upper = temp;
          }
          if (floating || lower2 % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower2, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart2(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset2 + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity4(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object) {
            return baseInvoke(object, path2, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path2) {
            return baseInvoke(object, path2, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object) {
          return function(path2) {
            return object == null ? undefined2 : baseGet(object, path2);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString(prefix) + id2;
        }
        var add2 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max4(array) {
          return array && array.length ? baseExtremum(array, identity4, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity4);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min3(array) {
          return array && array.length ? baseExtremum(array, identity4, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity4) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey2;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set3;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice2;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform2;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add2;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone3;
        lodash.cloneDeep = cloneDeep2;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find3;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get3;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity4;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate2;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max4;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min3;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now3;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart2;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity4);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root2._ = _;
      }
    }).call(exports);
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BCPlugin
});
module.exports = __toCommonJS(main_exports);

// node_modules/juggl-api/dist/index.mjs
var import_obsidian = require("obsidian");
var CAT_DANGLING = "dangling";
var CORE_STORE_ID = "core";
var VizId = class {
  constructor(id2, storeId) {
    this.id = id2;
    this.storeId = storeId;
  }
  toString() {
    return `${this.storeId}:${this.id}`;
  }
  toId() {
    return this.toString();
  }
  static fromId(id2) {
    const split = id2.split(":");
    const storeId = split[0];
    const _id = split.slice(1).join(":");
    return new VizId(_id, storeId);
  }
  static fromNode(node) {
    return VizId.fromId(node.id());
  }
  static fromNodes(nodes) {
    return nodes.map((n2) => VizId.fromNode(n2));
  }
  static fromFile(file) {
    return new VizId(file.name, "core");
  }
  static toId(id2, storeId) {
    return new VizId(id2, storeId).toId();
  }
};
var _parseTags = function(tags) {
  return [].concat(...tags.map((tag) => {
    tag = tag.slice(1);
    const hSplit = tag.split("/");
    const tags2 = [];
    for (const i in hSplit) {
      const hTag = hSplit.slice(0, parseInt(i) + 1).join("-");
      tags2.push(`tag-${hTag}`);
    }
    return tags2;
  }));
};
var getClasses = function(file, metadataCache) {
  if (file) {
    const classes = [];
    if (["png", "jpg", "jpeg", "gif", "bmp", "svg", "tiff"].contains(file.extension)) {
      classes.push("image");
    } else if (["mp3", "webm", "wav", "m4a", "ogg", "3gp", "flac"].contains(file.extension)) {
      classes.push("audio");
    } else if (["mp4", "webm", "ogv"].contains(file.extension)) {
      classes.push("video");
    } else if (file.extension === "pdf") {
      classes.push("pdf");
    }
    if (file.extension === "md") {
      classes.push("note");
      const cache = metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        if ("image" in cache.frontmatter) {
          classes.push("image");
        }
        if ("tags" in cache.frontmatter) {
          const tags = (0, import_obsidian.parseFrontMatterTags)(cache.frontmatter);
          if (tags) {
            classes.push(..._parseTags(tags));
          }
        }
        if ("cssclass" in cache.frontmatter) {
          const clazzes = (0, import_obsidian.parseFrontMatterStringArray)(cache.frontmatter, "cssclass");
          if (clazzes) {
            classes.push(...clazzes);
          }
        }
      }
      if (cache == null ? void 0 : cache.tags) {
        classes.push(..._parseTags(cache.tags.map((t) => t.tag)));
      }
    } else {
      classes.push("file");
    }
    return classes;
  }
  return [CAT_DANGLING];
};
var nodeFromFile = async function(file, plugin, settings, id2) {
  if (!id2) {
    id2 = VizId.toId(file.name, CORE_STORE_ID);
  }
  const cache = plugin.app.metadataCache.getFileCache(file);
  const name = file.extension === "md" ? file.basename : file.name;
  const classes = getClasses(file, plugin.app.metadataCache).join(" ");
  const data = {
    id: id2,
    name,
    path: file.path
  };
  if (["png", "jpg", "jpeg", "gif", "bmp", "svg", "tiff"].contains(file.extension)) {
    try {
      data["resource_url"] = `http://localhost:${plugin.settings.imgServerPort}/${encodeURI(file.path)}`;
    } catch (e) {
    }
  }
  if (settings.readContent && file.extension == "md") {
    data["content"] = await plugin.app.vault.cachedRead(file);
  }
  const frontmatter = cache == null ? void 0 : cache.frontmatter;
  if (frontmatter) {
    Object.keys(frontmatter).forEach((k) => {
      if (!(k === "position")) {
        if (k === "image") {
          const imageField = frontmatter[k];
          try {
            new URL(imageField);
            data[k] = imageField;
          } catch (e) {
            try {
              data[k] = `http://localhost:${plugin.settings.imgServerPort}/${encodeURI(imageField)}`;
            } catch (e3) {
            }
          }
        } else {
          data[k] = frontmatter[k];
        }
      }
    });
  }
  return {
    group: "nodes",
    data,
    classes
  };
};
var nodeDangling = function(path2) {
  return {
    group: "nodes",
    data: {
      id: VizId.toId(path2, CORE_STORE_ID),
      name: path2
    },
    classes: "dangling"
  };
};
var wikilinkRegex = "\\[\\[([^\\]\\r\\n]+?)\\]\\]";
var nameRegex = "[^\\W\\d]\\w*";
var regexEscape = function(str) {
  return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var parseTypedLink = function(link2, line, typedLinkPrefix) {
  const regexPublishedIn = new RegExp(`^${regexEscape(typedLinkPrefix)} (publishedIn) (\\d\\d\\d\\d) (${wikilinkRegex},? *)+$`);
  const matchPI = regexPublishedIn.exec(line);
  if (!(matchPI === null)) {
    return {
      class: "type-publishedIn",
      isInline: false,
      properties: {
        year: matchPI[2],
        context: "",
        type: "publishedIn"
      }
    };
  }
  const regex = new RegExp(`^${regexEscape(typedLinkPrefix)} (${nameRegex}) (${wikilinkRegex},? *)+$`);
  const match2 = regex.exec(line);
  const splitLink = link2.original.split("|");
  let alias = null;
  if (splitLink.length > 1) {
    alias = splitLink.slice(1).join().slice(0, -2);
  }
  if (!(match2 === null)) {
    return {
      class: `type-${match2[1]}`,
      isInline: false,
      properties: {
        alias,
        context: "",
        type: match2[1]
      }
    };
  }
  return null;
};
var getPlugin = function(app2) {
  if ("juggl" in app2.plugins.plugins) {
    return app2.plugins.plugins["juggl"];
  }
  return null;
};

// src/main.ts
var import_obsidian44 = require("obsidian");

// node_modules/obsidian-community-lib/dist/utils.js
var feather = __toESM(require_feather());
var import_obsidian2 = require("obsidian");
async function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function addFeatherIcon(name, attr2 = { viewBox: "0 0 24 24", width: "100", height: "100" }) {
  if (feather.icons[name]) {
    const iconName = `feather-${name}`;
    (0, import_obsidian2.addIcon)(iconName, feather.icons[name].toSvg(attr2));
    return iconName;
  } else {
    throw Error(`This Icon (${name}) doesn't exist in the Feather Library.`);
  }
}
async function copy(content, success = () => new import_obsidian2.Notice("Copied to clipboard"), failure = (reason) => {
  new import_obsidian2.Notice("Could not copy to clipboard");
  console.log({ reason });
}) {
  await navigator.clipboard.writeText(content).then(success, failure);
}
var isInVault = (noteName, sourcePath = "") => !!app.metadataCache.getFirstLinkpathDest(noteName, sourcePath);
function hoverPreview(event, view, to) {
  const targetEl = event.target;
  app.workspace.trigger("hover-link", {
    event,
    source: view.getViewType(),
    hoverParent: view,
    targetEl,
    linktext: to
  });
}
async function createNewMDNote(newName, currFilePath = "") {
  const newFileFolder = app.fileManager.getNewFileParent(currFilePath).path;
  const newFilePath = (0, import_obsidian2.normalizePath)(`${newFileFolder}${newFileFolder === "/" ? "" : "/"}${addMD(newName)}`);
  return await app.vault.create(newFilePath, "");
}
var addMD = (noteName) => {
  return noteName.match(/\.MD$|\.md$/m) ? noteName : noteName + ".md";
};
async function openOrSwitch(dest, event, options = { createNewFile: true }) {
  const { workspace } = app;
  let destFile = app.metadataCache.getFirstLinkpathDest(dest, "");
  if (!destFile && options.createNewFile) {
    destFile = await createNewMDNote(dest);
  } else if (!destFile && !options.createNewFile)
    return;
  const leavesWithDestAlreadyOpen = [];
  workspace.iterateAllLeaves((leaf) => {
    var _a;
    if (leaf.view instanceof import_obsidian2.MarkdownView) {
      const file = (_a = leaf.view) === null || _a === void 0 ? void 0 : _a.file;
      if (file && file.basename + "." + file.extension === dest) {
        leavesWithDestAlreadyOpen.push(leaf);
      }
    }
  });
  if (leavesWithDestAlreadyOpen.length > 0) {
    workspace.setActiveLeaf(leavesWithDestAlreadyOpen[0]);
  } else {
    const mode = app.vault.getConfig("defaultViewMode");
    const leaf = event.ctrlKey || event.getModifierState("Meta") ? workspace.splitActiveLeaf() : workspace.getUnpinnedLeaf();
    await leaf.openFile(destFile, { active: true, mode });
  }
}
async function openView(viewType, viewClass, side = "right") {
  let leaf = null;
  for (leaf of app.workspace.getLeavesOfType(viewType)) {
    if (leaf.view instanceof viewClass) {
      return leaf.view;
    }
    await leaf.setViewState({ type: "empty" });
    break;
  }
  leaf = (leaf !== null && leaf !== void 0 ? leaf : side === "right") ? app.workspace.getRightLeaf(false) : app.workspace.getLeftLeaf(false);
  await leaf.setViewState({
    type: viewType,
    active: true
  });
  return leaf.view;
}
function resolvedLinksComplete(noFiles) {
  const { resolvedLinks } = app.metadataCache;
  return Object.keys(resolvedLinks).length === noFiles;
}
async function waitForResolvedLinks(delay = 1e3, max4 = 50) {
  const noFiles = app.vault.getMarkdownFiles().length;
  let i = 0;
  while (!resolvedLinksComplete(noFiles) && i < max4) {
    await wait(delay);
    i++;
  }
  if (i === max4) {
    throw Error("Obsidian-Community-Lib: ResolvedLinks did not finish initialising. `max` iterations was reached first.");
  }
}

// src/constants.ts
var MATRIX_VIEW = "BC-matrix";
var DUCK_VIEW = "BC-ducks";
var TREE_VIEW = "BC-tree";
var TRAIL_ICON = "BC-trail-icon";
var TRAIL_ICON_SVG = '<path fill="currentColor" stroke="currentColor" d="M48.8,4c-6,0-13.5,0.5-19.7,3.3S17.9,15.9,17.9,25c0,5,2.6,9.7,6.1,13.9s8.1,8.3,12.6,12.3s9,7.8,12.2,11.5 c3.2,3.7,5.1,7.1,5.1,10.2c0,14.4-13.4,19.3-13.4,19.3c-0.7,0.2-1.2,0.8-1.3,1.5s0.1,1.4,0.7,1.9c0.6,0.5,1.3,0.6,2,0.3 c0,0,16.1-6.1,16.1-23c0-4.6-2.6-8.8-6.1-12.8c-3.5-4-8.1-7.9-12.6-11.8c-4.5-3.9-8.9-7.9-12.2-11.8c-3.2-3.9-5.2-7.7-5.2-11.4 c0-7.8,3.6-11.6,8.8-14S43,8,48.8,8c4.6,0,9.3,0,11,0c0.7,0,1.4-0.4,1.7-1c0.3-0.6,0.3-1.4,0-2s-1-1-1.7-1C58.3,4,53.4,4,48.8,4 L48.8,4z M78.1,4c-0.6,0-1.2,0.2-1.6,0.7l-8.9,9.9c-0.5,0.6-0.7,1.4-0.3,2.2c0.3,0.7,1,1.2,1.8,1.2h0.1l-2.8,2.6 c-0.6,0.6-0.8,1.4-0.5,2.2c0.3,0.8,1,1.3,1.9,1.3h1.3l-4.5,4.6c-0.6,0.6-0.7,1.4-0.4,2.2c0.3,0.7,1,1.2,1.8,1.2h10v4 c0,0.7,0.4,1.4,1,1.8c0.6,0.4,1.4,0.4,2,0c0.6-0.4,1-1,1-1.8v-4h10c0.8,0,1.5-0.5,1.8-1.2c0.3-0.7,0.1-1.6-0.4-2.2L86.9,24h1.3 c0.8,0,1.6-0.5,1.9-1.3c0.3-0.8,0.1-1.6-0.5-2.2l-2.8-2.6h0.1c0.8,0,1.5-0.5,1.8-1.2c0.3-0.7,0.2-1.6-0.3-2.2l-8.9-9.9 C79.1,4.3,78.6,4,78.1,4L78.1,4z M78,9l4.4,4.9h-0.7c-0.8,0-1.6,0.5-1.9,1.3c-0.3,0.8-0.1,1.6,0.5,2.2l2.8,2.6h-1.1 c-0.8,0-1.5,0.5-1.8,1.2c-0.3,0.7-0.1,1.6,0.4,2.2l4.5,4.6H70.8l4.5-4.6c0.6-0.6,0.7-1.4,0.4-2.2c-0.3-0.7-1-1.2-1.8-1.2h-1.1 l2.8-2.6c0.6-0.6,0.8-1.4,0.5-2.2c-0.3-0.8-1-1.3-1.9-1.3h-0.7L78,9z M52.4,12c-4.1,0-7.1,0.5-9.4,1.5c-2.3,1-3.8,2.5-4.5,4.3 c-0.7,1.8-0.5,3.6,0.1,5.2c0.6,1.5,1.5,2.9,2.5,3.9c5.4,5.4,18.1,12.6,29.6,21c5.8,4.2,11.2,8.6,15.1,13c3.9,4.4,6.2,8.7,6.2,12.4 c0,14.5-12.9,18.7-12.9,18.7c-0.7,0.2-1.2,0.8-1.4,1.5s0.1,1.5,0.7,1.9c0.6,0.5,1.3,0.6,2,0.3c0,0,15.6-5.6,15.6-22.5 c0-5.3-2.9-10.3-7.2-15.1C84.6,53.6,79,49,73.1,44.7c-11.8-8.6-24.8-16.3-29.2-20.6c-0.6-0.6-1.2-1.5-1.6-2.4 c-0.3-0.9-0.4-1.7-0.1-2.4c0.3-0.7,0.8-1.4,2.3-2c1.5-0.7,4.1-1.2,7.8-1.2c4.9,0,9.4,0.1,9.4,0.1c0.7,0,1.4-0.3,1.8-1 c0.4-0.6,0.4-1.4,0-2.1c-0.4-0.6-1.1-1-1.8-1C61.9,12.1,57.3,12,52.4,12L52.4,12z M24,46c-0.5,0-1.1,0.2-1.4,0.6L9.2,60.5 c-0.6,0.6-0.7,1.4-0.4,2.2c0.3,0.7,1,1.2,1.8,1.2h3l-6.5,6.8c-0.6,0.6-0.7,1.4-0.4,2.2s1,1.2,1.8,1.2H13l-8.5,8.6 C4,83.2,3.8,84,4.2,84.8C4.5,85.5,5.2,86,6,86h16v5.4c0,0.7,0.4,1.4,1,1.8c0.6,0.4,1.4,0.4,2,0c0.6-0.4,1-1,1-1.8V86h16 c0.8,0,1.5-0.5,1.8-1.2c0.3-0.7,0.1-1.6-0.4-2.2L35,74h4.4c0.8,0,1.5-0.5,1.8-1.2s0.2-1.6-0.4-2.2l-6.5-6.8h3 c0.8,0,1.5-0.5,1.8-1.2c0.3-0.7,0.2-1.6-0.4-2.2L25.4,46.6C25.1,46.2,24.5,46,24,46L24,46z M24,50.9l8.7,9h-3 c-0.8,0-1.5,0.5-1.8,1.2s-0.2,1.6,0.4,2.2l6.5,6.8h-4.5c-0.8,0-1.5,0.5-1.8,1.2c-0.3,0.7-0.1,1.6,0.4,2.2l8.5,8.6H10.8l8.5-8.6 c0.6-0.6,0.7-1.4,0.4-2.2c-0.3-0.7-1-1.2-1.8-1.2h-4.5l6.5-6.8c0.6-0.6,0.7-1.4,0.4-2.2c-0.3-0.7-1-1.2-1.8-1.2h-3L24,50.9z"/>';
var DUCK_ICON = "BC-duck-icon";
var DUCK_ICON_SVG = '<path fill="currentColor" stroke="currentColor" d="M72,31c0-1.5-1.2-2.8-2.8-2.8c-1.5,0-2.8,1.2-2.8,2.8s1.2,2.8,2.8,2.8C70.8,33.8,72,32.6,72,31z M80.4,47.7c10.7,0,19.4-8.7,19.4-19.4H88.4c-0.1-0.6-0.1-1.1-0.2-1.7c-1.6-7.1-7.3-12.8-14.3-144c-1.6-0.4-3.1-0.5-4.6-0.5c-10.7,0-19.4,8.7-19.4,19.4v13.9h-9.4c-6.8,0-13.6-2.4-18.2-7.3c-0.7-0.7-1.6-1.1-2.4-11c-1.7,0-3.3,1.3-3.3,3.3c0,16.4,12.5,31,28.6,32.6c1.6,0.2,3.1-1.1,3.1-2.8v-2.8c0-1.4-1-2.6-2.4-2.7c-7.9-09-14.8-6.2-18.4-13.5c4.1,1.6,8.5,2.5,13.1,2.5l17.7,0.1V31c0-6.1,5-11.1,11.1-11.1c0.9,0,1.8,0.1,2.7,0.3c3.9,0.9,7.2,4.2,8.1,8.1C814,34.4,78,39.1,74,41l-4.7,2.3v12.4l2.1,2.4c1.5,1.8,3.4,4.7,3.5,8.8c0.1,3.4-1.3,6.7-3.9,9.4c-3,3-7,4.8-11.2,4.8H43.9c-1,0-2.1-01-3.2-0.2C25.2,79.5,12.3,68.1,8.7,53.2h5.1c-1.2-2.7-2-5.5-2.5-8.3H5.4c-3.3,0-6,3-5.5,6.3c2.9,20.3,19.4,36.1,40,38c1.3,0.1,2.6,02,4,0.2h15.8c12.5,0,23.7-10.2,23.4-22.7c-0.1-5.4-2.2-10.3-5.6-14.1v-4.9H80.4L80.4,47.7z"/>';
var splitLinksRegex = new RegExp(/\[\[(.+?)\]\]/g);
var dropHeaderOrAlias = new RegExp(/\[\[([^#|]+)\]\]/);
var regNFlags = new RegExp(/^.(.*?)\W(\w*)$/);
var TRAIL_LENGTHS = [
  "Shortest",
  "Longest",
  "All"
];
var VISTYPES = [
  "Force Directed Graph",
  "Tidy Tree",
  "Circle Packing",
  "Edge Bundling",
  "Arc Diagram",
  "Sunburst",
  "Tree Map",
  "Icicle",
  "Radial Tree"
];
var DIRECTIONS = ["up", "same", "down", "next", "prev"];
var ARROW_DIRECTIONS = {
  up: "\u2191",
  same: "\u2194",
  down: "\u2193",
  next: "\u2192",
  prev: "\u2190"
};
var RELATIONS = ["Parent", "Sibling", "Child"];
var REAlCLOSED = ["Real", "Closed"];
var ALLUNLINKED = ["All", "No Unlinked"];
var CODEBLOCK_TYPES = ["tree", "juggl"];
var CODEBLOCK_FIELDS = [
  "type",
  "dir",
  "fields",
  "depth",
  "title",
  "flat",
  "content",
  "from",
  "implied"
];
var JUGGL_CB_DEFAULTS = {
  // @ts-ignore
  animateLayout: true,
  autoAddNodes: false,
  autoExpand: false,
  autoZoom: false,
  coreStore: "core",
  expandInitial: false,
  fdgdLayout: "d3-force",
  filter: "",
  height: "750px",
  hoverEdges: false,
  layout: "force-directed",
  limit: 250,
  mergeEdges: true,
  // metaKeyHover: true,
  mode: "workspace",
  navigator: true,
  openWithShift: false,
  readContent: true,
  styleGroups: [],
  toolbar: true,
  width: "100%",
  zoomSpeed: 1
};
var JUGGL_TRAIL_DEFAULTS = Object.assign(
  JUGGL_CB_DEFAULTS,
  {
    animateLayout: true,
    autoZoom: false,
    fdgdLayout: "d3-force",
    height: "300px",
    readContent: false,
    toolbar: false,
    navigator: false
  }
);
CODEBLOCK_FIELDS.push(...Object.keys(JUGGL_CB_DEFAULTS));
var blankUserHier = () => {
  return { up: [], same: [], down: [], next: [], prev: [] };
};
var blankRealNImplied = () => {
  return {
    up: { reals: [], implieds: [] },
    down: { reals: [], implieds: [] },
    same: { reals: [], implieds: [] },
    next: { reals: [], implieds: [] },
    prev: { reals: [], implieds: [] }
  };
};
var [
  BC_I_AUNT,
  BC_I_COUSIN,
  BC_I_SIBLING_1,
  BC_I_SIBLING_2,
  BC_I_REFLEXIVE,
  BC_I_PARENT
] = [
  "BC-Aunt",
  "BC-Cousin",
  "BC-Sibling-1",
  "BC-Sibling-2",
  "BC-Reflexive",
  "BC-Parent"
];
var [
  BC_FOLDER_NOTE,
  BC_FOLDER_NOTE_SUBFOLDERS,
  BC_FOLDER_NOTE_RECURSIVE,
  BC_TAG_NOTE,
  BC_TAG_NOTE_FIELD,
  BC_TAG_NOTE_EXACT,
  BC_LINK_NOTE,
  BC_TRAVERSE_NOTE,
  BC_REGEX_NOTE,
  BC_REGEX_NOTE_FIELD,
  BC_DV_NOTE,
  BC_DV_NOTE_FIELD,
  BC_IGNORE,
  BC_IGNORE_DENDRON,
  BC_HIDE_TRAIL,
  BC_ORDER
] = [
  "BC-folder-note",
  "BC-folder-note-subfolders",
  "BC-folder-note-recursive",
  "BC-tag-note",
  "BC-tag-note-field",
  "BC-tag-note-exact",
  "BC-link-note",
  "BC-traverse-note",
  "BC-regex-note",
  "BC-regex-note-field",
  "BC-dataview-note",
  "BC-dataview-note-field",
  "BC-ignore",
  "BC-ignore-dendron",
  "BC-hide-trail",
  "BC-order"
];
var BC_FIELDS_INFO = [
  {
    field: BC_FOLDER_NOTE,
    desc: "Set this note as a Breadcrumbs folder-note. All other notes in this folder will be added to the graph with the field name specified in this key's value",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: true
  },
  {
    field: BC_FOLDER_NOTE_SUBFOLDERS,
    desc: "Link to notes in subfolders with the given field.",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: false
  },
  {
    field: BC_FOLDER_NOTE_RECURSIVE,
    desc: "Recursively add notes in subfolders to the foldernote of _that_ subfolder.",
    afterYaml: ": true",
    afterInline: ":: true",
    alt: false
  },
  {
    field: BC_TAG_NOTE,
    desc: "Set this note as a Breadcrumbs tag-note. All other notes with this tag will be added to the graph using the default fieldName specified in `Settings > Alternative Hierarchies > Tag Notes > Default Field`, or using the fieldName you specify with `BC-tag-note-field: fieldName`",
    afterYaml: ": '#",
    afterInline: ":: #",
    alt: true
  },
  {
    field: BC_TAG_NOTE_FIELD,
    desc: "Manually choose the field for this tag-note to use",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: false
  },
  {
    field: BC_TAG_NOTE_EXACT,
    desc: "Only look for notes with the exact tag. i.e. `#A` won't match `#A/B`",
    afterYaml: ": true",
    afterInline: ":: true",
    alt: false
  },
  {
    field: BC_LINK_NOTE,
    desc: "Set this note as a Breadcrumbs link-note. All links leaving this note will be added to the graph with the field name specified in this key's value.",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: true
  },
  {
    field: BC_TRAVERSE_NOTE,
    desc: "Set this note as a Breadcrumbs traverse-note. Starting from this note, the Obsidian graph will be traversed in depth-first order, and all notes along the way will be added to the BC graph using the fieldName you specify",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: true
  },
  {
    field: BC_REGEX_NOTE,
    desc: "Set this note as a Breadcrumbs regex-note. The value of this field is a regular expression (of the form '/regex/flags'). All note names that match the regex will be added to the BC graph using the default fieldName specified in `Settings > Alternative Hierarchies > Regex Notes > Default Field`, or using the fieldName you specify in 'BC-regex-note-field'.",
    afterYaml: ": '/",
    afterInline: ":: /",
    alt: true
  },
  {
    field: BC_REGEX_NOTE_FIELD,
    desc: "Manually choose the field for this regex-note to use",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: false
  },
  {
    field: BC_DV_NOTE,
    desc: "Set this note as a Breadcrumbs Dataview-note. The value of this field is a Dataview `from` query. All notes that match the query will be added to the BC graph using the default fieldName specified in `Settings > Alternative Hierarchies > Dataview Notes > Default Field`, or using the fieldName you specify in 'BC-dataview-note-field'.",
    afterYaml: ": '",
    afterInline: ":: ",
    alt: true
  },
  {
    field: BC_DV_NOTE_FIELD,
    desc: "Manually choose the field for this Dataview-note to use",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: false
  },
  {
    field: BC_IGNORE,
    desc: "Tells Breadcrumbs to ignore a note from its index entirely. This is useful if you want to use Breadcrumbs to index notes, but you don't want to show them in the graph.",
    afterYaml: ": true",
    afterInline: ":: true",
    alt: false
  },
  {
    field: BC_IGNORE_DENDRON,
    desc: "Tells Breadcrumbs to not treat this note as a dendron note (only useful if the note name has you dendron splitter in it, usually a period `.`).",
    afterYaml: ": true",
    afterInline: ":: true",
    alt: false
  },
  {
    field: BC_HIDE_TRAIL,
    desc: "Don't show the trail in this note",
    afterYaml: ": true",
    afterInline: ":: true",
    alt: false
  },
  {
    field: BC_ORDER,
    desc: "Set the order of this note in the Matrix view. A lower value places this note higher in the order.",
    afterYaml: ": ",
    afterInline: ":: ",
    alt: false
  }
];
var BC_ALTS = BC_FIELDS_INFO.filter((f) => f.alt).map((f) => f.field);
var ILLEGAL_FILENAME_CHARS = [
  "\\",
  "/",
  ":",
  "*",
  "?",
  '"',
  "<",
  ">",
  "|"
];
var DATAVIEW_MISSING = "The Dataview plugin must be installed for this to work";
var API_NAME = "BCAPI";
var DEFAULT_SETTINGS = {
  addDendronNotes: false,
  addDateNotes: false,
  aliasesInIndex: false,
  alphaSortAsc: true,
  altLinkFields: [],
  CSVPaths: "",
  createIndexIndent: "  ",
  dateFormat: "YYYY-MM-DD",
  dateNoteFormat: "yyyy-MM-dd",
  dateNoteField: "next",
  dataviewNoteField: "up",
  dateNoteAddMonth: "",
  dateNoteAddYear: "",
  debugMode: "WARN",
  dendronNoteDelimiter: ".",
  dendronNoteField: "up",
  dvWaitTime: 5e3,
  enableAlphaSort: true,
  enableRelationSuggestor: false,
  fieldSuggestor: true,
  filterImpliedSiblingsOfDifferentTypes: false,
  jugglLayout: "hierarchy",
  limitWriteBCCheckboxes: [],
  CHECKBOX_STATES_OVERWRITTEN: false,
  gridDefaultDepth: 25,
  hierarchyNotes: [""],
  hierarchyNoteIsParent: false,
  HNUpField: "",
  indexNotes: [""],
  namingSystemField: "",
  namingSystemRegex: "",
  namingSystemSplit: ".",
  namingSystemEndsWithDelimiter: false,
  refreshOnNoteChange: false,
  useAllMetadata: true,
  openMatrixOnLoad: true,
  openDuckOnLoad: false,
  openDownOnLoad: true,
  parseJugglLinksWithoutJuggl: false,
  showNameOrType: true,
  showRelationType: true,
  regexNoteField: "",
  relSuggestorTrigger: "\\",
  rlLeaf: true,
  showAllPathsIfNoneToIndexNote: false,
  showAllAliases: true,
  showBCs: true,
  showBCsInEditLPMode: false,
  showRefreshNotice: true,
  showImpliedRelations: true,
  showTrail: true,
  showGrid: true,
  showJuggl: false,
  showPrevNext: true,
  sortByNameShowAlias: false,
  squareDirectionsOrder: [0, 1, 2, 3, 4],
  limitTrailCheckboxes: [],
  limitJumpToFirstFields: [],
  showAll: "All",
  noPathMessage: `This note has no real or implied parents`,
  tagNoteField: "",
  threadIntoNewPane: false,
  threadingTemplate: "{{field}} of {{current}}",
  threadingDirTemplates: { up: "", same: "", down: "", next: "", prev: "" },
  threadUnderCursor: false,
  trailSeperator: "\u2192",
  treatCurrNodeAsImpliedSibling: false,
  trimDendronNotes: false,
  respectReadableLineLength: true,
  userHiers: [
    {
      up: ["up"],
      same: ["same"],
      down: ["down"],
      next: ["next"],
      prev: ["prev"]
    }
  ],
  writeBCsInline: false,
  showWriteAllBCsCmd: false,
  visGraph: "Force Directed Graph",
  visRelation: "Parent",
  visClosed: "Real",
  visAll: "All",
  wikilinkIndex: true,
  impliedRelations: {
    siblingIdentity: false,
    sameParentIsSibling: true,
    siblingsSiblingIsSibling: false,
    siblingsParentIsParent: false,
    parentsSiblingsIsParents: false,
    parentsParentsIsParent: false,
    cousinsIsSibling: false
  },
  refreshOnNoteSave: false,
  showUpInJuggl: false
};

// src/Views/MatrixView.ts
var import_loglevel14 = __toESM(require_loglevel());
var import_obsidian10 = require("obsidian");

// src/Debugger.ts
var import_loglevel = __toESM(require_loglevel());
var Debugger = class {
  constructor(plugin) {
    this.debugLessThan = (level) => import_loglevel.levels[this.plugin.settings.debugMode] < level;
    this.plugin = plugin;
  }
  start2G(group) {
    if (this.debugLessThan(3))
      console.groupCollapsed(group);
  }
  end2G(...msgs) {
    if (this.debugLessThan(3)) {
      if (msgs.length)
        (0, import_loglevel.info)(...msgs);
      console.groupEnd();
    }
  }
  start1G(group) {
    if (this.debugLessThan(2))
      console.groupCollapsed(group);
  }
  end1G(...msgs) {
    if (this.debugLessThan(2)) {
      if (msgs.length)
        (0, import_loglevel.debug)(...msgs);
      console.groupEnd();
    }
  }
  startGs(...groups) {
    this.start2G(groups[0]);
    if (groups[1])
      this.start1G(groups[1]);
  }
  /**
   * End a debug and info group, logging `msgs` in `endDebugGroup`
   * @param  {1|2} count The number of groups to end. `1` ends Trace, 2 ends both
   * @param  {any[]} ...msgs
   */
  endGs(count2, ...msgs) {
    if (count2 === 1)
      this.end2G(...msgs);
    else {
      this.end1G();
      this.end2G(...msgs);
    }
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root2 && root2.host) {
    return root2;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function get_binding_group_value(group, __value, checked) {
  const value = /* @__PURE__ */ new Set();
  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked)
      value.add(group[i].__value);
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function init_binding_group(group) {
  let _inputs;
  return {
    /* push */
    p(...inputs) {
      _inputs = inputs;
      _inputs.forEach((input) => group.push(input));
    },
    /* remove */
    r() {
      _inputs.forEach((input) => group.splice(group.indexOf(input), 1));
    }
  };
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c3) => fns.indexOf(c3) === -1 ? filtered.push(c3) : targets.push(c3));
  targets.forEach((c3) => c3());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function get_spread_update(levels2, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels2.length;
  while (i--) {
    const o = levels2[i];
    const n2 = updates[i];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels2[i] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance24, create_fragment24, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance24 ? instance24(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment24 ? create_fragment24($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type2, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type2, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/refreshIndex.ts
var import_graphology2 = __toESM(require_graphology_umd_min());
var import_loglevel13 = __toESM(require_loglevel());
var import_obsidian9 = require("obsidian");

// src/AlternativeHierarchies/CSVCrumbs.ts
var import_loglevel5 = __toESM(require_loglevel());
var import_obsidian4 = require("obsidian");

// src/Utils/ObsidianUtils.ts
var import_loglevel3 = __toESM(require_loglevel());
var import_obsidian3 = require("obsidian");

// src/Utils/generalUtils.ts
var import_loglevel2 = __toESM(require_loglevel());
var dropPath = (path2) => path2.replace(/^.*\//, "");
var dropDendron = (path2, settings) => settings.trimDendronNotes ? path2.split(settings.dendronNoteDelimiter).last() : path2;
var dropPathNDendron = (path2, settings) => dropDendron(dropPath(path2), settings);
var dropFolder = (path2) => path2.split("/").last().split(".").slice(0, -1).join(".");
var splitAndTrim = (fields) => {
  if (!fields || fields === "")
    return [];
  else
    return fields.split(",").map((str) => str.trim());
};
function padArray(arr, finalLength, filler = "") {
  const copy3 = [...arr];
  const currLength = copy3.length;
  if (currLength > finalLength)
    throw new Error("Current length is greater than final length");
  else if (currLength === finalLength)
    return copy3;
  else {
    for (let i = currLength; i < finalLength; i++)
      copy3.push(filler);
    return copy3;
  }
}
function transpose(A2) {
  const cols = A2[0].length;
  const AT = [];
  for (let j = 0; j < cols; j++)
    AT.push(A2.map((row) => row[j]));
  return AT;
}
function runs(arr) {
  const runs2 = [];
  let i = 0;
  while (i < arr.length) {
    const currValue = arr[i];
    runs2.push({ value: currValue, first: i, last: void 0 });
    while (currValue === arr[i]) {
      i++;
    }
    runs2.last().last = i - 1;
  }
  return runs2;
}
function swapItems(i, j, arr) {
  const max4 = arr.length - 1;
  if (i < 0 || i > max4 || j < 0 || j > max4)
    return arr;
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
  return arr;
}
function strToRegex(input) {
  const match2 = input.match(regNFlags);
  if (!match2)
    return null;
  const [, innerRegex, flags] = match2;
  try {
    const regex = new RegExp(innerRegex, flags);
    return regex;
  } catch (e) {
    (0, import_loglevel2.warn)(e);
    return null;
  }
}
function escapeRegex(string) {
  return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// src/Utils/ObsidianUtils.ts
var getSettings = () => app.plugins.plugins.breadcrumbs.settings;
var getCurrFile = () => app.workspace.getActiveFile();
var getBaseFromMDPath = (path2) => {
  const splitSlash = path2.split("/").last();
  if (splitSlash.endsWith(".md")) {
    return splitSlash.split(".md").slice(0, -1).join(".");
  } else
    return splitSlash;
};
var getDVBasename = (file) => file.basename || file.name;
var getFolderName = (file) => {
  var _a;
  return (
    //@ts-ignore
    ((_a = file == null ? void 0 : file.parent) == null ? void 0 : _a.name) || file.folder
  );
};
function makeWiki(str, wikiQ = true) {
  let copy3 = str.slice();
  if (wikiQ) {
    copy3 = "[[" + copy3;
    copy3 += "]]";
  }
  return copy3;
}
function dropWikilinks(str) {
  let copy3 = str.slice();
  if (copy3.startsWith("[[") && copy3.endsWith("]]"))
    copy3 = copy3.slice(2, -2);
  return copy3;
}
var createOrUpdateYaml = async (key, value, file, frontmatter, api) => {
  const valueStr = value.toString();
  if (!frontmatter || frontmatter[key] === void 0) {
    (0, import_loglevel3.info)(`Creating: ${key}: ${valueStr}`);
    await api.createYamlProperty(key, `['${valueStr}']`, file);
  } else if ([...[frontmatter[key]]].flat(3).some((val) => val == valueStr)) {
    (0, import_loglevel3.info)("Already Exists!");
    return;
  } else {
    const oldValueFlat = [...[frontmatter[key]]].flat(4);
    const newValue = [...oldValueFlat, `'${valueStr}'`];
    (0, import_loglevel3.info)(`Updating: ${key}: ${newValue}`);
    await api.update(key, `[${newValue.join(", ")}]`, file);
  }
};
function changeYaml(yaml, key, newVal) {
  if (yaml === "") {
    return `${key}: ['${newVal}']`;
  } else {
    const parsed = (0, import_obsidian3.parseYaml)(yaml);
    const value = parsed[key];
    if (value === void 0) {
      parsed[key] = newVal;
    } else if (typeof value === "string" && value !== newVal) {
      parsed[key] = [value, newVal];
    } else if (typeof (value == null ? void 0 : value[0]) === "string" && value.includes && !value.includes(newVal)) {
      parsed[key] = [...value, newVal];
    }
    return (0, import_obsidian3.stringifyYaml)(parsed);
  }
}
function splitAtYaml2(content) {
  if (!content.startsWith("---\n"))
    return ["", content];
  else {
    const splits = content.split("---");
    return [
      splits.slice(0, 2).join("---") + "---",
      splits.slice(2).join("---")
    ];
  }
}
var dropHash = (tag) => tag.startsWith("#") ? tag.slice(1) : tag;
var addHash = (tag) => tag.startsWith("#") ? tag : `#${tag}`;
function getAlt(node, plugin) {
  var _a;
  const { altLinkFields, showAllAliases } = plugin.settings;
  if (altLinkFields.length) {
    const file = app.metadataCache.getFirstLinkpathDest(node, "");
    if (file) {
      const metadata = app.metadataCache.getFileCache(file);
      for (const altField of altLinkFields) {
        const value = (_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a[altField];
        const arr = typeof value === "string" ? splitAndTrim(value) : value;
        if (value)
          return showAllAliases ? arr.join(", ") : arr[0];
      }
    }
  } else
    return null;
}
async function waitForCache(plugin) {
  var _a;
  if (app.plugins.enabledPlugins.has("dataview")) {
    let basename;
    while (!basename || !app.plugins.plugins.dataview.api.page(basename)) {
      await wait(100);
      basename = (_a = getCurrFile()) == null ? void 0 : _a.basename;
    }
  } else {
    await waitForResolvedLinks();
  }
}
var linkClass = (to, realQ = true) => `internal-link BC-Link ${isInVault(to) ? "" : "is-unresolved"} ${realQ ? "" : "BC-Implied"}`;
var getDVApi = (plugin) => {
  var _a;
  return (_a = app.plugins.plugins.dataview) == null ? void 0 : _a.api;
};
function isInsideYaml() {
  const { workspace, metadataCache } = app;
  const { activeLeaf } = workspace;
  const {
    state: { mode }
  } = activeLeaf.getViewState();
  if (mode !== "source")
    return null;
  const { editor } = activeLeaf.view;
  const file = getCurrFile();
  if (!file)
    return null;
  const { frontmatter } = metadataCache.getFileCache(file);
  if (!frontmatter)
    return false;
  const { start: start2, end } = frontmatter.position;
  const currOff = editor.posToOffset(editor.getCursor());
  if (currOff >= start2.offset && currOff <= end.offset)
    return true;
  else
    return false;
}

// src/Utils/graphUtils.ts
var import_graphology = __toESM(require_graphology_umd_min());
var import_graphology_traversal = __toESM(require_graphology_traversal());
var import_loglevel4 = __toESM(require_loglevel());

// src/Utils/HierUtils.ts
function getFields(userHiers, dir = "all") {
  const fields = [];
  userHiers.forEach((hier) => {
    if (dir === "all") {
      DIRECTIONS.forEach((eachDir) => {
        fields.push(...hier[eachDir]);
      });
    } else {
      fields.push(...hier[dir]);
    }
  });
  return fields;
}
var getOppDir = (dir) => {
  switch (dir) {
    case "up":
      return "down";
    case "down":
      return "up";
    case "same":
      return "same";
    case "next":
      return "prev";
    case "prev":
      return "next";
  }
};
function getFieldInfo(userHiers, field) {
  let fieldDir;
  let fieldHier;
  DIRECTIONS.forEach((dir) => {
    userHiers.forEach((hier) => {
      if (hier[dir].includes(field)) {
        fieldDir = dir;
        fieldHier = hier;
        return;
      }
    });
  });
  return { fieldHier, fieldDir };
}
function getOppFields(userHiers, field, dir) {
  if (field.endsWith(">"))
    return [field.slice(0, -4)];
  const oppFields = [fallbackOppField(field, dir)];
  const { fieldHier, fieldDir } = getFieldInfo(userHiers, field);
  if (!fieldHier || !fieldDir)
    return oppFields;
  const oppDir = getOppDir(fieldDir);
  oppFields.unshift(...fieldHier[oppDir]);
  return oppFields;
}
var hierToStr = (hier) => DIRECTIONS.map(
  (dir) => `${ARROW_DIRECTIONS[dir]}: ${hier[dir].join(", ")}`
).join("\n");
var fallbackField = (field, dir) => `${field} <${ARROW_DIRECTIONS[dir]}>`;
var fallbackOppField = (field, dir) => `${field} <${ARROW_DIRECTIONS[getOppDir(dir)]}>`;
function iterateHiers(userHiers, fn) {
  userHiers.forEach((hier) => {
    DIRECTIONS.forEach((dir) => {
      hier[dir].forEach((field) => {
        fn(hier, dir, field);
      });
    });
  });
}

// src/Utils/graphUtils.ts
function closeImpliedLinks(real, implied) {
  const closedG = real.copy();
  implied.forEachEdge((key, a2, s2, t) => {
    closedG.mergeEdge(t, s2, a2);
  });
  return closedG;
}
function removeUnlinkedNodes(g) {
  const copy3 = g.copy();
  copy3.forEachNode((node) => {
    if (!copy3.degree(node))
      copy3.dropNode(node);
  });
  return copy3;
}
function getSubInDirs(g, ...dirs) {
  const sub = new import_graphology.MultiGraph();
  g == null ? void 0 : g.forEachEdge((k, a2, s2, t) => {
    if (dirs.includes(a2.dir)) {
      addNodesIfNot(sub, [s2, t], { order: a2.order });
      sub.addEdge(s2, t, a2);
    }
  });
  return sub;
}
function getSubForFields(g, fields) {
  const sub = new import_graphology.MultiGraph();
  g.forEachEdge((k, a2, s2, t) => {
    if (fields.includes(a2.field)) {
      addNodesIfNot(sub, [s2, t], { order: a2.order });
      sub.addEdge(s2, t, a2);
    }
  });
  return sub;
}
function getReflexiveClosure(g, userHiers) {
  const copy3 = g.copy();
  copy3.forEachEdge((k, a2, s2, t) => {
    const { dir, field } = a2;
    if (field === void 0)
      return;
    const oppDir = getOppDir(dir);
    const oppField = dir === "same" ? field : getOppFields(userHiers, field, dir)[0];
    addNodesIfNot(copy3, [s2, t], { order: 9999 });
    addEdgeIfNot(copy3, t, s2, {
      dir: oppDir,
      field: oppField,
      implied: BC_I_REFLEXIVE
    });
  });
  return copy3;
}
function addNodesIfNot(g, nodes, attr2 = { order: 9999 }) {
  for (const node of nodes) {
    g.updateNode(node, (exstantAttrs) => {
      const extantOrder = exstantAttrs.order;
      return {
        ...exstantAttrs,
        order: extantOrder && extantOrder < 9999 ? extantOrder : attr2.order
      };
    });
  }
}
function addEdgeIfNot(g, source, target, attr2) {
  if (!g.hasEdge(source, target))
    g.addEdge(source, target, attr2);
}
var getSinks = (g) => g.filterNodes((node) => g.hasNode(node) && !g.outDegree(node));
var getOutNeighbours = (g, node) => g.hasNode(node) ? g.outNeighbors(node) : [];
var getInNeighbours = (g, node) => g.hasNode(node) ? g.inNeighbors(node) : [];
function dfsAllPaths(g, start2) {
  const queue = [{ node: start2, path: [] }];
  const visited = {};
  const allPaths = [];
  let i = 0;
  while (queue.length > 0 && i < 1e3) {
    i++;
    const { node, path: path2 } = queue.shift();
    const extPath = [node, ...path2];
    const succsNotVisited = g.hasNode(node) ? g.filterOutNeighbors(
      node,
      (succ) => !visited[succ] || visited[succ] < 5
    ) : [];
    const newItems = succsNotVisited.map((succ) => {
      visited[succ] = visited[succ] ? visited[succ] + 1 : 1;
      return { node: succ, path: extPath };
    });
    queue.unshift(...newItems);
    if (!g.hasNode(node) || !g.outDegree(node))
      allPaths.push(extPath);
  }
  return allPaths;
}
function bfsAllPaths(g, start2) {
  const pathsArr = [];
  const queue = [{ node: start2, path: [] }];
  let i = 0;
  while (queue.length !== 0 && i < 1e3) {
    i++;
    const { node, path: path2 } = queue.shift();
    const extPath = [node, ...path2];
    const succs = g.hasNode(node) ? g.filterOutNeighbors(node, (n2) => !path2.includes(n2)) : [];
    for (const node2 of succs) {
      queue.push({ node: node2, path: extPath });
    }
    if (!g.hasNode(node) || succs.length === 0) {
      pathsArr.push(extPath);
    }
  }
  pathsArr.forEach((path2) => {
    if (path2.length)
      path2.splice(path2.length - 1, 1);
  });
  (0, import_loglevel4.info)({ pathsArr });
  return pathsArr;
}
function removeCycles(g, startNode) {
  const copy3 = g.copy();
  let prevNode = null;
  (0, import_graphology_traversal.dfsFromNode)(copy3, startNode, (n2) => {
    copy3.forEachOutNeighbor(n2, (t) => {
      if (t === prevNode && copy3.hasEdge(t, prevNode)) {
        try {
          copy3.dropEdge(t, prevNode);
        } catch (error6) {
          console.error(t, prevNode, error6);
        }
      }
    });
    prevNode = n2;
  });
  return copy3;
}
function buildObsGraph() {
  const ObsG = new import_graphology.MultiGraph();
  const { resolvedLinks, unresolvedLinks } = app.metadataCache;
  for (const source in resolvedLinks) {
    if (!source.endsWith(".md"))
      continue;
    const sourceBase = getBaseFromMDPath(source);
    addNodesIfNot(ObsG, [sourceBase]);
    for (const dest in resolvedLinks[source]) {
      if (!dest.endsWith(".md"))
        continue;
      const destBase = getBaseFromMDPath(dest);
      addNodesIfNot(ObsG, [destBase]);
      ObsG.addEdge(sourceBase, destBase, { resolved: true });
    }
  }
  for (const source in unresolvedLinks) {
    const sourceBase = getBaseFromMDPath(source);
    addNodesIfNot(ObsG, [sourceBase]);
    for (const dest in unresolvedLinks[source]) {
      const destBase = getBaseFromMDPath(dest);
      addNodesIfNot(ObsG, [destBase]);
      if (sourceBase === destBase)
        continue;
      ObsG.addEdge(sourceBase, destBase, { resolved: false });
    }
  }
  (0, import_loglevel4.info)({ ObsG });
  return ObsG;
}
function populateMain(settings, mainG, source, field, target, sourceOrder, targetOrder, fillOpp = false) {
  const { userHiers } = settings;
  const dir = getFieldInfo(userHiers, field).fieldDir;
  addNodesIfNot(mainG, [source], {
    order: sourceOrder
  });
  addNodesIfNot(mainG, [target], {
    order: targetOrder
  });
  addEdgeIfNot(mainG, source, target, {
    dir,
    field
  });
  if (fillOpp) {
    addEdgeIfNot(mainG, target, source, {
      dir: getOppDir(dir),
      field: getOppFields(userHiers, field, dir)[0]
    });
  }
}
var getTargetOrder = (frontms, target) => {
  var _a, _b;
  return parseInt(
    (_b = (_a = frontms.find((ff) => {
      var _a2;
      return ((_a2 = ff == null ? void 0 : ff.file) == null ? void 0 : _a2.basename) === target;
    })) == null ? void 0 : _a[BC_ORDER]) != null ? _b : "9999"
  );
};
var getSourceOrder = (frontm) => {
  var _a;
  return parseInt((_a = frontm[BC_ORDER]) != null ? _a : "9999");
};
function getRealnImplied(plugin, currNode, dir = null) {
  const realsnImplieds = blankRealNImplied();
  const { settings, closedG } = plugin;
  const { userHiers } = settings;
  if (!closedG.hasNode(currNode))
    return realsnImplieds;
  closedG.forEachEdge(currNode, (k, a2, s2, t) => {
    const { field, dir: edgeDir, implied } = a2;
    const oppField = getOppFields(userHiers, field, edgeDir)[0];
    (dir ? [dir, getOppDir(dir)] : DIRECTIONS).forEach(
      (currDir) => {
        const oppDir = getOppDir(currDir);
        if (s2 === currNode && (edgeDir === currDir || edgeDir === oppDir)) {
          const arr = realsnImplieds[edgeDir].reals;
          if (arr.findIndex((item) => item.to === t) === -1) {
            arr.push({ to: t, field, implied });
          }
        } else if (edgeDir === currDir || edgeDir === oppDir) {
          const arr = realsnImplieds[getOppDir(edgeDir)].implieds;
          if (arr.findIndex((item) => item.to === s2) === -1) {
            arr.push({
              to: s2,
              field: oppField,
              implied
            });
          }
        }
      }
    );
  });
  return realsnImplieds;
}

// src/AlternativeHierarchies/CSVCrumbs.ts
async function getCSVRows(plugin) {
  const { CSVPaths } = plugin.settings;
  const CSVRows = [];
  if (CSVPaths === "")
    return CSVRows;
  const fullPath = (0, import_obsidian4.normalizePath)(CSVPaths);
  const content = await app.vault.adapter.read(fullPath);
  const lines = content.split("\n");
  const headers = lines[0].split(",").map((head) => head.trim());
  lines.slice(1).forEach((row) => {
    const rowObj = {};
    row.split(",").map((head) => dropWikilinks(head.trim())).forEach((item, i) => {
      rowObj[headers[i]] = item;
    });
    (0, import_loglevel5.debug)({ rowObj });
    CSVRows.push(rowObj);
  });
  return CSVRows;
}
function addCSVCrumbs(g, CSVRows, dir, field) {
  CSVRows.forEach((row) => {
    addNodesIfNot(g, [row.file]);
    if (field === "" || !row[field])
      return;
    addNodesIfNot(g, [row[field]]);
    addEdgeIfNot(g, row.file, row[field], { dir, field });
  });
}

// src/AlternativeHierarchies/DataviewNotes.ts
var import_loglevel6 = __toESM(require_loglevel());
var import_obsidian5 = require("obsidian");
function addDataviewNotesToGraph(plugin, eligableAlts, frontms, mainG) {
  const { settings } = plugin;
  const { userHiers, dataviewNoteField } = settings;
  const dv = getDVApi(plugin);
  if (!dv && eligableAlts.length) {
    new import_obsidian5.Notice(DATAVIEW_MISSING);
    return;
  }
  const fields = getFields(userHiers);
  eligableAlts.forEach((altFile) => {
    var _a;
    const basename = getDVBasename(altFile.file);
    let query = altFile[BC_DV_NOTE];
    if (query.hasOwnProperty("path")) {
      query = `[[${query.path}]]`;
    }
    let field = (_a = altFile[BC_DV_NOTE_FIELD]) != null ? _a : dataviewNoteField || fields[0];
    let targets = [];
    try {
      targets = dv.pages(query).values;
    } catch (er) {
      new import_obsidian5.Notice(`${query} is not a valid Dataview from-query`);
      (0, import_loglevel6.warn)(er);
    }
    for (const target of targets) {
      if (target[BC_IGNORE])
        continue;
      const targetBN = getDVBasename(target.file);
      const sourceOrder = getSourceOrder(altFile);
      const targetOrder = getTargetOrder(frontms, targetBN);
      populateMain(
        settings,
        mainG,
        basename,
        field,
        targetBN,
        sourceOrder,
        targetOrder,
        true
      );
    }
  });
}

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit2) {
    super(`Invalid unit ${unit2}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a2, k) => {
    a2[k] = obj[k];
    return a2;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x4, n2) {
  return x4 - n2 * Math.floor(x4 / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number3, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number3 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > 60 ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale2, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date).find((m2) => m2.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format2) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format2) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format2} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit2, count2, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit2) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit2 === "days";
    switch (count2) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit2][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit2][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit2][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count2, -0) || count2 < 0, fmtValue = Math.abs(count2), singular = fmtValue === 1, lilUnits = units[unit2], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit2][0] : unit2;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale2, opts = {}) {
    return new Formatter(locale2, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c3 = fmt.charAt(i);
      if (c3 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c3;
      } else if (c3 === current) {
        currentFull += c3;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c3;
        current = c3;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale2, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale2;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }
  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format2) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts, format2, locale2);
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format: format2, locale: locale2 }) {
    return parseZoneInfo(ts, format2, locale2, this.name);
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.offset(ts), format2);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format2) {
    return formatOffset(this.fixed, format2);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "local" || lowered === "system")
      return defaultZone2;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var throwOnInvalid;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale2) {
    defaultLocale = locale2;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }
    const { numberingSystem, calendar } = options;
    return [smaller, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    let z;
    if (dt.zone.isUniversal) {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1e3);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }
    const intlOpts = { ...this.opts };
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count2, unit2) {
    if (this.rtf) {
      return this.rtf.format(count2, unit2);
    } else {
      return formatRelativeTime(unit2, count2, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count2, unit2) {
    if (this.rtf) {
      return this.rtf.formatToParts(count2, unit2);
    } else {
      return [];
    }
  }
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale2, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale2 || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale2, numberingSystem, outputCalendar);
  }
  constructor(locale2, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale2);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format2 = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format2 ? { month: length, day: "numeric" } : { month: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format2 = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format2 ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format2 ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems(defaultOK = true) {
    return listStuff(
      this,
      void 0,
      defaultOK,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m2) => m2.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/impl/regexParser.js
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m2) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m2, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m2 = regex.exec(s2);
    if (m2) {
      return extractor(m2);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m2 = match2[pos];
  return isUndefined(m2) ? fallback : parseInteger(m2);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [
    s2,
    yearStr,
    monthStr,
    weekStr,
    dayStr,
    hourStr,
    minuteStr,
    secondStr,
    millisecondsStr
  ] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
  };
  return new Duration(conf);
}
function antiTrunc(n2) {
  return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
}
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
var Duration = class {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = accurate ? accurateMatrix : casualMatrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count2, opts) {
    return Duration.fromObject({ milliseconds: count2 }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit2) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit2 ? unit2.toLowerCase() : unit2];
    if (!normalized)
      throw new InvalidUnitError(unit2);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l2 = orderedUnits.map((unit2) => {
      const val = this.values[unit2];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit2.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts
    };
    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }
    let str = value.toFormat(fmt);
    if (opts.includePrefix) {
      str = "T" + str;
    }
    return str;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit2) {
    return this[Duration.normalizeUnit(unit2)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: locale2, numberingSystem, conversionAccuracy } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem }), opts = { loc };
    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit2) {
    return this.isValid ? this.shiftTo(unit2).get(unit2) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        for (const down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    return clone(this, { values: built }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start2, end) {
  if (!start2 || !start2.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start2) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start2, end) {
    const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start2, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e] = (text2 || "").split("/", 2);
    if (s2 && e) {
      let start2, startIsValid;
      try {
        start2 = DateTime.fromISO(s2, opts);
        startIsValid = start2.isValid;
      } catch (e3) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e3) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start2, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start2, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit2 = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit2]).get(unit2) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit2 = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start2 = this.start.startOf(unit2), end = this.end.startOf(unit2);
    return Math.floor(end.diff(start2, unit2).get(unit2)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit2) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit2) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: start2, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start2 || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort(), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a2, b) => a2.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start2 = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b) => a2.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start2 = i.time;
      } else {
        if (start2 && +start2 !== +i.time) {
          results.push(Interval.fromDateTimes(start2, i.time));
        }
        start2 = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit2, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit2, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale: locale2 = null } = {}) {
    return Locale.create(locale2).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale: locale2 = null } = {}) {
    return Locale.create(locale2, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a2, b) => b.year - a2.year],
    ["quarters", (a2, b) => b.quarter - a2.quarter],
    ["months", (a2, b) => b.month - a2.month + (b.year - a2.year) * 12],
    [
      "weeks",
      (a2, b) => {
        const days = dayDiff(a2, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  let lowestOrder, highWater;
  for (const [unit2, differ] of differs) {
    if (units.indexOf(unit2) >= 0) {
      lowestOrder = unit2;
      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit2]: delta });
      if (highWater > later) {
        cursor = cursor.plus({ [unit2]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }
      results[unit2] = delta;
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min3, max4] = numberingSystemsUTF16[key];
          if (code >= min3 && code <= max4) {
            value += code - min3;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m2]) => signedOffset(h, m2), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one2 = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short", false), 0);
      case "GG":
        return oneOf(loc.eras("long", false), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true, false), 1);
      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false, false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one2);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one2);
      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      default:
        return literal(t);
    }
  };
  const unit2 = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit2.token = token;
  return unit2;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};
function tokenForPart(part, locale2, formatOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    return {
      literal: true,
      val: value
    };
  }
  const style = formatOpts[type2];
  let val = partTypeStyleToTokenVal[type2];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re2 = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re2}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale2) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  if (!formatOpts) {
    return token;
  }
  const formatter = Formatter.create(locale2, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  const tokens = parts.map((p) => tokenForPart(p, locale2, formatOpts));
  if (tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale2) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale2)));
}
function explainFromTokens(locale2, input, format2) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format2), locale2), units = tokens.map((t) => unitForToken(t, locale2)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale2, input, format2) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale2, input, format2);
  return [result, zone, specificOffset, invalidReason];
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit2, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit2}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal2) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal2), day = ordinal2 - table[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal2 = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal2 - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal2 = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal2 < 1) {
    year = weekYear - 1;
    ordinal2 += daysInYear(year);
  } else if (ordinal2 > yearInDays) {
    year = weekYear + 1;
    ordinal2 -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal2);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal2 = computeOrdinal(year, month, day);
  return { year, ordinal: ordinal2, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal: ordinal2 } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal2);
  return { year, month, day, ...timeObject(ordinalData) };
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c3);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format2, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format2}`)
    );
  }
}
function toTechFormat(dt, format2, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format2) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c3 = "";
  if (longFormat && o.c.year >= 0)
    c3 += "+";
  c3 += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c3 += "-";
    c3 += padStart(o.c.month);
    c3 += "-";
    c3 += padStart(o.c.day);
  } else {
    c3 += padStart(o.c.month);
    c3 += padStart(o.c.day);
  }
  return c3;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c3 = padStart(o.c.hour);
  if (extended) {
    c3 += ":";
    c3 += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c3 += ":";
    }
  } else {
    c3 += padStart(o.c.minute);
  }
  if (o.c.second !== 0 || !suppressSeconds) {
    c3 += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c3 += ".";
      c3 += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c3 += "Z";
    } else if (o.o < 0) {
      c3 += "-";
      c3 += padStart(Math.trunc(-o.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(-o.o % 60));
    } else {
      c3 += "+";
      c3 += padStart(Math.trunc(o.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c3 += "[" + o.zone.ianaName + "]";
  }
  return c3;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit2) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit2.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit2);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start2, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format2 = (c3, unit2) => {
    c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c3, unit2);
  }, differ = (unit2) => {
    if (opts.calendary) {
      if (!end.hasSame(start2, unit2)) {
        return end.startOf(unit2).diff(start2.startOf(unit2), unit2).get(unit2);
      } else
        return 0;
    } else {
      return end.diff(start2, unit2).get(unit2);
    }
  };
  if (opts.unit) {
    return format2(differ(opts.unit), opts.unit);
  }
  for (const unit2 of opts.units) {
    const count2 = differ(unit2);
    if (Math.abs(count2) >= 1) {
      return format2(count2, unit2);
    }
  }
  return format2(start2 > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c3 = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c3, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c3 = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
        c3 = invalid ? null : c3;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c3;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit2) {
    return this[unit2];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale: locale2, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale: locale2, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: locale2, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale: locale2, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale2) {
    return this.reconfigure({ locale: locale2 });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit2) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit2);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit2) {
    return this.isValid ? this.plus({ [unit2]: 1 }).startOf(unit2).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: format2 = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format2 === "extended";
    let c3 = toISODate(this, ext);
    c3 += "T";
    c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c3;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: format2 = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format2 === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format: format2 = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c3 = includePrefix ? "T" : "";
    return c3 + toISOTime(
      this,
      format2 === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit2 = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit2).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit2 = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit2, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit2) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit2) <= inputMs && inputMs <= adjustedToZone.endOf(unit2);
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit2 = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit2 = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit: unit2
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options = {}) {
    const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale: locale2,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options = {}) {
    return DateTime.fromFormatExplain(text2, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// src/AlternativeHierarchies/DateNotes.ts
function addDateNotesToGraph(plugin, frontms, mainG) {
  const { settings } = plugin;
  const {
    addDateNotes,
    dateNoteAddMonth,
    dateNoteAddYear,
    dateNoteFormat,
    dateNoteField
  } = settings;
  if (!addDateNotes)
    return;
  const { regex } = DateTime.fromFormatExplain("", dateNoteFormat);
  frontms.forEach((page) => {
    const { file } = page;
    const { day } = file;
    if (!day || !regex.test(getDVBasename(file)))
      return;
    const today = getDVBasename(file);
    const tomorrow = day.plus({ days: 1 });
    const tomStr = tomorrow.toFormat(dateNoteFormat);
    populateMain(
      settings,
      mainG,
      today,
      dateNoteField,
      tomStr,
      9999,
      9999,
      true
    );
  });
}

// src/AlternativeHierarchies/DendronNotes.ts
var getDendronParent = (dendron, splitter) => dendron.split(splitter).slice(0, -1).join(splitter);
function addDendronNotesToGraph(plugin, frontms, mainG) {
  const { settings } = plugin;
  const { addDendronNotes, dendronNoteDelimiter, dendronNoteField } = settings;
  if (!addDendronNotes)
    return;
  for (const frontm of frontms) {
    if (frontm[BC_IGNORE_DENDRON] || frontm[BC_IGNORE])
      continue;
    let curr = getDVBasename(frontm.file);
    let parent = getDendronParent(curr, dendronNoteDelimiter);
    while (parent !== "") {
      const parentFile = frontms.find(
        (fm) => getDVBasename(fm.file) === parent
      );
      if (!parentFile || parentFile[BC_IGNORE_DENDRON] !== true) {
        populateMain(
          settings,
          mainG,
          curr,
          dendronNoteField,
          parent,
          9999,
          9999,
          true
        );
      }
      curr = parent;
      parent = getDendronParent(parent, dendronNoteDelimiter);
    }
  }
}

// src/AlternativeHierarchies/FolderNotes.ts
var import_obsidian6 = require("obsidian");
var getSubsFromFolder = (folder) => {
  const otherNotes = [], subFolders = [];
  folder.children.forEach((tAbstract) => {
    if (tAbstract instanceof import_obsidian6.TFile)
      otherNotes.push(tAbstract);
    else
      subFolders.push(tAbstract);
  });
  return { otherNotes, subFolders };
};
function addFolderNotesToGraph(plugin, folderNotes, frontms, mainG) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  folderNotes.forEach((altFile) => {
    const { file } = altFile;
    const basename = getDVBasename(file);
    const topFolderName = getFolderName(file);
    const topFolder = app.vault.getAbstractFileByPath(topFolderName);
    const targets = frontms.map((ff) => ff.file).filter(
      (other) => getFolderName(other) === topFolderName && other.path !== file.path && !other[BC_IGNORE]
    ).map(getDVBasename);
    const field = altFile[BC_FOLDER_NOTE];
    if (typeof field !== "string" || !fields.includes(field))
      return;
    targets.forEach((target) => {
      const sourceOrder = getSourceOrder(altFile);
      const targetOrder = getTargetOrder(frontms, basename);
      populateMain(
        settings,
        mainG,
        basename,
        field,
        target,
        sourceOrder,
        targetOrder,
        true
      );
    });
    if (altFile[BC_FOLDER_NOTE_SUBFOLDERS]) {
      const subfolderField = altFile[BC_FOLDER_NOTE_SUBFOLDERS];
      if (typeof subfolderField !== "string" || !fields.includes(subfolderField))
        return;
      const { subFolders } = getSubsFromFolder(topFolder);
      subFolders.forEach((subFolder) => {
        subFolder.children.forEach((child) => {
          if (child instanceof import_obsidian6.TFile) {
            const childBasename = getDVBasename(child);
            populateMain(
              settings,
              mainG,
              basename,
              subfolderField,
              childBasename,
              9999,
              9999,
              true
            );
          }
        });
      });
    }
    if (altFile[BC_FOLDER_NOTE_RECURSIVE]) {
      const { subFolders } = getSubsFromFolder(topFolder);
      const folderQueue = [...subFolders];
      let currFolder = folderQueue.shift();
      while (currFolder !== void 0) {
        const { otherNotes, subFolders: subFolders2 } = getSubsFromFolder(currFolder);
        const folderNote = currFolder.name;
        const targets2 = otherNotes.map(getDVBasename);
        const sourceOrder = 9999;
        const targetOrder = 9999;
        const parentFolderNote = currFolder.parent.name;
        populateMain(
          settings,
          mainG,
          parentFolderNote,
          field,
          folderNote,
          sourceOrder,
          targetOrder,
          true
        );
        targets2.forEach((target) => {
          if (target === folderNote)
            return;
          const sourceOrder2 = 9999;
          const targetOrder2 = 9999;
          populateMain(
            settings,
            mainG,
            folderNote,
            field,
            target,
            sourceOrder2,
            targetOrder2,
            true
          );
        });
        folderQueue.push(...subFolders2);
        currFolder = folderQueue.shift();
      }
    }
  });
}

// src/AlternativeHierarchies/HierarchyNotes/HierarchyNotes.ts
async function getHierarchyNoteItems(file) {
  const { listItems } = app.metadataCache.getFileCache(file);
  if (!listItems)
    return [];
  const basename = getDVBasename(file);
  const { hierarchyNoteIsParent } = getSettings();
  const lines = (await app.vault.cachedRead(file)).split("\n");
  const hierarchyNoteItems = [];
  const afterBulletReg = new RegExp(/\s*[+*-]\s(.*$)/);
  const dropWikiLinksReg = new RegExp(/\[\[(.*?)\]\]/);
  const fieldReg = new RegExp(/(.*?)\[\[.*?\]\]/);
  for (const item of listItems) {
    const line = lines[item.position.start.line];
    const afterBulletCurr = afterBulletReg.exec(line)[1];
    const note = dropWikiLinksReg.exec(afterBulletCurr)[1];
    let field = fieldReg.exec(afterBulletCurr)[1].trim() || null;
    const { parent } = item;
    if (parent >= 0) {
      const parentNote = lines[parent];
      const afterBulletParent = afterBulletReg.exec(parentNote)[1];
      const dropWikiParent = dropWikiLinksReg.exec(afterBulletParent)[1];
      hierarchyNoteItems.push({
        note,
        parent: dropWikiParent,
        field
      });
    } else {
      hierarchyNoteItems.push({
        note,
        parent: hierarchyNoteIsParent ? basename : null,
        field
      });
    }
  }
  return hierarchyNoteItems;
}
function addHNsToGraph(settings, hnArr, mainG) {
  const { HNUpField, userHiers } = settings;
  const upFields = getFields(userHiers, "up");
  hnArr.forEach((hnItem, i) => {
    var _a, _b;
    const { note, field, parent } = hnItem;
    const targetField = field != null ? field : HNUpField || upFields[0];
    const dir = (_a = getFieldInfo(userHiers, targetField)) == null ? void 0 : _a.fieldDir;
    const oppDir = getOppDir(dir);
    const oppField = getOppFields(userHiers, targetField, dir)[0];
    if (parent === null) {
      const s2 = note;
      const t = (_b = hnArr[i + 1]) == null ? void 0 : _b.note;
      addNodesIfNot(mainG, [s2, t]);
      addEdgeIfNot(mainG, s2, t, { dir: oppDir, field: oppField });
    } else {
      addNodesIfNot(mainG, [note, parent]);
      if (settings.showUpInJuggl) {
        addEdgeIfNot(mainG, note, parent, {
          dir,
          field: targetField
        });
      }
      addEdgeIfNot(mainG, parent, note, {
        dir: oppDir,
        field: oppField
      });
    }
  });
}

// src/AlternativeHierarchies/JugglLinks.ts
async function getJugglLinks(plugin, files) {
  const { settings, db } = plugin;
  db.start2G("getJugglLinks");
  const { userHiers } = settings;
  const typedLinksArr = await Promise.all(
    files.map(async (file) => {
      var _a, _b;
      const jugglLink = { file, links: [] };
      const links = (_b = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.links) != null ? _b : [];
      const content = links.length ? await app.vault.cachedRead(file) : "";
      const lines = content.split("\n");
      links.forEach((link2) => {
        var _a2, _b2, _c, _d, _e, _f, _g;
        const lineNo = link2.position.start.line;
        const line = lines[lineNo];
        const linksInLine = (_c = (_b2 = (_a2 = line.match(splitLinksRegex)) == null ? void 0 : _a2.map((link3) => link3.slice(2, link3.length - 2))) == null ? void 0 : _b2.map((innerText) => innerText.split("|")[0])) != null ? _c : [];
        const typedLinkPrefix = (_e = (_d = app.plugins.plugins.juggl) == null ? void 0 : _d.settings.typedLinkPrefix) != null ? _e : "-";
        const parsedLinks = parseTypedLink(link2, line, typedLinkPrefix);
        const field = (_g = (_f = parsedLinks == null ? void 0 : parsedLinks.properties) == null ? void 0 : _f.type) != null ? _g : "";
        if (field === "")
          return;
        const { fieldDir } = getFieldInfo(userHiers, field) || {};
        if (!fieldDir)
          return;
        jugglLink.links.push({
          dir: fieldDir,
          field,
          linksInLine
        });
      });
      return jugglLink;
    })
  );
  const allFields = getFields(userHiers);
  const filteredLinks = typedLinksArr.map((jugglLink) => {
    jugglLink.links = jugglLink.links.filter(
      (link2) => allFields.includes(link2.field)
    );
    return jugglLink;
  });
  db.end2G({ filteredLinks });
  return filteredLinks;
}
function addJugglLinksToGraph(settings, jugglLinks, frontms, mainG) {
  jugglLinks.forEach((jugglLink) => {
    const { basename } = jugglLink.file;
    jugglLink.links.forEach((link2) => {
      const { dir, field, linksInLine } = link2;
      if (dir === "")
        return;
      const sourceOrder = getTargetOrder(frontms, basename);
      linksInLine.forEach((linkInLine) => {
        const targetsOrder = getTargetOrder(frontms, linkInLine);
        populateMain(
          settings,
          mainG,
          basename,
          field,
          linkInLine,
          sourceOrder,
          targetsOrder
        );
      });
    });
  });
}

// src/AlternativeHierarchies/LinkNotes.ts
function addLinkNotesToGraph(plugin, eligableAlts, frontms, mainG) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  eligableAlts.forEach((altFile) => {
    var _a, _b, _c, _d;
    const linkNoteFile = altFile.file;
    const linkNoteBasename = getDVBasename(linkNoteFile);
    let field = altFile[BC_LINK_NOTE];
    if (typeof field !== "string" || !fields.includes(field))
      return;
    const links = (_b = (_a = app.metadataCache.getFileCache(linkNoteFile)) == null ? void 0 : _a.links) == null ? void 0 : _b.map((l2) => l2.link.match(/[^#|]+/)[0]);
    const embeds = (_d = (_c = app.metadataCache.getFileCache(linkNoteFile)) == null ? void 0 : _c.embeds) == null ? void 0 : _d.map((l2) => l2.link.match(/[^#|]+/)[0]);
    const targets = [...links != null ? links : [], ...embeds != null ? embeds : []];
    for (const target of targets) {
      const sourceOrder = getSourceOrder(altFile);
      const targetOrder = getTargetOrder(frontms, linkNoteBasename);
      populateMain(
        settings,
        mainG,
        linkNoteBasename,
        field,
        target,
        sourceOrder,
        targetOrder,
        true
      );
    }
  });
}

// src/AlternativeHierarchies/RegexNotes.ts
var import_loglevel7 = __toESM(require_loglevel());
function addRegexNotesToGraph(plugin, eligableAlts, frontms, mainG) {
  const { settings } = plugin;
  const { userHiers, regexNoteField } = settings;
  const fields = getFields(userHiers);
  eligableAlts.forEach((altFile) => {
    const regexNoteFile = altFile.file;
    const regexNoteBasename = getDVBasename(regexNoteFile);
    const regex = strToRegex(altFile[BC_REGEX_NOTE]);
    (0, import_loglevel7.info)({ regex });
    let field = altFile[BC_REGEX_NOTE_FIELD];
    if (typeof field !== "string" || !fields.includes(field))
      field = regexNoteField || fields[0];
    const targets = [];
    frontms.forEach((page) => {
      if (page[BC_IGNORE])
        return;
      const basename = getDVBasename(page.file);
      if (basename !== regexNoteBasename && regex.test(basename))
        targets.push(basename);
    });
    for (const target of targets) {
      const sourceOrder = getSourceOrder(altFile);
      const targetOrder = getTargetOrder(frontms, regexNoteBasename);
      populateMain(
        settings,
        mainG,
        regexNoteBasename,
        field,
        target,
        sourceOrder,
        targetOrder,
        true
      );
    }
  });
}

// src/AlternativeHierarchies/TagNotes.ts
var import_loglevel8 = __toESM(require_loglevel());
var getAllTags = (file, withHash = true) => {
  var _a, _b;
  const { tags, frontmatter } = app.metadataCache.getFileCache(file);
  const allTags = [];
  tags == null ? void 0 : tags.forEach((t) => allTags.push(dropHash(t.tag)));
  [(_a = frontmatter == null ? void 0 : frontmatter.tags) != null ? _a : []].flat().forEach((t) => {
    splitAndTrim(t).forEach((innerT) => allTags.push(dropHash(innerT)));
  });
  [(_b = frontmatter == null ? void 0 : frontmatter.tag) != null ? _b : []].flat().forEach((t) => {
    splitAndTrim(t).forEach((innerT) => allTags.push(dropHash(innerT)));
  });
  return allTags.map((t) => (withHash ? "#" : "") + t.toLowerCase());
};
function addTagNotesToGraph(plugin, eligableAlts, frontms, mainG) {
  const { settings } = plugin;
  const { userHiers, tagNoteField } = settings;
  const fields = getFields(userHiers);
  eligableAlts.forEach((altFile) => {
    var _a;
    const tagNoteFile = altFile.file;
    const tagNoteBasename = getDVBasename(tagNoteFile);
    const tag = addHash(altFile[BC_TAG_NOTE].trim().toLowerCase());
    (0, import_loglevel8.info)({ tag });
    const hasThisTag = (file) => {
      const allTags = getAllTags(file);
      return altFile[BC_TAG_NOTE_EXACT] !== void 0 ? allTags.includes(tag) : allTags.some((t) => t.includes(tag));
    };
    const targets = frontms.map((ff) => ff.file).filter((file) => file.path !== tagNoteFile.path && hasThisTag(file) && !file[BC_IGNORE]).map(getDVBasename);
    (0, import_loglevel8.info)({ targets });
    let field = (_a = altFile[BC_TAG_NOTE_FIELD]) != null ? _a : tagNoteField || fields[0];
    targets.forEach((target) => {
      const sourceOrder = getSourceOrder(altFile);
      const targetOrder = getTargetOrder(frontms, tagNoteBasename);
      populateMain(
        settings,
        mainG,
        tagNoteBasename,
        field,
        target,
        sourceOrder,
        targetOrder,
        true
      );
    });
  });
}

// src/AlternativeHierarchies/TraverseNotes.ts
var import_loglevel9 = __toESM(require_loglevel());
function addTraverseNotesToGraph(plugin, traverseNotes, mainG, obsG) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  traverseNotes.forEach((altFile) => {
    const { file } = altFile;
    const basename = getDVBasename(file);
    const noCycles = removeCycles(obsG, basename);
    let field = altFile[BC_TRAVERSE_NOTE];
    if (typeof field !== "string" || !fields.includes(field))
      return;
    const allPaths = dfsAllPaths(noCycles, basename);
    (0, import_loglevel9.info)(allPaths);
    const reversed = [...allPaths].map((path2) => path2.reverse());
    reversed.forEach((path2) => {
      path2.forEach((node, i) => {
        const next = path2[i + 1];
        if (next === void 0)
          return;
        populateMain(
          settings,
          mainG,
          node,
          field,
          next,
          9999,
          9999,
          true
        );
      });
    });
  });
}

// src/Relations.ts
function addSiblingsFromSameParent(g, settings) {
  const { userHiers, treatCurrNodeAsImpliedSibling } = settings;
  g.forEachNode((currN, a2) => {
    g.forEachOutEdge(currN, (k, currNAttr, s2, parentNode) => {
      var _a;
      if (currNAttr.dir !== "up")
        return;
      const { fieldDir, fieldHier } = getFieldInfo(userHiers, currNAttr.field);
      const field = (_a = fieldHier.same[0]) != null ? _a : fallbackField(currNAttr.field, fieldDir);
      g.forEachOutEdge(parentNode, (k2, a3, s3, impliedSibling) => {
        if (a3.dir !== "down" || !treatCurrNodeAsImpliedSibling && impliedSibling === currN)
          return;
        addEdgeIfNot(g, currN, impliedSibling, {
          dir: "same",
          field,
          implied: BC_I_SIBLING_1
        });
      });
    });
  });
}
function addSiblingsParentIsParent(g) {
  g.forEachNode((currN, a2) => {
    g.forEachOutEdge(currN, (k, currNAttr, s2, sibling) => {
      if (currNAttr.dir !== "same")
        return;
      g.forEachOutEdge(sibling, (k2, a3, s3, parent) => {
        const { dir, field } = a3;
        if (dir !== "up")
          return;
        addEdgeIfNot(g, currN, parent, {
          dir: "up",
          field,
          implied: BC_I_PARENT
        });
      });
    });
  });
}
function addAuntsUncles(g) {
  g.forEachNode((currN, a2) => {
    g.forEachOutEdge(currN, (k, currEAttr, s2, parentNode) => {
      if (currEAttr.dir !== "up")
        return;
      g.forEachOutEdge(parentNode, (k2, a3, s3, uncle) => {
        if (a3.dir !== "same")
          return;
        addEdgeIfNot(g, currN, uncle, {
          dir: "up",
          // Use the starting node's parent field
          field: currEAttr.field,
          implied: BC_I_AUNT
        });
      });
    });
  });
}
function addCousins(g) {
  g.forEachNode((currN, a2) => {
    g.forEachOutEdge(currN, (k, currEAttr, s2, parentNode) => {
      if (currEAttr.dir !== "up")
        return;
      g.forEachOutEdge(parentNode, (k2, parentSiblingAttr, s3, uncle) => {
        if (parentSiblingAttr.dir !== "same")
          return;
        g.forEachOutEdge(uncle, (k3, a3, s4, cousin) => {
          if (a3.dir !== "down" || currN === cousin)
            return;
          addEdgeIfNot(g, currN, cousin, {
            dir: "same",
            field: parentSiblingAttr.field,
            implied: BC_I_COUSIN
          });
        });
      });
    });
  });
}
function addStructuralEquivalenceSiblings(g) {
  g.forEachNode((currN, a2) => {
    g.forEachInEdge(currN, (k, aSis, sis, _) => {
      if (aSis.dir !== "same")
        return;
      g.forEachInEdge(currN, (k2, aBro, bro, _2) => {
        if (aBro.dir !== "same" || sis === bro)
          return;
        if (aBro.field === aSis.field) {
          addEdgeIfNot(g, sis, bro, {
            dir: "same",
            field: aBro.field,
            implied: BC_I_SIBLING_2
          });
        }
      });
    });
  });
}

// src/Views/TrailView.ts
var import_loglevel12 = __toESM(require_loglevel());
var import_obsidian8 = require("obsidian");

// src/Components/NextPrev.svelte
function add_css(target) {
  append_styles(target, "svelte-11g23nm", ".BC-nexts.svelte-11g23nm div.svelte-11g23nm{text-align:right}.BC-nexts.svelte-11g23nm.svelte-11g23nm{border-left:1px solid var(--background-modifier-border)}.BC-prevs.svelte-11g23nm.svelte-11g23nm{border-right:1px solid var(--background-modifier-border)}.BC-NextPrev-Container.svelte-11g23nm.svelte-11g23nm{display:grid;grid-template-columns:1fr 1fr}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i].field;
  child_ctx[9] = list[i].real;
  child_ctx[10] = list[i].to;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i].field;
  child_ctx[9] = list[i].real;
  child_ctx[10] = list[i].to;
  return child_ctx;
}
function create_each_block_1(ctx) {
  let div;
  let strong;
  let t0_value = (
    /*field*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*to*/
    ctx[10] + ""
  );
  let t2;
  let t3;
  let div_class_value;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[4](
        /*to*/
        ctx[10],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[5](
        /*to*/
        ctx[10],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      strong = element("strong");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      attr(div, "class", div_class_value = linkClass(
        /*to*/
        ctx[10],
        /*real*/
        ctx[9]
      ) + " BC-prev svelte-11g23nm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, strong);
      append(strong, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler),
          listen(div, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*prev*/
      2 && t0_value !== (t0_value = /*field*/
      ctx[8] + ""))
        set_data(t0, t0_value);
      if (dirty & /*prev*/
      2 && t2_value !== (t2_value = /*to*/
      ctx[10] + ""))
        set_data(t2, t2_value);
      if (dirty & /*prev*/
      2 && div_class_value !== (div_class_value = linkClass(
        /*to*/
        ctx[10],
        /*real*/
        ctx[9]
      ) + " BC-prev svelte-11g23nm")) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let t0_value = (
    /*to*/
    ctx[10] + ""
  );
  let t0;
  let t1;
  let strong;
  let t2_value = (
    /*field*/
    ctx[8] + ""
  );
  let t2;
  let t3;
  let div_class_value;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[6](
        /*to*/
        ctx[10],
        ...args
      )
    );
  }
  function mouseover_handler_1(...args) {
    return (
      /*mouseover_handler_1*/
      ctx[7](
        /*to*/
        ctx[10],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      strong = element("strong");
      t2 = text(t2_value);
      t3 = space();
      attr(div, "class", div_class_value = linkClass(
        /*to*/
        ctx[10],
        /*real*/
        ctx[9]
      ) + " BC-next svelte-11g23nm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, strong);
      append(strong, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler_1),
          listen(div, "mouseover", mouseover_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*next*/
      1 && t0_value !== (t0_value = /*to*/
      ctx[10] + ""))
        set_data(t0, t0_value);
      if (dirty & /*next*/
      1 && t2_value !== (t2_value = /*field*/
      ctx[8] + ""))
        set_data(t2, t2_value);
      if (dirty & /*next*/
      1 && div_class_value !== (div_class_value = linkClass(
        /*to*/
        ctx[10],
        /*real*/
        ctx[9]
      ) + " BC-next svelte-11g23nm")) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let div2;
  let div0;
  let span0;
  let t;
  let div1;
  let span1;
  let each_value_1 = (
    /*prev*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = (
    /*next*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      div1 = element("div");
      span1 = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "BC-prevs svelte-11g23nm");
      attr(div1, "class", "BC-nexts svelte-11g23nm");
      attr(div2, "class", "BC-NextPrev-Container svelte-11g23nm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(span0, null);
        }
      }
      append(div2, t);
      append(div2, div1);
      append(div1, span1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(span1, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*linkClass, prev, openOrSwitch, hoverPreview, activeLeafView*/
      6) {
        each_value_1 = /*prev*/
        ctx2[1];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(span0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*linkClass, next, openOrSwitch, hoverPreview, activeLeafView*/
      5) {
        each_value = /*next*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  ;
  ;
  let { plugin } = $$props;
  let { next } = $$props;
  let { prev } = $$props;
  const activeLeafView = app.workspace.activeLeaf.view;
  const click_handler = async (to, e) => await openOrSwitch(to, e);
  const mouseover_handler = (to, e) => hoverPreview(e, activeLeafView, to);
  const click_handler_1 = async (to, e) => await openOrSwitch(to, e);
  const mouseover_handler_1 = (to, e) => hoverPreview(e, activeLeafView, to);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("next" in $$props2)
      $$invalidate(0, next = $$props2.next);
    if ("prev" in $$props2)
      $$invalidate(1, prev = $$props2.prev);
  };
  return [
    next,
    prev,
    activeLeafView,
    plugin,
    click_handler,
    mouseover_handler,
    click_handler_1,
    mouseover_handler_1
  ];
}
var NextPrev = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 3, next: 0, prev: 1 }, add_css);
  }
};
var NextPrev_default = NextPrev;

// src/Components/TrailGrid.svelte
function add_css2(target) {
  append_styles(target, "svelte-dgw0hd", "div.BC-grid-wrapper.svelte-dgw0hd.svelte-dgw0hd{position:relative}div.BC-trail-grid.svelte-dgw0hd.svelte-dgw0hd{border:2px solid var(--background-modifier-border);display:grid;align-items:stretch;width:auto;height:auto}.BC-grid-options.svelte-dgw0hd.svelte-dgw0hd{position:absolute;top:0px;right:0px;height:35px;width:32px;border:1px solid var(--background-modifier-border);border-radius:10px;text-align:center;transition:width 0.3s;overflow-wrap:normal;overflow:hidden}div.BC-grid-options.svelte-dgw0hd.svelte-dgw0hd:hover{padding:5px;width:fit-content}div.BC-grid-options.svelte-dgw0hd:hover .BC-grid-options-icon.svelte-dgw0hd{display:none}.BC-grid-options-options.svelte-dgw0hd.svelte-dgw0hd{display:none}div.BC-grid-options.svelte-dgw0hd:hover .BC-grid-options-options.svelte-dgw0hd{display:unset}.BC-depth-button.svelte-dgw0hd.svelte-dgw0hd{padding:3px 5px}div.BC-trail-grid-item.svelte-dgw0hd.svelte-dgw0hd{display:flex;flex-direction:column;border:1px solid var(--background-modifier-border);align-items:center;justify-content:center;padding:2px;font-size:smaller}div.BC-trail-grid-item.BC-filler.svelte-dgw0hd.svelte-dgw0hd{opacity:0.7}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i].value;
  child_ctx[19] = list[i].first;
  child_ctx[20] = list[i].last;
  return child_ctx;
}
function create_each_block_12(ctx) {
  var _a;
  let div1;
  let div0;
  let t0_value = ((_a = getAlt(
    /*value*/
    ctx[18],
    /*plugin*/
    ctx[0]
  )) != null ? _a : dropDendron(
    /*value*/
    ctx[18],
    /*settings*/
    ctx[5]
  )) + "";
  let t0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[10](
        /*value*/
        ctx[18],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[11](
        /*value*/
        ctx[18],
        ...args
      )
    );
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div0, "class", div0_class_value = null_to_empty(linkClass(
        /*value*/
        ctx[18]
      )) + " svelte-dgw0hd");
      attr(div1, "class", div1_class_value = "BC-trail-grid-item " + /*value*/
      (ctx[18] === "" ? "BC-filler" : "") + " svelte-dgw0hd");
      set_style(
        div1,
        "grid-area",
        /*first*/
        ctx[19] + 1 + " / " + /*i*/
        (ctx[17] + 1) + " / " + /*last*/
        (ctx[20] + 2) + " / " + /*i*/
        (ctx[17] + 2)
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      if (!mounted) {
        dispose = [
          listen(div1, "click", click_handler),
          listen(div1, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (dirty & /*allRuns, plugin*/
      17 && t0_value !== (t0_value = ((_a2 = getAlt(
        /*value*/
        ctx[18],
        /*plugin*/
        ctx[0]
      )) != null ? _a2 : dropDendron(
        /*value*/
        ctx[18],
        /*settings*/
        ctx[5]
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*allRuns*/
      16 && div0_class_value !== (div0_class_value = null_to_empty(linkClass(
        /*value*/
        ctx[18]
      )) + " svelte-dgw0hd")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & /*allRuns*/
      16 && div1_class_value !== (div1_class_value = "BC-trail-grid-item " + /*value*/
      (ctx[18] === "" ? "BC-filler" : "") + " svelte-dgw0hd")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*allRuns*/
      16) {
        set_style(
          div1,
          "grid-area",
          /*first*/
          ctx[19] + 1 + " / " + /*i*/
          (ctx[17] + 1) + " / " + /*last*/
          (ctx[20] + 2) + " / " + /*i*/
          (ctx[17] + 2)
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block2(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*allRuns*/
    ctx[4][
      /*i*/
      ctx[17]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*allRuns, openOrSwitch, hoverPreview, activeLeafView, linkClass, getAlt, plugin, dropDendron, settings*/
      113) {
        each_value_1 = /*allRuns*/
        ctx2[4][
          /*i*/
          ctx2[17]
        ];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment2(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let span3;
  let span0;
  let t2;
  let span2;
  let button0;
  let t3;
  let button0_disabled_value;
  let t4;
  let span1;
  let t5;
  let t6;
  let button1;
  let t7;
  let button1_disabled_value;
  let mounted;
  let dispose;
  let each_value = (
    /*transposedTrails*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      span3 = element("span");
      span0 = element("span");
      span0.textContent = "\u2699\uFE0F";
      t2 = space();
      span2 = element("span");
      button0 = element("button");
      t3 = text("-");
      t4 = space();
      span1 = element("span");
      t5 = text(
        /*depth*/
        ctx[1]
      );
      t6 = space();
      button1 = element("button");
      t7 = text("+");
      attr(div0, "class", "BC-trail-grid svelte-dgw0hd");
      set_style(div0, "grid-template-columns", "1fr ".repeat(
        /*transposedTrails*/
        ctx[3].length
      ));
      set_style(div0, "grid-template-rows", "1fr ".repeat(
        /*slicedTrails*/
        ctx[2].length
      ));
      attr(span0, "class", "BC-grid-options-icon svelte-dgw0hd");
      attr(button0, "class", "BC-depth-button svelte-dgw0hd");
      button0.disabled = button0_disabled_value = /*depth*/
      ctx[1] === 1;
      attr(span1, "class", "tree-item-flair");
      attr(button1, "class", "BC-depth-button svelte-dgw0hd");
      button1.disabled = button1_disabled_value = /*depth*/
      ctx[1] === /*maxLength*/
      ctx[7];
      attr(span2, "class", "BC-grid-options-options svelte-dgw0hd");
      attr(div1, "class", "BC-grid-options svelte-dgw0hd");
      attr(div2, "class", "BC-grid-wrapper svelte-dgw0hd");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      append(div1, span3);
      append(span3, span0);
      append(span3, t2);
      append(span3, span2);
      append(span2, button0);
      append(button0, t3);
      append(span2, t4);
      append(span2, span1);
      append(span1, t5);
      append(span2, t6);
      append(span2, button1);
      append(button1, t7);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_1*/
            ctx[12]
          ),
          listen(
            button1,
            "click",
            /*click_handler_2*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*allRuns, openOrSwitch, hoverPreview, activeLeafView, linkClass, getAlt, plugin, dropDendron, settings, transposedTrails*/
      121) {
        each_value = /*transposedTrails*/
        ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*transposedTrails*/
      8) {
        set_style(div0, "grid-template-columns", "1fr ".repeat(
          /*transposedTrails*/
          ctx2[3].length
        ));
      }
      if (dirty & /*slicedTrails*/
      4) {
        set_style(div0, "grid-template-rows", "1fr ".repeat(
          /*slicedTrails*/
          ctx2[2].length
        ));
      }
      if (dirty & /*depth*/
      2 && button0_disabled_value !== (button0_disabled_value = /*depth*/
      ctx2[1] === 1)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & /*depth*/
      2)
        set_data(
          t5,
          /*depth*/
          ctx2[1]
        );
      if (dirty & /*depth*/
      2 && button1_disabled_value !== (button1_disabled_value = /*depth*/
      ctx2[1] === /*maxLength*/
      ctx2[7])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let paddedTrails;
  let transposedTrails;
  let allRuns;
  ;
  let { sortedTrails } = $$props;
  let { plugin } = $$props;
  const { settings } = plugin;
  const { gridDefaultDepth } = settings;
  const activeLeafView = app.workspace.activeLeaf.view;
  const maxLength = sortedTrails.last().length;
  let depth = Math.min(maxLength, gridDefaultDepth);
  let slicedTrails = sortedTrails;
  const click_handler = async (value, e) => await openOrSwitch(value, e);
  const mouseover_handler = (value, e) => hoverPreview(e, activeLeafView, value);
  const click_handler_1 = () => $$invalidate(1, depth -= 1);
  const click_handler_2 = () => $$invalidate(1, depth += 1);
  $$self.$$set = ($$props2) => {
    if ("sortedTrails" in $$props2)
      $$invalidate(8, sortedTrails = $$props2.sortedTrails);
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sortedTrails, depth, slicedTrails*/
    262) {
      $: {
        $$invalidate(2, slicedTrails = []);
        sortedTrails.forEach((trail) => {
          const slice2 = trail.slice(maxLength - depth);
          if (slice2.length)
            slicedTrails.push(slice2);
        });
      }
    }
    if ($$self.$$.dirty & /*slicedTrails, depth*/
    6) {
      $:
        $$invalidate(9, paddedTrails = slicedTrails.map((trail) => padArray(trail, depth)));
    }
    if ($$self.$$.dirty & /*paddedTrails*/
    512) {
      $:
        $$invalidate(3, transposedTrails = transpose(paddedTrails));
    }
    if ($$self.$$.dirty & /*transposedTrails*/
    8) {
      $:
        $$invalidate(4, allRuns = transposedTrails.map(runs));
    }
  };
  return [
    plugin,
    depth,
    slicedTrails,
    transposedTrails,
    allRuns,
    settings,
    activeLeafView,
    maxLength,
    sortedTrails,
    paddedTrails,
    click_handler,
    mouseover_handler,
    click_handler_1,
    click_handler_2
  ];
}
var TrailGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { sortedTrails: 8, plugin: 0 }, add_css2);
  }
};
var TrailGrid_default = TrailGrid;

// src/Components/TrailPath.svelte
function add_css3(target) {
  append_styles(target, "svelte-3c1frp", "span.BC-trail-path-container.svelte-3c1frp{display:flex;justify-content:space-between}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[18] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*trail*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*trailSeperator, trailsToShow, openOrSwitch, hoverPreview, view, getAlt, plugin, dropDendron, settings*/
      186) {
        each_value_1 = /*trail*/
        ctx2[13];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${/*noPathMessage*/
      ctx[6]}`;
      attr(span, "class", "BC-empty-trail");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${" " + /*trailSeperator*/
      ctx[7] + " "}`;
      attr(span, "class", "BC-trail-sep");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_13(ctx) {
  var _a;
  let span;
  let t0_value = ((_a = getAlt(
    /*crumb*/
    ctx[16],
    /*plugin*/
    ctx[1]
  )) != null ? _a : dropDendron(
    /*crumb*/
    ctx[16],
    /*settings*/
    ctx[4]
  )) + "";
  let t0;
  let t1;
  let if_block_anchor;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[8](
        /*crumb*/
        ctx[16],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[9](
        /*crumb*/
        ctx[16],
        ...args
      )
    );
  }
  let if_block = (
    /*i*/
    ctx[18] < /*trail*/
    ctx[13].length - 1 && create_if_block_2(ctx)
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "internal-link BC-Link");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler),
          listen(span, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (dirty & /*trailsToShow, plugin*/
      10 && t0_value !== (t0_value = ((_a2 = getAlt(
        /*crumb*/
        ctx[16],
        /*plugin*/
        ctx[1]
      )) != null ? _a2 : dropDendron(
        /*crumb*/
        ctx[16],
        /*settings*/
        ctx[4]
      )) + ""))
        set_data(t0, t0_value);
      if (
        /*i*/
        ctx[18] < /*trail*/
        ctx[13].length - 1
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block3(ctx) {
  let div;
  let t;
  function select_block_type(ctx2, dirty) {
    if (!/*trail*/
    ctx2[13].length)
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_if_block(ctx) {
  let div;
  let button;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t = text(
        /*trail_length*/
        ctx[2]
      );
      attr(button, "class", "button-div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t);
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler_1*/
            ctx[10]
          ),
          listen(
            button,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*trail_length*/
      4)
        set_data(
          t,
          /*trail_length*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let span;
  let div;
  let t;
  let each_value = (
    /*trailsToShow*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  let if_block = (
    /*sortedTrails*/
    ctx[0].length > 1 && create_if_block(ctx)
  );
  return {
    c() {
      span = element("span");
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "trails-div");
      attr(span, "class", "BC-trail-path-container svelte-3c1frp");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(span, t);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*noPathMessage, trailsToShow, trailSeperator, openOrSwitch, hoverPreview, view, getAlt, plugin, dropDendron, settings*/
      250) {
        each_value = /*trailsToShow*/
        ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*sortedTrails*/
        ctx2[0].length > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let trailsToShow;
  ;
  let { sortedTrails } = $$props;
  let { plugin } = $$props;
  const { settings } = plugin;
  const { view } = app.workspace.activeLeaf;
  let { showAll, noPathMessage, trailSeperator } = settings;
  let trail_length = showAll;
  const click_handler = async (crumb, e) => await openOrSwitch(crumb, e);
  const mouseover_handler = (crumb, e) => hoverPreview(e, view, crumb);
  const click_handler_1 = () => $$invalidate(2, trail_length = getTrailLength(trail_length));
  const contextmenu_handler = (e) => {
    e.preventDefault();
    $$invalidate(2, trail_length = getTrailLength(trail_length, -1));
  };
  $$self.$$set = ($$props2) => {
    if ("sortedTrails" in $$props2)
      $$invalidate(0, sortedTrails = $$props2.sortedTrails);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*trail_length, sortedTrails*/
    5) {
      $:
        $$invalidate(3, trailsToShow = trail_length == "All" ? sortedTrails : trail_length == "Shortest" ? [sortedTrails[0]] : [sortedTrails.last()]);
    }
  };
  return [
    sortedTrails,
    plugin,
    trail_length,
    trailsToShow,
    settings,
    view,
    noPathMessage,
    trailSeperator,
    click_handler,
    mouseover_handler,
    click_handler_1,
    contextmenu_handler
  ];
}
var TrailPath = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { sortedTrails: 0, plugin: 1 }, add_css3);
  }
};
var TrailPath_default = TrailPath;

// src/Visualisations/Juggl.ts
var import_loglevel11 = __toESM(require_loglevel());
var import_obsidian7 = require("obsidian");

// src/Commands/CreateIndex.ts
var import_lodash = __toESM(require_lodash());
var import_loglevel10 = __toESM(require_loglevel());
function addAliasesToIndex(plugin, index2) {
  var _a, _b, _c, _d;
  const { aliasesInIndex } = plugin.settings;
  const lines = index2.slice().split("\n");
  if (aliasesInIndex) {
    for (let line of lines) {
      const [indent, ...content] = line.split("- ");
      const note = content.join("- ");
      if (!note)
        continue;
      const currFile = app.metadataCache.getFirstLinkpathDest(note, "");
      if (currFile !== null) {
        const cache = app.metadataCache.getFileCache(currFile);
        const alias = (_b = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.alias) != null ? _b : [];
        const aliases = (_d = (_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c.aliases) != null ? _d : [];
        const allAliases = [...[alias].flat(3), ...[aliases].flat(3)];
        if (allAliases.length) {
          line += ` (${allAliases.join(", ")})`;
        }
      }
    }
  }
  return lines.join("\n");
}
function createIndex(allPaths, asWikilinks, indent = "  ") {
  let index2 = "";
  const copy3 = (0, import_lodash.cloneDeep)(allPaths);
  const reversed = copy3.map((path2) => path2.reverse());
  reversed.forEach((path2) => path2.shift());
  const realIndent = indent === "\\t" ? "	" : indent;
  const visited = {};
  reversed.forEach((path2) => {
    for (let depth = 0; depth < path2.length; depth++) {
      const currNode = path2[depth];
      if (visited.hasOwnProperty(currNode) && visited[currNode].includes(depth))
        continue;
      else {
        index2 += `${realIndent.repeat(depth)}- ${asWikilinks ? makeWiki(currNode) : currNode}
`;
        if (!visited.hasOwnProperty(currNode))
          visited[currNode] = [];
        visited[currNode].push(depth);
      }
    }
  });
  return index2;
}
async function copyLocalIndex(plugin) {
  const { settings, closedG } = plugin;
  const { wikilinkIndex, createIndexIndent } = settings;
  const { basename } = getCurrFile();
  const onlyDowns = getSubInDirs(closedG, "down");
  const allPaths = dfsAllPaths(onlyDowns, basename);
  const index2 = addAliasesToIndex(plugin, createIndex(allPaths, wikilinkIndex, createIndexIndent));
  (0, import_loglevel10.info)({ index: index2 });
  await copy(index2);
}
async function copyGlobalIndex(plugin) {
  const { settings, closedG } = plugin;
  const { wikilinkIndex, createIndexIndent } = settings;
  const onlyDowns = getSubInDirs(closedG, "down");
  const onlyUps = getSubInDirs(closedG, "up");
  const sinks = getSinks(onlyUps);
  let globalIndex = "";
  sinks.forEach((terminal) => {
    globalIndex += terminal + "\n";
    const allPaths = dfsAllPaths(onlyDowns, terminal);
    globalIndex += addAliasesToIndex(plugin, createIndex(allPaths, wikilinkIndex, createIndexIndent)) + "\n";
  });
  (0, import_loglevel10.info)({ globalIndex });
  await copy(globalIndex);
}
var indexToLinePairs = (index2, flat = false) => index2.split("\n").map((line) => {
  const [indent, ...content] = line.split("- ");
  return [flat ? "" : indent, content.join("- ")];
}).filter((pair) => pair[1] !== "");

// src/Components/JugglButton.svelte
function create_fragment4(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(
        /*renderedIcon*/
        ctx[3]
      );
      attr(button, "type", "button");
      attr(button, "class", "juggl-button");
      attr(
        button,
        "aria-label",
        /*title*/
        ctx[2]
      );
      button.disabled = /*disabled*/
      ctx[1];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*onClick*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*renderedIcon*/
      8)
        set_data(
          t,
          /*renderedIcon*/
          ctx[3]
        );
      if (dirty & /*title*/
      4) {
        attr(
          button,
          "aria-label",
          /*title*/
          ctx[2]
        );
      }
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx[1];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let renderedIcon;
  let { icon } = $$props;
  let { onClick } = $$props;
  let { disabled = false } = $$props;
  let { title = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(4, icon = $$props2.icon);
    if ("onClick" in $$props2)
      $$invalidate(0, onClick = $$props2.onClick);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*icon*/
    16) {
      $:
        $$invalidate(3, renderedIcon = icon);
    }
  };
  return [onClick, disabled, title, renderedIcon, icon];
}
var JugglButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      icon: 4,
      onClick: 0,
      disabled: 1,
      title: 2
    });
  }
};
var JugglButton_default = JugglButton;

// src/Components/JugglDepth.svelte
function create_if_block2(ctx) {
  let div;
  let jugglbutton0;
  let t0;
  let jugglbutton1;
  let t1;
  let jugglbutton2;
  let current;
  jugglbutton0 = new JugglButton_default({
    props: {
      icon: "-",
      disabled: (
        /*depth*/
        ctx[3] <= 0
      ),
      onClick: (
        /*func*/
        ctx[4]
      )
    }
  });
  jugglbutton1 = new JugglButton_default({
    props: {
      icon: (
        /*depth*/
        ctx[3]
      ),
      disabled: true,
      onClick: null
    }
  });
  jugglbutton2 = new JugglButton_default({
    props: {
      icon: "+",
      disabled: (
        /*depth*/
        ctx[3] >= /*maxDepth*/
        ctx[1]
      ),
      onClick: (
        /*func_1*/
        ctx[5]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(jugglbutton0.$$.fragment);
      t0 = space();
      create_component(jugglbutton1.$$.fragment);
      t1 = space();
      create_component(jugglbutton2.$$.fragment);
      attr(div, "class", "cy-toolbar-section");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(jugglbutton0, div, null);
      append(div, t0);
      mount_component(jugglbutton1, div, null);
      append(div, t1);
      mount_component(jugglbutton2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const jugglbutton0_changes = {};
      if (dirty & /*depth*/
      8)
        jugglbutton0_changes.disabled = /*depth*/
        ctx2[3] <= 0;
      if (dirty & /*depth, onUpdateDepth*/
      12)
        jugglbutton0_changes.onClick = /*func*/
        ctx2[4];
      jugglbutton0.$set(jugglbutton0_changes);
      const jugglbutton1_changes = {};
      if (dirty & /*depth*/
      8)
        jugglbutton1_changes.icon = /*depth*/
        ctx2[3];
      jugglbutton1.$set(jugglbutton1_changes);
      const jugglbutton2_changes = {};
      if (dirty & /*depth, maxDepth*/
      10)
        jugglbutton2_changes.disabled = /*depth*/
        ctx2[3] >= /*maxDepth*/
        ctx2[1];
      if (dirty & /*depth, onUpdateDepth*/
      12)
        jugglbutton2_changes.onClick = /*func_1*/
        ctx2[5];
      jugglbutton2.$set(jugglbutton2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(jugglbutton0.$$.fragment, local);
      transition_in(jugglbutton1.$$.fragment, local);
      transition_in(jugglbutton2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jugglbutton0.$$.fragment, local);
      transition_out(jugglbutton1.$$.fragment, local);
      transition_out(jugglbutton2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(jugglbutton0);
      destroy_component(jugglbutton1);
      destroy_component(jugglbutton2);
    }
  };
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visible*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*visible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { visible = true } = $$props;
  let { maxDepth } = $$props;
  let { onUpdateDepth } = $$props;
  let depth = maxDepth;
  const func = () => {
    $$invalidate(3, depth -= 1);
    onUpdateDepth(depth);
  };
  const func_12 = () => {
    $$invalidate(3, depth += 1);
    onUpdateDepth(depth);
  };
  $$self.$$set = ($$props2) => {
    if ("visible" in $$props2)
      $$invalidate(0, visible = $$props2.visible);
    if ("maxDepth" in $$props2)
      $$invalidate(1, maxDepth = $$props2.maxDepth);
    if ("onUpdateDepth" in $$props2)
      $$invalidate(2, onUpdateDepth = $$props2.onUpdateDepth);
  };
  return [visible, maxDepth, onUpdateDepth, depth, func, func_12];
}
var JugglDepth = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      visible: 0,
      maxDepth: 1,
      onUpdateDepth: 2
    });
  }
};
var JugglDepth_default = JugglDepth;

// src/Visualisations/Juggl.ts
var STORE_ID = "core";
var BCStoreEvents = class extends import_obsidian7.Events {
};
var BCStore = class extends import_obsidian7.Component {
  constructor(graph, metadata, depthMap) {
    super();
    this.graph = graph;
    this.cache = metadata;
    this.depthMap = depthMap;
  }
  asString(node) {
    const id2 = VizId.fromNode(node);
    return id2.id.slice(0, -3);
  }
  getFile(nodeId) {
    return this.cache.getFirstLinkpathDest(nodeId.id, "");
  }
  async connectNodes(allNodes, newNodes, graph) {
    const edges = [];
    const nodesListS = new Set(
      allNodes.map((node) => this.asString(node)).filter((s2) => s2)
    );
    newNodes.forEach((node) => {
      const name = this.asString(node);
      if (!this.graph.hasNode(name)) {
        return;
      }
      this.graph.forEachOutEdge(
        this.asString(node),
        (key, attr2, source, target) => {
          if (nodesListS.has(target)) {
            edges.push({
              data: {
                id: `BC:${source}->${target}`,
                source: VizId.toId(source, STORE_ID) + ".md",
                target: VizId.toId(target, STORE_ID) + ".md",
                type: attr2.field,
                dir: attr2.dir
              },
              classes: `type-${attr2.field} dir-${attr2.dir} breadcrumbs$`
            });
          }
        }
      );
    });
    return Promise.resolve(edges);
  }
  getEvents(view) {
    return new BCStoreEvents();
  }
  async getNeighbourhood(nodeIds, view) {
    const new_nodes = [];
    for (const nodeId of nodeIds) {
      const name = nodeId.id.slice(0, -3);
      if (!this.graph.hasNode(name)) {
        continue;
      }
      for (const new_node of this.graph.neighbors(name)) {
        new_nodes.push(
          await this.get(new VizId(new_node + ".md", STORE_ID), view)
        );
      }
    }
    return new_nodes;
  }
  refreshNode(id2, view) {
    return;
  }
  storeId() {
    return STORE_ID;
  }
  get(nodeId, view) {
    const file = this.getFile(nodeId);
    let depth = 0;
    if (this.depthMap && nodeId.id in this.depthMap) {
      depth = this.depthMap[nodeId.id];
    }
    if (file === null) {
      const dangling = nodeDangling(nodeId.id);
      dangling.data.depth = depth;
      return Promise.resolve(dangling);
    }
    const cache = this.cache.getFileCache(file);
    if (cache === null) {
      (0, import_loglevel11.info)("returning empty cache", nodeId);
      return Promise.resolve(nodeDangling(nodeId.id));
    }
    return nodeFromFile(file, view.plugin, view.settings, nodeId.toId()).then(
      (node) => {
        node.data.depth = depth;
        return node;
      }
    );
  }
};
function createJuggl(plugin, target, initialNodes, args, depthMap = null) {
  try {
    const jugglPlugin = getPlugin(app);
    if (!jugglPlugin) {
      return;
    }
    for (let key in JUGGL_CB_DEFAULTS) {
      if (key in args && args[key] === void 0)
        args[key] = JUGGL_CB_DEFAULTS[key];
    }
    const bcStore = new BCStore(
      plugin.mainG,
      app.metadataCache,
      depthMap
    );
    const stores = {
      coreStore: bcStore,
      dataStores: [bcStore]
    };
    const juggl = jugglPlugin.createJuggl(target, args, stores, initialNodes);
    plugin.addChild(juggl);
    (0, import_loglevel11.info)({ juggl });
    return juggl;
  } catch (error6) {
    (0, import_loglevel11.warn)({ error: error6 });
    return null;
  }
}
function zoomToSource(juggl, source) {
  if (!juggl) {
    return;
  }
  juggl.on("vizReady", (viz) => {
    viz.one("layoutstop", (e) => {
      const viz2 = e.cy;
      const node = viz2.$id(VizId.toId(source + ".md", STORE_ID));
      viz2.animate({
        center: {
          eles: node
        },
        duration: 250,
        queue: false,
        zoom: 1.7
      });
    });
  });
}
function zoomToGraph(juggl) {
  juggl.on("vizReady", (viz) => {
    viz.fit(viz.nodes());
  });
}
function createDepthMap(paths, source, offset2 = 0) {
  let depthMap = {};
  depthMap[source + ".md"] = 0;
  paths.forEach((path2) => {
    for (let i = 0; i < path2.length; i++) {
      const name = path2[i] + ".md";
      const depth = path2.length - i - 1 + offset2;
      if (name in depthMap) {
        depthMap[name] = Math.min(depthMap[name], depth);
      } else {
        depthMap[name] = depth;
      }
    }
  });
  return depthMap;
}
function updateDepth(juggl, depth) {
  juggl.viz.$(`[depth>${depth}]`).addClass("filtered");
  juggl.viz.$(`[depth<=${depth}]`).removeClass("filtered");
}
function createJugglTrail(plugin, target, paths, source, args) {
  const toolbarDiv = document.createElement("div");
  toolbarDiv.addClass("cy-toolbar");
  target.appendChild(toolbarDiv);
  const sectDiv = document.createElement("div");
  sectDiv.addClass("cy-toolbar-section");
  toolbarDiv.appendChild(sectDiv);
  const amtChildren = target.children.length;
  let jugglUp = null;
  let jugglDown = null;
  new JugglButton_default({
    target: sectDiv,
    props: {
      icon: "\u2191",
      onClick: () => {
        if (jugglUp) {
          target.children[amtChildren].classList.remove("juggl-hide");
          depthUp.$set({ visible: true });
        }
        if (jugglDown) {
          target.children[amtChildren + 1].classList.add("juggl-hide");
          depthDown.$set({ visible: false });
        }
      },
      disabled: false,
      title: "Show up graph"
    }
  });
  new JugglButton_default({
    target: sectDiv,
    props: {
      icon: "\u2193",
      onClick: () => {
        if (jugglDown) {
          target.children[amtChildren + 1].classList.remove("juggl-hide");
          depthUp.$set({ visible: false });
          if (jugglUp) {
            target.children[amtChildren].classList.add("juggl-hide");
            depthDown.$set({ visible: true });
          }
          return;
        }
        const sub = getSubInDirs(plugin.mainG, "down", "up");
        const closed = getReflexiveClosure(sub, plugin.settings.userHiers);
        const subClosed = getSubInDirs(closed, "down");
        const { createIndexIndent } = plugin.settings;
        const allPaths = dfsAllPaths(subClosed, source);
        const index2 = createIndex(allPaths, false, createIndexIndent);
        const lines = index2.split("\n").map((line) => {
          const [indent, ...content] = line.split("- ");
          return content.join("- ");
        }).filter((pair) => pair);
        let depthMapDown = createDepthMap(allPaths, source);
        const maxDepthDown = Math.max(...Object.values(depthMapDown));
        depthDown = new JugglDepth_default({
          target: toolbarDiv,
          props: {
            maxDepth: maxDepthDown,
            onUpdateDepth: (d) => {
              updateDepth(jugglDown, d);
            }
          }
        });
        let nodesS = new Set(lines);
        nodesS.add(source);
        const nodes2 = Array.from(nodesS).map((s2) => s2 + ".md");
        const argsDown = Object.assign({}, args);
        const layout2 = plugin.settings.jugglLayout;
        if (layout2 === "hierarchy") {
          argsDown.layout = {
            // @ts-ignore
            name: "dagre",
            animate: false,
            ranker: (graph) => {
              Object.keys(graph._nodes).forEach((id2) => {
                const name = VizId.fromId(id2).id;
                if (name in depthMapDown) {
                  graph._nodes[id2].rank = depthMapDown[name] + 1;
                } else {
                  graph._nodes[id2].rank = 0;
                }
              });
            }
          };
        } else {
          argsDown.layout = layout2;
        }
        const isFdgd2 = layout2 === "cola" || layout2 === "d3-force";
        if (isFdgd2) {
          argsDown.fdgdLayout = layout2;
          argsDown.layout = "force-directed";
        } else {
          argsDown.autoZoom = true;
          argsDown.animateLayout = false;
        }
        jugglDown = createJuggl(plugin, target, nodes2, argsDown, depthMapDown);
        if (isFdgd2) {
          zoomToSource(jugglDown, source);
        } else {
          zoomToGraph(jugglDown);
        }
        if (jugglUp) {
          target.children[amtChildren].addClass("juggl-hide");
          depthUp.$set({ visible: false });
        }
      },
      disabled: false,
      title: "Show down graph"
    }
  });
  const depthMapUp = createDepthMap(paths, source, 1);
  const maxDepthUp = Math.max(...Object.values(depthMapUp));
  let depthDown;
  const depthUp = new JugglDepth_default({
    target: toolbarDiv,
    props: {
      maxDepth: maxDepthUp,
      onUpdateDepth: (d) => {
        updateDepth(jugglUp, d);
      }
    }
  });
  let nodes = Array.from(
    new Set(paths.reduce((prev, curr) => prev.concat(curr), []))
  );
  nodes.push(source);
  nodes = nodes.map((s2) => s2 + ".md");
  const argsUp = Object.assign({}, args);
  const layout = plugin.settings.jugglLayout;
  if (layout === "hierarchy") {
    argsUp.layout = {
      // @ts-ignore
      name: "dagre",
      animate: false,
      ranker: (graph) => {
        Object.keys(graph._nodes).forEach((id2) => {
          const name = VizId.fromId(id2).id;
          if (name in depthMapUp) {
            graph._nodes[id2].rank = maxDepthUp - depthMapUp[name] + 1;
          } else {
            graph._nodes[id2].rank = maxDepthUp + 2;
          }
        });
      }
    };
  } else {
    argsUp.layout = layout;
  }
  const isFdgd = layout === "cola" || layout === "d3-force";
  if (isFdgd) {
    argsUp.fdgdLayout = layout;
    argsUp.layout = "force-directed";
  } else {
    argsUp.autoZoom = true;
    argsUp.animateLayout = false;
  }
  jugglUp = createJuggl(plugin, target, nodes, argsUp, depthMapUp);
  if (isFdgd) {
    zoomToSource(jugglUp, source);
  } else {
    zoomToGraph(jugglUp);
  }
}

// src/Views/TrailView.ts
function getLimitedTrailSub(plugin) {
  const { settings, mainG, closedG } = plugin;
  const { limitTrailCheckboxes, userHiers } = settings;
  if (getFields(userHiers).every((field) => limitTrailCheckboxes.includes(field))) {
    return getSubInDirs(closedG, "up");
  } else {
    const oppFields = limitTrailCheckboxes.map((field) => {
      var _a;
      return (_a = getOppFields(userHiers, field, "up")) == null ? void 0 : _a[0];
    }).filter((field) => field !== void 0);
    const subGraph = getSubForFields(mainG, [
      ...limitTrailCheckboxes,
      ...oppFields
    ]);
    const closed = getReflexiveClosure(subGraph, userHiers);
    return getSubInDirs(closed, "up");
  }
}
function getBreadcrumbs(settings, g, currFile) {
  const { basename, extension } = currFile;
  if (extension !== "md")
    return null;
  const allTrails = bfsAllPaths(g, basename);
  let filteredTrails = [...allTrails];
  const { indexNotes, showAllPathsIfNoneToIndexNote } = settings;
  if (
    // Works for `undefined` and `""`
    indexNotes[0] && filteredTrails.length
  ) {
    filteredTrails = filteredTrails.filter(
      (trail) => indexNotes.includes(trail[0])
    );
    if (filteredTrails.length === 0 && showAllPathsIfNoneToIndexNote)
      filteredTrails = [...allTrails];
  }
  const sortedTrails = filteredTrails.filter((trail) => trail.length > 0).sort((a2, b) => a2.length - b.length);
  return sortedTrails;
}
function getNextNPrev(plugin, currNode) {
  const { mainG } = plugin;
  const { userHiers } = plugin.settings;
  if (!mainG)
    return null;
  const nextNPrev = blankRealNImplied();
  mainG.forEachEdge(currNode, (k, a2, s2, t) => {
    const { dir, field, implied } = a2;
    if (dir !== "next" && dir !== "prev")
      return;
    if (s2 === currNode) {
      nextNPrev[dir].reals.push({ field, to: t, implied });
    } else {
      const oppField = getOppFields(userHiers, field, dir)[0];
      nextNPrev[getOppDir(dir)].implieds.push({
        field: oppField,
        to: s2,
        implied
      });
    }
  });
  return nextNPrev;
}
function getTrailLength(curr, offset2 = 1) {
  const index2 = (TRAIL_LENGTHS.indexOf(curr) + offset2) % TRAIL_LENGTHS.length;
  return TRAIL_LENGTHS[index2 < 0 ? TRAIL_LENGTHS.length + index2 : index2];
}
async function drawTrail(plugin) {
  var _a, _b, _c, _d;
  try {
    const { settings, db, mainG } = plugin;
    const {
      showBCs,
      noPathMessage,
      respectReadableLineLength,
      showTrail,
      showGrid,
      showJuggl,
      showPrevNext,
      showBCsInEditLPMode
    } = settings;
    db.start2G("drawTrail");
    const activeMDView = app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    const mode = activeMDView == null ? void 0 : activeMDView.getMode();
    if (!showBCs || !activeMDView || mode !== "preview" && !showBCsInEditLPMode) {
      (_a = activeMDView == null ? void 0 : activeMDView.containerEl.querySelector(".BC-trail")) == null ? void 0 : _a.remove();
      return db.end2G();
    }
    const { file } = activeMDView;
    const { frontmatter } = (_b = app.metadataCache.getFileCache(file)) != null ? _b : {};
    if ((frontmatter == null ? void 0 : frontmatter[BC_HIDE_TRAIL]) || (frontmatter == null ? void 0 : frontmatter["kanban-plugin"]))
      return db.end2G();
    const { basename } = file;
    if (!mainG.hasNode(basename))
      return db.end2G();
    const view = mode === "preview" ? activeMDView.previewMode.containerEl.querySelector(
      "div.markdown-preview-view"
    ) : activeMDView.contentEl.querySelector("div.markdown-source-view");
    (_c = activeMDView.containerEl.querySelectorAll(".BC-trail")) == null ? void 0 : _c.forEach((trail) => trail.remove());
    const closedUp = getLimitedTrailSub(plugin);
    const sortedTrails = getBreadcrumbs(settings, closedUp, file);
    (0, import_loglevel12.info)({ sortedTrails });
    const {
      next: { reals: rNext, implieds: iNext },
      prev: { reals: rPrev, implieds: iPrev }
    } = getNextNPrev(plugin, basename);
    const next = [...rNext];
    iNext.forEach((i) => {
      if (next.findIndex((n2) => n2.to === i.to) === -1)
        next.push(i);
    });
    const prev = [...rPrev];
    iPrev.forEach((i) => {
      if (prev.findIndex((n2) => n2.to === i.to) === -1)
        prev.push(i);
    });
    const noItems = !sortedTrails.length && !next.length && !prev.length;
    if (noItems && noPathMessage === "")
      return db.end2G();
    const selectorForMaxWidth = mode === "preview" ? ".markdown-preview-view.is-readable-line-width .markdown-preview-sizer" : "";
    const elForMaxWidth = selectorForMaxWidth !== "" ? document.querySelector(selectorForMaxWidth) : null;
    const max_width = elForMaxWidth ? getComputedStyle(elForMaxWidth).getPropertyValue("max-width") : "100%";
    const trailDiv = createDiv({
      cls: `BC-trail ${respectReadableLineLength ? "is-readable-line-width markdown-preview-sizer markdown-preview-section" : ""}`,
      attr: {
        style: (mode !== "preview" ? `max-width: ${max_width};` : "") + `margin: 0 auto;${respectReadableLineLength ? "width: var(--file-line-width);" : "width: 100%"}`
      }
    });
    plugin.visited.push([file.path, trailDiv]);
    if (mode === "preview") {
      view.querySelector("div.markdown-preview-sizer").before(trailDiv);
    } else {
      const cmGutter = view.querySelector("div.cm-gutters");
      if (cmGutter) {
        requestAnimationFrame(() => {
          const gutterHeight = trailDiv.getBoundingClientRect().height;
          cmGutter.style.paddingTop = `${gutterHeight + 4}px`;
        });
      }
      (_d = view.querySelector("div.cm-contentContainer")) == null ? void 0 : _d.before(trailDiv);
    }
    trailDiv.empty();
    if (settings.indexNotes.includes(basename)) {
      trailDiv.innerText = "Index Note";
      return db.end2G();
    }
    if (noItems) {
      trailDiv.innerText = noPathMessage;
      return db.end2G();
    }
    const targetProps = {
      target: trailDiv,
      props: { sortedTrails, plugin }
    };
    if (showTrail && sortedTrails.length)
      new TrailPath_default(targetProps);
    if (showGrid && sortedTrails.length)
      new TrailGrid_default(targetProps);
    if (showPrevNext && (next.length || prev.length)) {
      new NextPrev_default({
        target: trailDiv,
        props: { plugin, next, prev }
      });
    }
    if (showJuggl && sortedTrails.length) {
      createJugglTrail(
        plugin,
        trailDiv,
        sortedTrails,
        basename,
        JUGGL_TRAIL_DEFAULTS
      );
    }
    db.end2G();
  } catch (err) {
    (0, import_loglevel12.error)(err);
    plugin.db.end2G();
  }
}

// src/refreshIndex.ts
function getDVMetadataCache(plugin) {
  const { db } = plugin;
  const api = getDVApi(plugin);
  db.start1G("getDVMetadataCache");
  const frontms = api.pages().values;
  db.end1G({ frontms });
  return frontms;
}
function getObsMetadataCache(plugin, files) {
  const { db } = plugin;
  db.start1G("getObsMetadataCache");
  const frontms = files.map((file) => {
    const { frontmatter } = app.metadataCache.getFileCache(file);
    return frontmatter ? { file, ...frontmatter } : { file };
  });
  db.end1G({ frontms });
  return frontms;
}
var isDVProxy = (item) => typeof item.defaultComparator === "function";
function unproxy(item) {
  const unproxied = [];
  const queue = [item];
  while (queue.length) {
    const currItem = queue.shift();
    if (isDVProxy(currItem))
      queue.push(...currItem.values);
    else
      unproxied.push(currItem);
  }
  return unproxied;
}
function parseFieldValue(value) {
  if (!value)
    return [];
  const parsed = [];
  try {
    if (typeof value === "string") {
      const splits = value.match(splitLinksRegex);
      if (splits !== null) {
        const linkNames = splits.map((link2) => getBaseFromMDPath(link2.match(dropHeaderOrAlias)[1]));
        parsed.push(...linkNames);
      }
    } else {
      const rawValues = [value].flat(4);
      (0, import_loglevel13.debug)(...rawValues);
      rawValues.forEach((rawItem) => {
        if (!rawItem)
          return;
        const unProxied = unproxy(rawItem);
        unProxied.forEach((value2) => {
          if (typeof value2 === "string" || typeof value2 === "number") {
            const rawAsString = value2.toString();
            const splits = rawAsString.match(splitLinksRegex);
            if (splits !== null) {
              const strs = splits.map(
                (link2) => getBaseFromMDPath(link2.match(dropHeaderOrAlias)[1])
              );
              parsed.push(...strs);
            } else {
              const basename = getBaseFromMDPath(rawAsString);
              parsed.push(basename.split("#")[0].split("|")[0]);
            }
          } else if (value2.path !== void 0) {
            const basename = getBaseFromMDPath(value2.path);
            if (basename !== void 0)
              parsed.push(basename);
          }
        });
      });
    }
    return parsed;
  } catch (err) {
    (0, import_loglevel13.error)(err);
    return parsed;
  }
}
async function buildMainG(plugin) {
  const mainG = new import_graphology2.MultiGraph();
  try {
    const { settings, db } = plugin;
    const { userHiers, CSVPaths, parseJugglLinksWithoutJuggl, hierarchyNotes } = settings;
    db.start2G("initGraphs");
    if (userHiers.length === 0) {
      db.end2G();
      new import_obsidian9.Notice("You do not have any Breadcrumbs hierarchies set up.");
      return mainG;
    }
    const files = app.vault.getMarkdownFiles();
    const dvQ = app.plugins.enabledPlugins.has("dataview");
    let frontms = dvQ ? getDVMetadataCache(plugin) : getObsMetadataCache(plugin, files);
    const CSVRows = CSVPaths !== "" ? await getCSVRows(plugin) : [];
    const eligableAlts = {};
    BC_ALTS.forEach((alt) => eligableAlts[alt] = []);
    db.start2G("addFrontmatterToGraph");
    frontms.forEach((page) => {
      BC_ALTS.forEach((alt) => {
        if (page[alt] !== void 0 && page[alt] !== null)
          eligableAlts[alt].push(page);
      });
      const basename = getDVBasename(page.file);
      const sourceOrder = getSourceOrder(page);
      iterateHiers(userHiers, (hier, dir, field) => {
        const values = parseFieldValue(page[field]);
        values.forEach((target) => {
          if (target.startsWith("<%") || target.startsWith("{{"))
            return;
          const targetOrder = getTargetOrder(frontms, target);
          populateMain(
            settings,
            mainG,
            basename,
            field,
            target,
            sourceOrder,
            targetOrder
          );
        });
        if (CSVRows.length)
          addCSVCrumbs(mainG, CSVRows, dir, field);
      });
    });
    db.end2G();
    const jugglLinks = app.plugins.plugins.juggl || parseJugglLinksWithoutJuggl ? await getJugglLinks(plugin, files) : [];
    if (jugglLinks.length)
      addJugglLinksToGraph(settings, jugglLinks, frontms, mainG);
    db.start2G("Alternative Hierarchies");
    db.start2G("Hierarchy Notes");
    if (hierarchyNotes.length) {
      for (const noteOrFolder of hierarchyNotes) {
        if (noteOrFolder.endsWith("/")) {
          const folder = app.vault.getAbstractFileByPath(
            (0, import_obsidian9.normalizePath)(noteOrFolder)
          );
          if (!(folder instanceof import_obsidian9.TFolder))
            continue;
          for (const child of folder.children) {
            if (child instanceof import_obsidian9.TFile) {
              addHNsToGraph(
                settings,
                await getHierarchyNoteItems(child),
                mainG
              );
            }
          }
        } else {
          const file = app.metadataCache.getFirstLinkpathDest(noteOrFolder, "");
          if (file)
            addHNsToGraph(
              settings,
              await getHierarchyNoteItems(file),
              mainG
            );
        }
      }
    }
    db.end2G();
    db.start2G("Folder Notes");
    addFolderNotesToGraph(plugin, eligableAlts[BC_FOLDER_NOTE], frontms, mainG);
    db.end2G();
    db.start2G("Tag Notes");
    addTagNotesToGraph(plugin, eligableAlts[BC_TAG_NOTE], frontms, mainG);
    db.end2G();
    db.start2G("Link Notes");
    addLinkNotesToGraph(plugin, eligableAlts[BC_LINK_NOTE], frontms, mainG);
    db.end2G();
    db.start2G("Regex Notes");
    addRegexNotesToGraph(plugin, eligableAlts[BC_REGEX_NOTE], frontms, mainG);
    db.end2G();
    db.start2G("Traverse Notes");
    addTraverseNotesToGraph(
      plugin,
      eligableAlts[BC_TRAVERSE_NOTE],
      mainG,
      buildObsGraph()
    );
    db.end2G();
    db.start2G("Dendron Notes");
    addDendronNotesToGraph(plugin, frontms, mainG);
    db.end2G();
    db.start2G("Dataview Notes");
    addDataviewNotesToGraph(plugin, eligableAlts[BC_DV_NOTE], frontms, mainG);
    db.end2G();
    db.start2G("Date Notes");
    addDateNotesToGraph(plugin, frontms, mainG);
    db.end2G();
    db.end2G();
    files.forEach((file) => addNodesIfNot(mainG, [file.basename]));
    db.end2G("graphs inited", { mainG });
    return mainG;
  } catch (err) {
    (0, import_loglevel13.error)(err);
    plugin.db.end2G();
    return mainG;
  }
}
function buildClosedG(plugin) {
  const { mainG, settings } = plugin;
  const {
    userHiers,
    impliedRelations: {
      sameParentIsSibling,
      parentsSiblingsIsParents,
      cousinsIsSibling,
      siblingsSiblingIsSibling,
      siblingsParentIsParent
    }
  } = settings;
  let closedG = getReflexiveClosure(mainG, userHiers);
  if (sameParentIsSibling)
    addSiblingsFromSameParent(closedG, settings);
  if (siblingsParentIsParent)
    addSiblingsParentIsParent(closedG);
  if (parentsSiblingsIsParents)
    addAuntsUncles(closedG);
  if (cousinsIsSibling)
    addCousins(closedG);
  if (siblingsSiblingIsSibling)
    addStructuralEquivalenceSiblings(closedG);
  return closedG;
}
async function refreshIndex(plugin) {
  var _a;
  if (!plugin.activeLeafChange)
    plugin.registerActiveLeafChangeEvent();
  if (!plugin.layoutChange)
    plugin.registerLayoutChangeEvent();
  plugin.mainG = await buildMainG(plugin);
  plugin.closedG = buildClosedG(plugin);
  for (const { type: type2 } of plugin.VIEWS)
    await ((_a = plugin.getActiveTYPEView(type2)) == null ? void 0 : _a.draw());
  if (plugin.settings.showBCs)
    await drawTrail(plugin);
  if (plugin.settings.showRefreshNotice)
    new import_obsidian9.Notice("BC Index refreshed");
}

// src/Components/MatrixButtons.svelte
function add_css4(target) {
  append_styles(target, "svelte-barhym", "button.svelte-barhym{padding:1px 6px 2px 6px;margin-right:6px}");
}
function create_if_block3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${/*alphaSortAsc*/
      ctx[2] ? "\u2197" : "\u2198"}`;
      attr(button, "class", "BC-sort-button svelte-barhym");
      attr(button, "aria-label", "Alphabetical Sorting Order");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  let button;
  let t1;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*enableAlphaSort*/
    ctx[3] && create_if_block3(ctx)
  );
  return {
    c() {
      button = element("button");
      button.textContent = "\u21BB";
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", "BC-refresh-button svelte-barhym");
      attr(button, "aria-label", "Refresh Index");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*enableAlphaSort*/
        ctx2[3]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  ;
  let { matrixView } = $$props;
  const { plugin } = matrixView;
  const { alphaSortAsc, enableAlphaSort } = plugin.settings;
  const click_handler = async () => await refreshIndex(plugin);
  const click_handler_1 = async () => {
    $$invalidate(1, plugin.settings.alphaSortAsc = !alphaSortAsc, plugin);
    await plugin.saveSettings();
    await matrixView.draw();
  };
  $$self.$$set = ($$props2) => {
    if ("matrixView" in $$props2)
      $$invalidate(0, matrixView = $$props2.matrixView);
  };
  return [
    matrixView,
    plugin,
    alphaSortAsc,
    enableAlphaSort,
    click_handler,
    click_handler_1
  ];
}
var MatrixButtons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { matrixView: 0 }, add_css4);
  }
};
var MatrixButtons_default = MatrixButtons;

// src/Components/Matrix.svelte
function add_css5(target) {
  append_styles(target, "svelte-1p44ezg", ".BC-Matrix.svelte-1p44ezg.svelte-1p44ezg{padding:5px;font-variant-numeric:tabular-nums;line-height:1.5}.BC-Matrix.svelte-1p44ezg>div.svelte-1p44ezg{border:3px solid var(--background-modifier-border);border-radius:3px;margin:3px;position:relative;height:fit-content}.BC-Matrix-square.svelte-1p44ezg.svelte-1p44ezg{border:1px solid var(--background-modifier-border)}.BC-Matrix-headers.svelte-1p44ezg.svelte-1p44ezg{display:flex;justify-content:space-between;align-items:center}.BC-Matrix-header.svelte-1p44ezg.svelte-1p44ezg{margin:2px;padding:0px 10px}h4.BC-Matrix-header.svelte-1p44ezg.svelte-1p44ezg:first-letter{text-transform:capitalize}ol.svelte-1p44ezg.svelte-1p44ezg{margin:3px;padding-left:30px}.BC-Matrix.svelte-1p44ezg li.svelte-1p44ezg{margin:0.1em}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i].field;
  child_ctx[17] = list[i].impliedItems;
  child_ctx[18] = list[i].realItems;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i].alt;
  child_ctx[22] = list[i].cls;
  child_ctx[23] = list[i].implied;
  child_ctx[24] = list[i].to;
  child_ctx[25] = list[i].parent;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i].alt;
  child_ctx[22] = list[i].cls;
  child_ctx[23] = list[i].implied;
  child_ctx[24] = list[i].to;
  return child_ctx;
}
function create_if_block4(ctx) {
  let div1;
  let div0;
  let h4;
  let t0_value = (
    /*field*/
    ctx[16] + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block0 = (
    /*showRelationType*/
    ctx[7] && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*realItems*/
    ctx[18].length && create_if_block_4(ctx)
  );
  let if_block2 = (
    /*showImpliedRelations*/
    ctx[4] && /*impliedItems*/
    ctx[17].length && create_if_block_12(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(h4, "class", "BC-Matrix-header svelte-1p44ezg");
      attr(div0, "class", "BC-Matrix-headers svelte-1p44ezg");
      attr(div1, "class", "BC-Matrix-square svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h4);
      append(h4, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*hierSquares*/
      1 && t0_value !== (t0_value = /*field*/
      ctx2[16] + ""))
        set_data(t0, t0_value);
      if (
        /*showRelationType*/
        ctx2[7]
      )
        if_block0.p(ctx2, dirty);
      if (
        /*realItems*/
        ctx2[18].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*showImpliedRelations*/
        ctx2[4] && /*impliedItems*/
        ctx2[17].length
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_12(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_5(ctx) {
  let h6;
  let t_value = (
    /*realItems*/
    ctx[18].length ? "Real" : "Implied"
  );
  let t;
  return {
    c() {
      h6 = element("h6");
      t = text(t_value);
      attr(h6, "class", "BC-Matrix-header svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, h6, anchor);
      append(h6, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hierSquares*/
      1 && t_value !== (t_value = /*realItems*/
      ctx2[18].length ? "Real" : "Implied"))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h6);
    }
  };
}
function create_if_block_4(ctx) {
  let ol;
  let each_value_3 = (
    /*realItems*/
    ctx[18]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  return {
    c() {
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ol, "class", "svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*hierSquares, rlLeaf, openOrSwitch, hoverPreview, matrixView, dropPathNDendron, settings*/
      45) {
        each_value_3 = /*realItems*/
        ctx2[18];
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(ol);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  var _a;
  let li;
  let div;
  let t0_value = (
    /*alt*/
    ((_a = ctx[21]) != null ? _a : dropPathNDendron(
      /*to*/
      ctx[24],
      /*settings*/
      ctx[3]
    )) + ""
  );
  let t0;
  let div_class_value;
  let div_aria_label_value;
  let div_aria_label_position_value;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[8](
        /*to*/
        ctx[24],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[9](
        /*to*/
        ctx[24],
        ...args
      )
    );
  }
  return {
    c() {
      var _a2;
      li = element("li");
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", div_class_value = /*cls*/
      ctx[22] + " " + /*implied*/
      ((_a2 = ctx[23]) != null ? _a2 : "") + " svelte-1p44ezg");
      attr(div, "aria-label", div_aria_label_value = /*alt*/
      ctx[21] ? (
        /*to*/
        ctx[24]
      ) : "");
      attr(div, "aria-label-position", div_aria_label_position_value = /*rlLeaf*/
      ctx[5] ? "left" : "right");
      attr(li, "class", "svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, t0);
      append(li, t1);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler),
          listen(div, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b;
      ctx = new_ctx;
      if (dirty & /*hierSquares*/
      1 && t0_value !== (t0_value = /*alt*/
      ((_a2 = ctx[21]) != null ? _a2 : dropPathNDendron(
        /*to*/
        ctx[24],
        /*settings*/
        ctx[3]
      )) + ""))
        set_data(t0, t0_value);
      if (dirty & /*hierSquares*/
      1 && div_class_value !== (div_class_value = /*cls*/
      ctx[22] + " " + /*implied*/
      ((_b = ctx[23]) != null ? _b : "") + " svelte-1p44ezg")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*hierSquares*/
      1 && div_aria_label_value !== (div_aria_label_value = /*alt*/
      ctx[21] ? (
        /*to*/
        ctx[24]
      ) : "")) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let h4;
  let t1;
  let t2;
  let ol;
  let ol_start_value;
  let if_block = (
    /*impliedItems*/
    ctx[17].length && create_if_block_22(ctx)
  );
  let each_value_2 = (
    /*impliedItems*/
    ctx[17]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      div = element("div");
      h4 = element("h4");
      h4.textContent = `${" "}`;
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h4, "class", "BC-Matrix-header svelte-1p44ezg");
      attr(div, "class", "BC-Matrix-headers svelte-1p44ezg");
      attr(ol, "start", ol_start_value = /*realItems*/
      ctx[18].length + 1);
      attr(ol, "class", "svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h4);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      insert(target, t2, anchor);
      insert(target, ol, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ol, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (
        /*impliedItems*/
        ctx2[17].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*treatCurrNodeAsImpliedSibling, hierSquares, currFile, rlLeaf, openOrSwitch, hoverPreview, matrixView, dropPathNDendron, settings*/
      111) {
        each_value_2 = /*impliedItems*/
        ctx2[17];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty & /*hierSquares*/
      1 && ol_start_value !== (ol_start_value = /*realItems*/
      ctx2[18].length + 1)) {
        attr(ol, "start", ol_start_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t2);
      if (detaching)
        detach(ol);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let if_block_anchor;
  let if_block = (
    /*showRelationType*/
    ctx[7] && /*realItems*/
    ctx[18].length && create_if_block_3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*showRelationType*/
        ctx2[7] && /*realItems*/
        ctx2[18].length
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let h6;
  return {
    c() {
      h6 = element("h6");
      h6.textContent = "Implied";
      attr(h6, "class", "BC-Matrix-header svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, h6, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(h6);
    }
  };
}
function create_each_block_2(ctx) {
  var _a;
  let li;
  let div;
  let t_value = (
    /*alt*/
    ((_a = ctx[21]) != null ? _a : dropPathNDendron(
      /*to*/
      ctx[24],
      /*settings*/
      ctx[3]
    )) + ""
  );
  let t;
  let div_class_value;
  let div_aria_label_value;
  let div_aria_label_position_value;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[10](
        /*to*/
        ctx[24],
        ...args
      )
    );
  }
  function mouseover_handler_1(...args) {
    return (
      /*mouseover_handler_1*/
      ctx[11](
        /*to*/
        ctx[24],
        ...args
      )
    );
  }
  return {
    c() {
      var _a2;
      li = element("li");
      div = element("div");
      t = text(t_value);
      attr(div, "class", div_class_value = /*cls*/
      ctx[22] + " " + /*implied*/
      ((_a2 = ctx[23]) != null ? _a2 : "") + " svelte-1p44ezg");
      attr(div, "aria-label", div_aria_label_value = /*alt*/
      (ctx[21] ? `${/*to*/
      ctx[24]}
` : "") + /*parent*/
      (ctx[25] ? "\u2191 " + /*parent*/
      ctx[25] : ""));
      attr(div, "aria-label-position", div_aria_label_position_value = /*rlLeaf*/
      ctx[5] ? "left" : "right");
      attr(li, "class", li_class_value = "BC-Implied " + /*treatCurrNodeAsImpliedSibling*/
      (ctx[6] && /*to*/
      ctx[24] === /*currFile*/
      ctx[1].basename ? "BC-active-note" : "") + " svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler_1),
          listen(div, "mouseover", mouseover_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b;
      ctx = new_ctx;
      if (dirty & /*hierSquares*/
      1 && t_value !== (t_value = /*alt*/
      ((_a2 = ctx[21]) != null ? _a2 : dropPathNDendron(
        /*to*/
        ctx[24],
        /*settings*/
        ctx[3]
      )) + ""))
        set_data(t, t_value);
      if (dirty & /*hierSquares*/
      1 && div_class_value !== (div_class_value = /*cls*/
      ctx[22] + " " + /*implied*/
      ((_b = ctx[23]) != null ? _b : "") + " svelte-1p44ezg")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & /*hierSquares*/
      1 && div_aria_label_value !== (div_aria_label_value = /*alt*/
      (ctx[21] ? `${/*to*/
      ctx[24]}
` : "") + /*parent*/
      (ctx[25] ? "\u2191 " + /*parent*/
      ctx[25] : ""))) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (dirty & /*hierSquares, currFile*/
      3 && li_class_value !== (li_class_value = "BC-Implied " + /*treatCurrNodeAsImpliedSibling*/
      (ctx[6] && /*to*/
      ctx[24] === /*currFile*/
      ctx[1].basename ? "BC-active-note" : "") + " svelte-1p44ezg")) {
        attr(li, "class", li_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_14(ctx) {
  let if_block_anchor;
  let if_block = (
    /*realItems*/
    (ctx[18].length || /*showImpliedRelations*/
    ctx[4] && /*impliedItems*/
    ctx[17].length) && create_if_block4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*realItems*/
        ctx2[18].length || /*showImpliedRelations*/
        ctx2[4] && /*impliedItems*/
        ctx2[17].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block4(ctx) {
  let div;
  let t;
  let each_value_1 = (
    /*squares*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "BC-matrix-hier svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hierSquares, treatCurrNodeAsImpliedSibling, currFile, rlLeaf, openOrSwitch, hoverPreview, matrixView, dropPathNDendron, settings, showRelationType, showImpliedRelations*/
      255) {
        each_value_1 = /*squares*/
        ctx2[13];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_14(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_14(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment7(ctx) {
  let div0;
  let matrixbuttons;
  let t;
  let div1;
  let div1_class_value;
  let current;
  matrixbuttons = new MatrixButtons_default({
    props: { matrixView: (
      /*matrixView*/
      ctx[2]
    ) }
  });
  let each_value = (
    /*hierSquares*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div0 = element("div");
      create_component(matrixbuttons.$$.fragment);
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "BC-matrix-buttons");
      attr(div1, "class", div1_class_value = "BC-Matrix markdown-preview-view " + /*hierSquares*/
      (ctx[0].length ? "" : "BC-empty-view") + " svelte-1p44ezg");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(matrixbuttons, div0, null);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const matrixbuttons_changes = {};
      if (dirty & /*matrixView*/
      4)
        matrixbuttons_changes.matrixView = /*matrixView*/
        ctx2[2];
      matrixbuttons.$set(matrixbuttons_changes);
      if (dirty & /*hierSquares, treatCurrNodeAsImpliedSibling, currFile, rlLeaf, openOrSwitch, hoverPreview, matrixView, dropPathNDendron, settings, showRelationType, showImpliedRelations*/
      255) {
        each_value = /*hierSquares*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*hierSquares*/
      1 && div1_class_value !== (div1_class_value = "BC-Matrix markdown-preview-view " + /*hierSquares*/
      (ctx2[0].length ? "" : "BC-empty-view") + " svelte-1p44ezg")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(matrixbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(matrixbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(matrixbuttons);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  ;
  ;
  ;
  let { hierSquares } = $$props;
  let { currFile } = $$props;
  let { matrixView } = $$props;
  const { plugin } = matrixView;
  const { settings } = plugin;
  const { showImpliedRelations, rlLeaf, treatCurrNodeAsImpliedSibling, showRelationType } = settings;
  const click_handler = async (to, e) => await openOrSwitch(to, e);
  const mouseover_handler = (to, event) => hoverPreview(event, matrixView, to);
  const click_handler_1 = async (to, e) => await openOrSwitch(to, e);
  const mouseover_handler_1 = (to, e) => hoverPreview(e, matrixView, to);
  $$self.$$set = ($$props2) => {
    if ("hierSquares" in $$props2)
      $$invalidate(0, hierSquares = $$props2.hierSquares);
    if ("currFile" in $$props2)
      $$invalidate(1, currFile = $$props2.currFile);
    if ("matrixView" in $$props2)
      $$invalidate(2, matrixView = $$props2.matrixView);
  };
  return [
    hierSquares,
    currFile,
    matrixView,
    settings,
    showImpliedRelations,
    rlLeaf,
    treatCurrNodeAsImpliedSibling,
    showRelationType,
    click_handler,
    mouseover_handler,
    click_handler_1,
    mouseover_handler_1
  ];
}
var Matrix = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        hierSquares: 0,
        currFile: 1,
        matrixView: 2
      },
      add_css5
    );
  }
};
var Matrix_default = Matrix;

// src/Views/MatrixView.ts
function getMatrixNeighbours(plugin, currNode) {
  const { closedG, settings } = plugin;
  const { userHiers } = settings;
  const neighbours = blankRealNImplied();
  if (!closedG)
    return neighbours;
  closedG.forEachEdge(currNode, (k, a2, s2, t) => {
    const { field, dir, implied } = a2;
    if (s2 === currNode) {
      neighbours[dir].reals.push({ to: t, field, implied });
    } else {
      neighbours[getOppDir(dir)].implieds.push({
        to: s2,
        field: getOppFields(userHiers, field, dir)[0],
        implied
      });
    }
  });
  return neighbours;
}
var MatrixView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = TRAIL_ICON;
    this.toInternalLinkObj = (to, realQ = true, parent, implied) => {
      return {
        to,
        cls: linkClass(to, realQ),
        alt: this.getAlt(to),
        order: this.getOrder(to),
        parent,
        implied
      };
    };
    this.getOrder = (node) => Number.parseInt(this.plugin.mainG.getNodeAttribute(node, "order"));
    this.sortItemsAlpha = (a2, b) => {
      var _a, _b;
      const { sortByNameShowAlias, alphaSortAsc } = this.plugin.settings;
      const aToSort = (sortByNameShowAlias ? a2.to : (_a = a2.alt) != null ? _a : a2.to).toLowerCase();
      const bToSort = (sortByNameShowAlias ? b.to : (_b = b.alt) != null ? _b : b.to).toLowerCase();
      const less = alphaSortAsc ? -1 : 1;
      const more = alphaSortAsc ? 1 : -1;
      return aToSort < bToSort ? less : more;
    };
    this.plugin = plugin;
    this.db = new Debugger(plugin);
  }
  async onload() {
    super.onload();
    const { plugin } = this;
    app.workspace.onLayoutReady(() => {
      setTimeout(
        async () => await this.draw(),
        app.plugins.plugins.dataview ? app.plugins.plugins.dataview.api ? 1 : plugin.settings.dvWaitTime : 3e3
      );
    });
  }
  getViewType() {
    return MATRIX_VIEW;
  }
  getDisplayText() {
    return "Breadcrumbs Matrix";
  }
  async onOpen() {
  }
  onClose() {
    var _a;
    (_a = this.view) == null ? void 0 : _a.$destroy();
    return Promise.resolve();
  }
  getAlt(node) {
    const { plugin } = this;
    const { altLinkFields, showAllAliases } = plugin.settings;
    if (!altLinkFields.length)
      return null;
    const dv = getDVApi(plugin);
    if (dv) {
      const page = dv.page(node);
      if (!page)
        return null;
      for (const alt of altLinkFields) {
        const value = page[alt];
        const arr = typeof value === "string" ? splitAndTrim(value) : value;
        if (value)
          return showAllAliases ? arr.join(", ") : arr[0];
      }
    } else {
      const file = app.metadataCache.getFirstLinkpathDest(node, "");
      if (file) {
        const { frontmatter } = app.metadataCache.getFileCache(file);
        for (const altField of altLinkFields) {
          const value = frontmatter == null ? void 0 : frontmatter[altField];
          const arr = typeof value === "string" ? splitAndTrim(value) : value;
          if (value)
            return showAllAliases ? arr.join(", ") : arr[0];
        }
      }
    }
  }
  // ANCHOR Remove duplicate implied links
  removeDuplicateImplied(reals, implieds) {
    const realTos = reals.map((real) => real.to);
    return implieds.filter((implied) => !realTos.includes(implied.to));
  }
  getHierSquares(userHiers, currFile) {
    const { plugin } = this;
    const { mainG, settings } = plugin;
    const { enableAlphaSort, squareDirectionsOrder } = settings;
    if (!mainG)
      return [];
    const { basename } = currFile;
    if (!mainG.hasNode(basename))
      return [];
    const realsnImplieds = getMatrixNeighbours(plugin, basename);
    return userHiers.map((hier) => {
      const filteredRealNImplied = blankRealNImplied();
      const resultsFilter = (item, dir, oppDir, arrow) => hier[dir].includes(item.field) || item.field.includes(`<${arrow}>`) && hier[oppDir].includes(item.field.split(" <")[0]);
      for (const dir in realsnImplieds) {
        const oppDir = getOppDir(dir);
        const arrow = ARROW_DIRECTIONS[dir];
        const { reals, implieds } = realsnImplieds[dir];
        filteredRealNImplied[dir].reals = reals.filter(
          (real) => resultsFilter(real, dir, oppDir, arrow)
        ).map(
          (item) => this.toInternalLinkObj(item.to, true, null, item.implied)
        );
        filteredRealNImplied[dir].implieds = implieds.filter(
          (implied) => resultsFilter(implied, dir, oppDir, arrow)
        ).map(
          (item) => this.toInternalLinkObj(item.to, false, null, item.implied)
        );
      }
      let {
        up: { reals: ru, implieds: iu },
        same: { reals: rs, implieds: is },
        down: { reals: rd, implieds: id2 },
        next: { reals: rn, implieds: iN },
        prev: { reals: rp, implieds: ip }
      } = filteredRealNImplied;
      [iu, is, id2, iN, ip] = [
        this.removeDuplicateImplied(ru, iu),
        this.removeDuplicateImplied(rs, is),
        this.removeDuplicateImplied(rd, id2),
        this.removeDuplicateImplied(rn, iN),
        this.removeDuplicateImplied(rp, ip)
      ];
      const iSameNoDup = [];
      is.forEach((impSib) => {
        if (iSameNoDup.every((noDup) => noDup.to !== impSib.to)) {
          iSameNoDup.push(impSib);
        }
      });
      is = iSameNoDup;
      const getFieldInHier = (dir) => hier[dir][0] ? hier[dir].join(", ") : `${hier[getOppDir(dir)].join(",")}${ARROW_DIRECTIONS[dir]}`;
      const squares = [ru, rs, rd, rn, rp, iu, is, id2, iN, ip];
      if (enableAlphaSort)
        squares.forEach((sq) => sq.sort(this.sortItemsAlpha));
      squares.forEach((sq) => sq.sort((a2, b) => a2.order - b.order));
      (0, import_loglevel14.info)([
        { ru },
        { rs },
        { rd },
        { rn },
        { rp },
        { iu },
        { is },
        { id: id2 },
        { iN },
        { ip }
      ]);
      const square = [
        {
          realItems: ru,
          impliedItems: iu,
          field: getFieldInHier("up")
        },
        {
          realItems: rs,
          impliedItems: is,
          field: getFieldInHier("same")
        },
        {
          realItems: rd,
          impliedItems: id2,
          field: getFieldInHier("down")
        },
        {
          realItems: rn,
          impliedItems: iN,
          field: getFieldInHier("next")
        },
        {
          realItems: rp,
          impliedItems: ip,
          field: getFieldInHier("prev")
        }
      ];
      return squareDirectionsOrder.map((order) => square[order]);
    });
  }
  async draw() {
    try {
      const { contentEl, db, plugin } = this;
      db.start2G("Draw Matrix View");
      contentEl.empty();
      const { userHiers } = plugin.settings;
      const currFile = getCurrFile();
      if (!currFile)
        return;
      const hierSquares = this.getHierSquares(userHiers, currFile).filter(
        (squareArr) => squareArr.some(
          (sq) => sq.realItems.length + sq.impliedItems.length > 0
        )
      );
      new Matrix_default({
        target: contentEl,
        props: { hierSquares, matrixView: this, currFile }
      });
      db.end2G();
    } catch (err) {
      (0, import_loglevel14.error)(err);
      this.db.end2G();
    }
  }
};

// src/API.ts
var BCAPI = class {
  constructor(plugin) {
    this.DIRECTIONS = DIRECTIONS;
    this.ARROW_DIRECTIONS = ARROW_DIRECTIONS;
    this.buildObsGraph = buildObsGraph;
    this.refreshIndex = async () => await refreshIndex(this.plugin);
    this.getSubInDirs = (dirs, g = this.mainG) => getSubInDirs(g, ...dirs);
    this.getSubForFields = (fields, g = this.mainG) => getSubForFields(g, fields);
    this.dfsAllPaths = (fromNode = ((_a) => (_a = getCurrFile()) == null ? void 0 : _a.basename)(), g = this.mainG) => dfsAllPaths(g, fromNode);
    this.createIndex = (allPaths, wikilinks = false, indent = "  ") => createIndex(allPaths, wikilinks, indent);
    this.getMatrixNeighbours = (fromNode = ((_b) => (_b = getCurrFile()) == null ? void 0 : _b.basename)()) => getMatrixNeighbours(this.plugin, fromNode);
    this.getOppDir = (dir) => getOppDir(dir);
    this.getOppFields = (field) => {
      const { fieldDir } = getFieldInfo(this.plugin.settings.userHiers, field);
      return getOppFields(this.plugin.settings.userHiers, field, fieldDir);
    };
    this.getFieldInfo = (field) => getFieldInfo(this.plugin.settings.userHiers, field);
    this.getFields = (dir) => getFields(this.plugin.settings.userHiers, dir != null ? dir : "all");
    this.plugin = plugin;
    this.mainG = this.plugin.mainG;
    this.closedG = this.plugin.closedG;
  }
  iterateHiers(cb) {
    iterateHiers(this.plugin.settings.userHiers, cb);
  }
};

// src/AlternativeHierarchies/HierarchyNotes/HierNoteModal.ts
var import_obsidian14 = require("obsidian");

// src/AlternativeHierarchies/HierarchyNotes/HierarchyNoteManipulator.ts
var import_loglevel15 = __toESM(require_loglevel());
var import_obsidian13 = require("obsidian");

// src/AlternativeHierarchies/HierarchyNotes/ModifyHierItemModal.ts
var import_obsidian12 = require("obsidian");

// src/Components/ModifyHNItemComp.svelte
var import_console = require("console");
var import_obsidian11 = require("obsidian");
function add_css6(target) {
  append_styles(target, "svelte-13g4k7i", "pre.svelte-13g4k7i{display:inline}");
}
function create_if_block_23(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*hnItem*/
      ctx2[2].depth === 0
    )
      return create_if_block_32;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block2(ctx) {
  let div;
  let pre;
  let t0;
  let t1_value = (
    /*buildNewItem*/
    ctx[6](
      /*newItem*/
      ctx[5],
      /*hnItem*/
      ctx[2].depth - 4,
      true
    ) + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text("          ");
      t1 = text(t1_value);
      t2 = text("\n        ");
      attr(pre, "class", "svelte-13g4k7i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(pre, t1);
      append(pre, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*newItem, hnItem*/
      36 && t1_value !== (t1_value = /*buildNewItem*/
      ctx2[6](
        /*newItem*/
        ctx2[5],
        /*hnItem*/
        ctx2[2].depth - 4,
        true
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Can't add parent to top level item, choose another direction";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  let pre;
  let t0;
  let t1_value = (
    /*buildNewItem*/
    ctx[6](
      /*newItem*/
      ctx[5],
      /*hnItem*/
      ctx[2].depth + 4,
      true
    ) + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text("        ");
      t1 = text(t1_value);
      t2 = text("\n    ");
      attr(pre, "class", "svelte-13g4k7i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(pre, t1);
      append(pre, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*newItem, hnItem*/
      36 && t1_value !== (t1_value = /*buildNewItem*/
      ctx2[6](
        /*newItem*/
        ctx2[5],
        /*hnItem*/
        ctx2[2].depth + 4,
        true
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block5(ctx) {
  let div;
  let pre;
  let t0;
  let t1_value = (
    /*buildNewItem*/
    ctx[6](
      /*newItem*/
      ctx[5],
      /*hnItem*/
      ctx[2].depth,
      true
    ) + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text("        ");
      t1 = text(t1_value);
      t2 = text("\n    ");
      attr(pre, "class", "svelte-13g4k7i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(pre, t1);
      append(pre, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*newItem, hnItem*/
      36 && t1_value !== (t1_value = /*buildNewItem*/
      ctx2[6](
        /*newItem*/
        ctx2[5],
        /*hnItem*/
        ctx2[2].depth,
        true
      ) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment8(ctx) {
  let h5;
  let t0;
  let t1_value = ARROW_DIRECTIONS[
    /*rel*/
    ctx[0]
  ] + "";
  let t1;
  let t2;
  let t3_value = dropWikilinks(
    /*hnItem*/
    ctx[2].line
  ) + "";
  let t3;
  let t4;
  let div1;
  let t5;
  let div0;
  let pre;
  let t6;
  let strong;
  let t7_value = (
    /*buildNewItem*/
    ctx[6](
      dropWikilinks(
        /*hnItem*/
        ctx[2].line
      ),
      /*hnItem*/
      ctx[2].depth,
      true
    ) + ""
  );
  let t7;
  let t8;
  let t9;
  let t10;
  let select;
  let option0;
  let option1;
  let option2;
  let t14;
  let input;
  let t15;
  let button;
  let mounted;
  let dispose;
  let if_block0 = (
    /*rel*/
    ctx[0] === "up" && create_if_block_23(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*rel*/
      ctx2[0] === "same"
    )
      return create_if_block5;
    if (
      /*rel*/
      ctx2[0] === "down"
    )
      return create_if_block_13;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  return {
    c() {
      h5 = element("h5");
      t0 = text("Add an ");
      t1 = text(t1_value);
      t2 = text(" to ");
      t3 = text(t3_value);
      t4 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t5 = space();
      div0 = element("div");
      pre = element("pre");
      t6 = text("        ");
      strong = element("strong");
      t7 = text(t7_value);
      t8 = text("\n    ");
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      select = element("select");
      option0 = element("option");
      option0.textContent = "up";
      option1 = element("option");
      option1.textContent = "same";
      option2 = element("option");
      option2.textContent = "down";
      t14 = space();
      input = element("input");
      t15 = space();
      button = element("button");
      button.textContent = "Add";
      attr(pre, "class", "svelte-13g4k7i");
      option0.__value = "up";
      option0.value = option0.__value;
      option1.__value = "same";
      option1.value = option1.__value;
      option2.__value = "down";
      option2.value = option2.__value;
      attr(select, "class", "dropdown");
      attr(select, "width", "1");
      if (
        /*rel*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[8].call(select)
        ));
      attr(input, "type", "text");
      attr(input, "placeholder", "New item");
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      append(h5, t0);
      append(h5, t1);
      append(h5, t2);
      append(h5, t3);
      insert(target, t4, anchor);
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t5);
      append(div1, div0);
      append(div0, pre);
      append(pre, t6);
      append(pre, strong);
      append(strong, t7);
      append(pre, t8);
      append(div1, t9);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t10);
      append(div1, select);
      append(select, option0);
      append(select, option1);
      append(select, option2);
      select_option(
        select,
        /*rel*/
        ctx[0],
        true
      );
      append(div1, t14);
      append(div1, input);
      ctx[9](input);
      set_input_value(
        input,
        /*newItem*/
        ctx[5]
      );
      append(div1, t15);
      append(div1, button);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[8]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[10]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*rel*/
      1 && t1_value !== (t1_value = ARROW_DIRECTIONS[
        /*rel*/
        ctx2[0]
      ] + ""))
        set_data(t1, t1_value);
      if (dirty & /*hnItem*/
      4 && t3_value !== (t3_value = dropWikilinks(
        /*hnItem*/
        ctx2[2].line
      ) + ""))
        set_data(t3, t3_value);
      if (
        /*rel*/
        ctx2[0] === "up"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          if_block0.m(div1, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*hnItem*/
      4 && t7_value !== (t7_value = /*buildNewItem*/
      ctx2[6](
        dropWikilinks(
          /*hnItem*/
          ctx2[2].line
        ),
        /*hnItem*/
        ctx2[2].depth,
        true
      ) + ""))
        set_data(t7, t7_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, t10);
        }
      }
      if (dirty & /*rel*/
      1) {
        select_option(
          select,
          /*rel*/
          ctx2[0]
        );
      }
      if (dirty & /*newItem*/
      32 && input.value !== /*newItem*/
      ctx2[5]) {
        set_input_value(
          input,
          /*newItem*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(h5);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  ;
  ;
  let { modal } = $$props;
  let { settings } = $$props;
  let { hnItem } = $$props;
  let { file } = $$props;
  let { rel } = $$props;
  let inputEl;
  let newItem = app.workspace.activeLeaf.view.file.basename;
  const buildNewItem = (newItem2, depth = hnItem.depth, preview = false) => `${" ".repeat(Math.round(depth / (preview ? 2 : 1)))}- ${preview ? newItem2 || "<Empty>" : makeWiki(newItem2)}`;
  function select_change_handler() {
    rel = select_value(this);
    $$invalidate(0, rel);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(4, inputEl);
    });
  }
  function input_input_handler() {
    newItem = this.value;
    $$invalidate(5, newItem);
  }
  const click_handler = async (e) => {
    if (rel === "up" && hnItem.depth === 0) {
      new import_obsidian11.Notice("Can't add parent to top level item, choose another direction");
      return;
    } else {
      try {
        const content = await app.vault.read(file);
        const lines = content.split("\n");
        const lineNo = rel === "up" ? hnItem.lineNo : hnItem.lineNo + 1;
        const depth = rel === "up" ? hnItem.depth - 4 : rel === "down" ? hnItem.depth + 4 : hnItem.depth;
        lines.splice(lineNo, 0, buildNewItem(newItem, depth));
        await app.vault.modify(file, lines.join("\n"));
        modal.close();
      } catch (err) {
        (0, import_console.error)(err);
        new import_obsidian11.Notice("An error occured, please check the console");
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(1, modal = $$props2.modal);
    if ("settings" in $$props2)
      $$invalidate(7, settings = $$props2.settings);
    if ("hnItem" in $$props2)
      $$invalidate(2, hnItem = $$props2.hnItem);
    if ("file" in $$props2)
      $$invalidate(3, file = $$props2.file);
    if ("rel" in $$props2)
      $$invalidate(0, rel = $$props2.rel);
  };
  return [
    rel,
    modal,
    hnItem,
    file,
    inputEl,
    newItem,
    buildNewItem,
    settings,
    select_change_handler,
    input_binding,
    input_input_handler,
    click_handler
  ];
}
var ModifyHNItemComp = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        modal: 1,
        settings: 7,
        hnItem: 2,
        file: 3,
        rel: 0
      },
      add_css6
    );
  }
};
var ModifyHNItemComp_default = ModifyHNItemComp;

// src/AlternativeHierarchies/HierarchyNotes/ModifyHierItemModal.ts
var ModifyHierItemModal = class extends import_obsidian12.Modal {
  constructor(plugin, hnItem, file, rel) {
    super(app);
    this.plugin = plugin;
    this.modal = this;
    this.hnItem = hnItem;
    this.file = file;
    this.rel = rel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.mount = new ModifyHNItemComp_default({
      target: contentEl,
      props: {
        modal: this,
        settings: this.plugin.settings,
        hnItem: this.hnItem,
        file: this.file,
        rel: this.rel
      }
    });
  }
  onClose() {
    this.mount.$destroy();
    this.contentEl.empty();
  }
};

// src/AlternativeHierarchies/HierarchyNotes/HierarchyNoteManipulator.ts
var HierarchyNoteManipulator = class extends import_obsidian13.FuzzySuggestModal {
  constructor(plugin, hierNoteName) {
    super(app);
    this.plugin = plugin;
    this.settings = this.plugin.settings;
    this.hierNoteName = hierNoteName;
    const chooseOverride = (evt) => {
      this.chooser.useSelectedItem(evt);
      return false;
    };
    this.scope.register([], "Delete", chooseOverride);
    this.scope.register(["Shift"], "ArrowUp", chooseOverride);
    this.scope.register(["Shift"], "ArrowRight", chooseOverride);
    this.scope.register(["Shift"], "ArrowDown", chooseOverride);
  }
  async onOpen() {
    this.setPlaceholder("HN Manipulator");
    this.setInstructions([
      { command: "Shift + Enter", purpose: "Jump to item" },
      { command: "Shift + \u2191", purpose: "Add parent" },
      { command: "Shift + \u2192", purpose: "Add sibling" },
      { command: "Shift + \u2193 / Enter / Click", purpose: "Add child" },
      { command: "Delete", purpose: "Delete item" }
    ]);
    this.file = app.metadataCache.getFirstLinkpathDest(this.hierNoteName, "");
    if (!this.file)
      this.lines = [];
    console.log(this);
    const content = await app.vault.cachedRead(this.file);
    this.lines = content.split("\n");
    this.listItems = app.metadataCache.getFileCache(this.file).listItems;
    console.log(this);
    super.onOpen();
  }
  getItems() {
    const items = this.listItems.map((item) => {
      const i = item.position.start.line;
      return { i, line: this.lines[i] };
    }).map((item) => {
      const splits = item.line.split("- ");
      const depth = splits[0].length;
      const line = splits.slice(1).join("- ");
      return { depth, line, lineNo: item.i };
    });
    (0, import_loglevel15.info)(items);
    return items;
  }
  getItemText(item) {
    return `${" ".repeat(item.depth)}- ${dropWikilinks(item.line)}`;
  }
  renderSuggestion(item, el) {
    super.renderSuggestion(item, el);
    el.innerText = `${" ".repeat(item.item.depth)}- ${dropWikilinks(
      item.item.line
    )}`;
  }
  async deleteItem(item) {
    try {
      this.lines.splice(item.lineNo, 1);
      this.listItems.splice(item.lineNo, 1);
      await app.vault.modify(this.file, this.lines.join("\n"));
      new import_obsidian13.Notice("Item deleted Succesfully");
    } catch (err) {
      (0, import_loglevel15.error)(err);
      new import_obsidian13.Notice("An error occured. Please check the console");
    }
  }
  onChooseItem(item, evt) {
    if (evt instanceof KeyboardEvent && evt.key === "Delete") {
      this.deleteItem(item);
    } else if (evt instanceof KeyboardEvent && evt.key == "Enter" && evt.shiftKey) {
      const view = app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
      const { editor } = view != null ? view : {};
      if (!editor)
        return;
      view.leaf.openFile(this.file, { active: true, mode: "source" });
      editor.setCursor({ line: item.lineNo, ch: item.depth + 2 });
    } else if (evt instanceof KeyboardEvent || evt instanceof MouseEvent) {
      let rel;
      if (evt instanceof MouseEvent && evt.type == "click")
        rel = "down";
      if (evt instanceof KeyboardEvent) {
        if (evt.key === "Enter")
          rel = "down";
      }
      if (evt instanceof KeyboardEvent && evt.shiftKey) {
        if (evt.key === "ArrowUp")
          rel = "up";
        if (evt.key === "ArrowDown")
          rel = "down";
        if (evt.key === "ArrowRight")
          rel = "same";
      }
      new ModifyHierItemModal(
        this.plugin,
        item,
        this.file,
        rel
      ).open();
      this.close();
    }
  }
};

// src/AlternativeHierarchies/HierarchyNotes/HierNoteModal.ts
var HierarchyNoteSelectorModal = class extends import_obsidian14.FuzzySuggestModal {
  constructor(plugin) {
    super(app);
    this.plugin = plugin;
    this.settings = this.plugin.settings;
  }
  onOpen() {
    this.setPlaceholder("HN Chooser");
    const { hierarchyNotes } = this.settings;
    if (hierarchyNotes.length === 0) {
      this.close();
      new import_obsidian14.Notice("No hierarchy notes found");
    } else if (hierarchyNotes.length === 1 && !hierarchyNotes[0].endsWith("/")) {
      this.close();
      new HierarchyNoteManipulator(
        this.plugin,
        hierarchyNotes[0]
      ).open();
    } else {
      super.onOpen();
    }
  }
  getItems() {
    const { hierarchyNotes } = this.settings;
    if (hierarchyNotes.length == 1 && hierarchyNotes[0].endsWith("/")) {
      let folder = hierarchyNotes[0].slice(0, -1);
      if (app.plugins.plugins.dataview != void 0) {
        let pages = app.plugins.plugins.dataview.api.pages(
          `"${folder}"`
        );
        return pages.values.map((page) => page.file.path);
      } else {
        new import_obsidian14.Notice("make sure you have dataview enabled");
      }
    } else
      return hierarchyNotes;
  }
  getItemText(item) {
    return `${item}`;
  }
  renderSuggestion(item, el) {
    super.renderSuggestion(item, el);
  }
  onChooseItem(item, evt) {
    new HierarchyNoteManipulator(this.plugin, item).open();
    this.close();
  }
};

// src/Codeblocks.ts
var import_loglevel16 = __toESM(require_loglevel());
var import_obsidian16 = require("obsidian");

// src/Components/RenderMarkdown.svelte
var import_obsidian15 = require("obsidian");
function add_css7(target) {
  append_styles(target, "svelte-7e9i10", "div.BC-note-content.svelte-7e9i10{padding-left:20px}");
}
function create_fragment9(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "BC-note-content svelte-7e9i10");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[2](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[2](null);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let { path: path2 } = $$props;
  function getContent(note) {
    return __awaiter(this, void 0, void 0, function* () {
      const file = app.metadataCache.getFirstLinkpathDest(note, "");
      return yield app.vault.cachedRead(file);
    });
  }
  let el;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    import_obsidian15.MarkdownRenderer.renderMarkdown(yield getContent(path2), el, path2, null);
  }));
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(1, path2 = $$props2.path);
  };
  return [el, path2, div_binding];
}
var RenderMarkdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { path: 1 }, add_css7);
  }
};
var RenderMarkdown_default = RenderMarkdown;

// src/Components/CBTree.svelte
function add_css8(target) {
  append_styles(target, "svelte-1df5nr5", ".BC-tree.svelte-1df5nr5{padding-left:5px}pre.indent.svelte-1df5nr5{display:inline;background-color:transparent;position:top}details.svelte-1df5nr5{display:inline-block}.is-unresolved.svelte-1df5nr5{color:var(--text-muted)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_if_block_24(ctx) {
  let h3;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      h3 = element("h3");
      t0 = text(
        /*dir*/
        ctx[8]
      );
      t1 = text(" of ");
      t2 = text(
        /*basename*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      append(h3, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*basename*/
      16)
        set_data(
          t2,
          /*basename*/
          ctx2[4]
        );
    },
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
function create_if_block6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*content*/
      ctx2[7] === "open" || /*content*/
      ctx2[7] === "closed"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block3(ctx) {
  let div;
  let pre;
  let t0_value = (
    /*indent*/
    ctx[17] + "-"
  );
  let t0;
  let t1;
  let span;
  let a2;
  let t2_value = dropDendron(
    /*link*/
    ctx[18],
    /*settings*/
    ctx[5]
  ) + "";
  let t2;
  let a_class_value;
  let t3;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[15](
        /*link*/
        ctx[18],
        ...args
      )
    );
  }
  function mouseover_handler_1(...args) {
    return (
      /*mouseover_handler_1*/
      ctx[16](
        /*link*/
        ctx[18],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      a2 = element("a");
      t2 = text(t2_value);
      t3 = space();
      attr(pre, "class", "indent svelte-1df5nr5");
      attr(a2, "class", a_class_value = "internal-link " + (isInVault(
        /*link*/
        ctx[18]
      ) ? "" : "is-unresolved") + " svelte-1df5nr5");
      attr(span, "class", "internal-link");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(div, t1);
      append(div, span);
      append(span, a2);
      append(a2, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler_1),
          listen(span, "mouseover", mouseover_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*lines*/
      1 && t0_value !== (t0_value = /*indent*/
      ctx[17] + "-"))
        set_data(t0, t0_value);
      if (dirty & /*lines*/
      1 && t2_value !== (t2_value = dropDendron(
        /*link*/
        ctx[18],
        /*settings*/
        ctx[5]
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*lines*/
      1 && a_class_value !== (a_class_value = "internal-link " + (isInVault(
        /*link*/
        ctx[18]
      ) ? "" : "is-unresolved") + " svelte-1df5nr5")) {
        attr(a2, "class", a_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let pre;
  let t0_value = (
    /*indent*/
    ctx[17] + ""
  );
  let t0;
  let t1;
  let details2;
  let summary;
  let span;
  let a2;
  let t2_value = dropDendron(
    /*link*/
    ctx[18],
    /*settings*/
    ctx[5]
  ) + "";
  let t2;
  let a_class_value;
  let t3;
  let rendermarkdown;
  let details_open_value;
  let t4;
  let current;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[13](
        /*link*/
        ctx[18],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[14](
        /*link*/
        ctx[18],
        ...args
      )
    );
  }
  rendermarkdown = new RenderMarkdown_default({ props: { path: (
    /*link*/
    ctx[18]
  ) } });
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text(t0_value);
      t1 = space();
      details2 = element("details");
      summary = element("summary");
      span = element("span");
      a2 = element("a");
      t2 = text(t2_value);
      t3 = space();
      create_component(rendermarkdown.$$.fragment);
      t4 = space();
      attr(pre, "class", "indent svelte-1df5nr5");
      attr(a2, "class", a_class_value = "internal-link " + (isInVault(
        /*link*/
        ctx[18]
      ) ? "" : "is-unresolved") + " svelte-1df5nr5");
      attr(span, "class", "internal-link");
      details2.open = details_open_value = /*content*/
      ctx[7] === "open";
      attr(details2, "class", "svelte-1df5nr5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(div, t1);
      append(div, details2);
      append(details2, summary);
      append(summary, span);
      append(span, a2);
      append(a2, t2);
      append(details2, t3);
      mount_component(rendermarkdown, details2, null);
      append(div, t4);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler),
          listen(span, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*lines*/
      1) && t0_value !== (t0_value = /*indent*/
      ctx[17] + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & /*lines*/
      1) && t2_value !== (t2_value = dropDendron(
        /*link*/
        ctx[18],
        /*settings*/
        ctx[5]
      ) + ""))
        set_data(t2, t2_value);
      if (!current || dirty & /*lines*/
      1 && a_class_value !== (a_class_value = "internal-link " + (isInVault(
        /*link*/
        ctx[18]
      ) ? "" : "is-unresolved") + " svelte-1df5nr5")) {
        attr(a2, "class", a_class_value);
      }
      const rendermarkdown_changes = {};
      if (dirty & /*lines*/
      1)
        rendermarkdown_changes.path = /*link*/
        ctx[18];
      rendermarkdown.$set(rendermarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rendermarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rendermarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(rendermarkdown);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block5(ctx) {
  let show_if = meetsConditions(
    /*indent*/
    ctx[17],
    /*link*/
    ctx[18],
    /*froms*/
    ctx[1],
    /*min*/
    ctx[2],
    /*max*/
    ctx[3]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*lines, froms, min, max*/
      15)
        show_if = meetsConditions(
          /*indent*/
          ctx2[17],
          /*link*/
          ctx2[18],
          /*froms*/
          ctx2[1],
          /*min*/
          ctx2[2],
          /*max*/
          ctx2[3]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*lines, froms, min, max*/
          15) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment10(ctx) {
  let t;
  let div;
  let current;
  let if_block = (
    /*title*/
    ctx[6] !== false && create_if_block_24(ctx)
  );
  let each_value = (
    /*lines*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-tree svelte-1df5nr5");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[6] !== false
      )
        if_block.p(ctx2, dirty);
      if (dirty & /*content, lines, openOrSwitch, hoverPreview, activeLeafView, isInVault, dropDendron, settings, meetsConditions, froms, min, max*/
      687) {
        each_value = /*lines*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  ;
  ;
  let { plugin } = $$props;
  let { el } = $$props;
  let { lines } = $$props;
  let { froms } = $$props;
  let { min: min3 } = $$props;
  let { max: max4 } = $$props;
  let { basename } = $$props;
  let { parsedSource } = $$props;
  const { settings } = plugin;
  const { title, content, dir } = parsedSource;
  const activeLeafView = app.workspace.activeLeaf.view;
  const click_handler = async (link2, e) => await openOrSwitch(link2, e);
  const mouseover_handler = (link2, e) => hoverPreview(e, activeLeafView, link2);
  const click_handler_1 = async (link2, e) => await openOrSwitch(link2, e);
  const mouseover_handler_1 = (link2, e) => hoverPreview(e, activeLeafView, link2);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(10, plugin = $$props2.plugin);
    if ("el" in $$props2)
      $$invalidate(11, el = $$props2.el);
    if ("lines" in $$props2)
      $$invalidate(0, lines = $$props2.lines);
    if ("froms" in $$props2)
      $$invalidate(1, froms = $$props2.froms);
    if ("min" in $$props2)
      $$invalidate(2, min3 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max4 = $$props2.max);
    if ("basename" in $$props2)
      $$invalidate(4, basename = $$props2.basename);
    if ("parsedSource" in $$props2)
      $$invalidate(12, parsedSource = $$props2.parsedSource);
  };
  return [
    lines,
    froms,
    min3,
    max4,
    basename,
    settings,
    title,
    content,
    dir,
    activeLeafView,
    plugin,
    el,
    parsedSource,
    click_handler,
    mouseover_handler,
    click_handler_1,
    mouseover_handler_1
  ];
}
var CBTree = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        plugin: 10,
        el: 11,
        lines: 0,
        froms: 1,
        min: 2,
        max: 3,
        basename: 4,
        parsedSource: 12
      },
      add_css8
    );
  }
};
var CBTree_default = CBTree;

// src/Codeblocks.ts
function getCodeblockCB(plugin) {
  const { settings, db } = plugin;
  const { userHiers, createIndexIndent } = settings;
  return (source, el, ctx) => {
    var _a;
    db.start2G("Codeblock");
    const parsedSource = parseCodeBlockSource(source);
    const err = codeblockError(plugin, parsedSource);
    if (err !== "") {
      el.innerHTML = err;
      db.end2G();
      return;
    }
    let min3 = 0, max4 = Infinity;
    let { depth, dir, fields, from, implied, flat } = parsedSource;
    if (depth !== void 0) {
      const minNum = parseInt(depth[0]);
      if (!isNaN(minNum))
        min3 = minNum;
      const maxNum = parseInt(depth[1]);
      if (!isNaN(maxNum))
        max4 = maxNum;
    }
    const currFile = app.metadataCache.getFirstLinkpathDest(
      ctx.sourcePath,
      ""
    );
    const { basename } = currFile;
    let froms = void 0;
    if (from !== void 0) {
      try {
        const api = getDVApi(plugin);
        if (api) {
          const pages = (_a = api.pagePaths(from)) == null ? void 0 : _a.values;
          froms = pages.map(dropFolder);
        } else
          new import_obsidian16.Notice("Dataview must be enabled for `from` to work.");
      } catch (e) {
        new import_obsidian16.Notice(`The query "${from}" failed.`);
      }
    }
    const oppDir = getOppDir(dir);
    const sub = implied === false ? getSubInDirs(plugin.mainG, dir) : getSubInDirs(plugin.mainG, dir, oppDir);
    const closed = getReflexiveClosure(sub, userHiers);
    const subFields = fields != null ? fields : getFields(userHiers);
    const subClosed = getSubForFields(getSubInDirs(closed, dir), subFields);
    const allPaths = dfsAllPaths(subClosed, basename);
    const index2 = createIndex(allPaths, false, createIndexIndent);
    (0, import_loglevel16.info)({ allPaths, index: index2 });
    const lines = indexToLinePairs(index2, flat);
    switch (parsedSource.type) {
      case "tree":
        new CBTree_default({
          target: el,
          props: {
            plugin,
            el,
            min: min3,
            max: max4,
            lines,
            froms,
            basename,
            parsedSource
          }
        });
        break;
      case "juggl":
        createdJugglCB(
          plugin,
          el,
          parsedSource,
          lines,
          froms,
          basename,
          min3,
          max4
        );
        break;
    }
    db.end2G();
  };
}
var parseAsBool = (value) => value === "true" ? true : value === "false" ? false : value;
function parseCodeBlockSource(source) {
  const lines = source.split("\n");
  const getValue = (type2) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = lines.find((l2) => l2.startsWith(`${type2}:`))) == null ? void 0 : _a.split(":")) == null ? void 0 : _b[1]) == null ? void 0 : _c.trim();
  };
  const results = {};
  CODEBLOCK_FIELDS.forEach((field) => {
    const value = getValue(field);
    results[field] = parseAsBool(value);
  });
  results.fields = results.fields ? splitAndTrim(results.fields) : void 0;
  if (results.depth) {
    const match2 = results.depth.match(/(\d*)-?(\d*)/);
    results.depth = [match2[1], match2[2]];
  }
  return results;
}
function codeblockError(plugin, parsedSource) {
  var _a;
  const { dir, fields, type: type2, title, depth, flat, content, from, implied } = parsedSource;
  const { userHiers } = plugin.settings;
  let err = "";
  if (!CODEBLOCK_TYPES.includes(type2))
    err += `<code>type: ${type2}</code> is not a valid type. It must be one of: ${CODEBLOCK_TYPES.map(
      (type3) => `<code>${type3}</code>`
    ).join(", ")}.</br>`;
  const validDir = DIRECTIONS.includes(dir);
  if (!validDir)
    err += `<code>dir: ${dir}</code> is not a valid direction.</br>`;
  const allFields = getFields(userHiers);
  (_a = [fields].flat()) == null ? void 0 : _a.forEach((f) => {
    if (f !== void 0 && !allFields.includes(f))
      err += `<code>fields: ${f}</code> is not a field in your hierarchies.</br>`;
  });
  if (title !== void 0 && title !== false)
    err += `<code>title: ${title}</code> is not a valid value. It has to be <code>false</code>, or leave the entire line out.</br>`;
  if (depth !== void 0 && depth.every((num) => isNaN(parseInt(num))))
    err += `<code>depth: ${depth}</code> is not a valid value. It has to be a number.</br>`;
  if (flat !== void 0 && flat !== true)
    err += `<code>flat: ${flat}</code> is not a valid value. It has to be <code>true</code>, or leave the entire line out.</br>`;
  if (content !== void 0 && content !== "open" && content !== "closed")
    err += `<code>content: ${content}</code> is not a valid value. It has to be <code>open</code> or <code>closed</code>, or leave the entire line out.</br>`;
  if (from !== void 0 && !app.plugins.enabledPlugins.has("dataview")) {
    err += `Dataview must be enabled to use <code>from</code>.</br>`;
  }
  if (implied !== void 0 && implied !== false)
    err += `<code>implied: ${implied}</code> is not a valid value. It has to be <code>false</code>, or leave the entire line out.</br>`;
  return err === "" ? "" : `${err}</br>
    A valid example would be:
    <pre><code>
      type: tree
      dir: ${validDir ? dir : "down"}
      fields: ${allFields.map((f) => {
    return { f, dir: getFieldInfo(userHiers, f).fieldDir };
  }).filter((info14) => info14.dir === dir).map((info14) => info14.f).join(", ") || "child"}
      depth: 3
      </code></pre>`;
}
var indentToDepth = (indent) => indent.length / 2 + 1;
function meetsConditions(indent, node, froms, min3, max4) {
  const depth = indentToDepth(indent);
  return depth >= min3 && depth <= max4 && (froms === void 0 || froms.includes(node));
}
function createdJugglCB(plugin, target, args, lines, froms, source, min3, max4) {
  const nodes = lines.filter(([indent, node]) => meetsConditions(indent, node, froms, min3, max4)).map(([_, node]) => node + ".md");
  if (min3 <= 0)
    nodes.push(source + ".md");
  createJuggl(plugin, target, nodes, args);
}

// src/Commands/jumpToFirstDir.ts
var import_obsidian17 = require("obsidian");
async function jumpToFirstDir(plugin, dir) {
  var _a;
  const { limitJumpToFirstFields } = plugin.settings;
  const file = getCurrFile();
  if (!file) {
    new import_obsidian17.Notice("You need to be focussed on a Markdown file");
    return;
  }
  const { basename } = file;
  const realsNImplieds = getRealnImplied(plugin, basename, dir)[dir];
  const allBCs = [...realsNImplieds.reals, ...realsNImplieds.implieds];
  if (allBCs.length === 0) {
    new import_obsidian17.Notice(`No ${dir} found`);
    return;
  }
  const toNode = (_a = allBCs.find(
    (bc) => limitJumpToFirstFields.includes(bc.field)
  )) == null ? void 0 : _a.to;
  if (!toNode) {
    new import_obsidian17.Notice(
      `No note was found in ${dir} given the limited fields allowed: ${limitJumpToFirstFields.join(
        ", "
      )}`
    );
    return;
  }
  const toFile = app.metadataCache.getFirstLinkpathDest(toNode, "");
  await app.workspace.activeLeaf.openFile(toFile);
}

// src/Commands/threading.ts
var import_obsidian18 = require("obsidian");
var resolveThreadingNameTemplate = (template, currFile, field, dir, dateFormat) => template ? template.replace("{{current}}", currFile.basename).replace("{{field}}", field).replace("{{dir}}", dir).replace("{{date}}", moment().format(dateFormat)) : "Untitled";
function makeFilenameUnique(filename) {
  let i = 1, newName = filename;
  while (app.metadataCache.getFirstLinkpathDest(newName, "")) {
    if (i === 1)
      newName += ` ${i}`;
    else
      newName = newName.slice(0, -2) + ` ${i}`;
    i++;
  }
  return newName;
}
async function resolveThreadingContentTemplate(writeBCsInline, templatePath, oppField, currFile, crumb) {
  let newContent = crumb;
  if (templatePath) {
    const templateFile = app.metadataCache.getFirstLinkpathDest(
      templatePath,
      ""
    );
    const template = await app.vault.cachedRead(templateFile);
    newContent = template.replace(
      /\{\{BC-thread-crumb\}\}/i,
      writeBCsInline ? `${oppField}:: [[${currFile.basename}]]` : `${oppField}: ['${currFile.basename}']`
    );
  }
  return newContent;
}
async function thread(plugin, field) {
  var _a;
  const { settings } = plugin;
  const {
    userHiers,
    threadingTemplate,
    dateFormat,
    threadIntoNewPane,
    threadingDirTemplates,
    threadUnderCursor,
    writeBCsInline
  } = settings;
  const currFile = getCurrFile();
  if (!currFile)
    return;
  const newFileParent = app.fileManager.getNewFileParent(currFile.path);
  const dir = getFieldInfo(userHiers, field).fieldDir;
  const oppField = getOppFields(userHiers, field, dir)[0];
  let newBasename = resolveThreadingNameTemplate(
    threadingTemplate,
    currFile,
    field,
    dir,
    dateFormat
  );
  newBasename = makeFilenameUnique(newBasename);
  const oppCrumb = writeBCsInline ? `${oppField}:: [[${currFile.basename}]]` : `---
${oppField}: ['${currFile.basename}']
---`;
  const templatePath = threadingDirTemplates[dir];
  const newContent = await resolveThreadingContentTemplate(
    writeBCsInline,
    templatePath,
    oppField,
    currFile,
    oppCrumb
  );
  const newFile = await app.vault.create(
    (0, import_obsidian18.normalizePath)(`${newFileParent.path}/${newBasename}.md`),
    newContent
  );
  if (!writeBCsInline) {
    const { api } = (_a = app.plugins.plugins.metaedit) != null ? _a : {};
    if (!api) {
      new import_obsidian18.Notice(
        "Metaedit must be enabled to write to yaml. Alternatively, toggle the setting `Write Breadcrumbs Inline` to use Dataview inline fields instead."
      );
      return;
    }
    await createOrUpdateYaml(
      field,
      newFile.basename,
      currFile,
      app.metadataCache.getFileCache(currFile).frontmatter,
      api
    );
  } else {
    const crumb = `${field}:: [[${newFile.basename}]]`;
    const { editor } = app.workspace.activeLeaf.view;
    if (threadUnderCursor || !editor) {
      editor.replaceRange(crumb, editor.getCursor());
    } else {
      let content = await app.vault.read(currFile);
      const splits = splitAtYaml2(content);
      content = splits[0] + (splits[0].length ? "\n" : "") + crumb + (splits[1].length ? "\n" : "") + splits[1];
      await app.vault.modify(currFile, content);
    }
  }
  const leaf = threadIntoNewPane ? app.workspace.getLeaf(true) : app.workspace.activeLeaf;
  await leaf.openFile(newFile, { active: true, mode: "source" });
  if (templatePath) {
    if (app.plugins.plugins["templater-obsidian"]) {
      app.commands.executeCommandById(
        "templater-obsidian:replace-in-file-templater"
      );
    } else {
      new import_obsidian18.Notice(
        "The Templater plugin must be enabled to resolve the templates in the new note"
      );
    }
  }
  if (threadingTemplate) {
    const editor = leaf.view.editor;
    editor.setCursor(editor.getValue().length);
  } else {
    const noteNameInputs = document.getElementsByClassName("view-header-title");
    const newNoteInputEl = Array.from(noteNameInputs).find(
      (input) => input.innerText === newBasename
    );
    newNoteInputEl.innerText = "";
    newNoteInputEl.focus();
  }
}

// src/Commands/WriteBCs.ts
var import_loglevel17 = __toESM(require_loglevel());
var import_obsidian19 = require("obsidian");
async function writeBCToFile(plugin, currFile) {
  const { settings, mainG } = plugin;
  const file = currFile != null ? currFile : getCurrFile();
  const { limitWriteBCCheckboxes, writeBCsInline, userHiers } = settings;
  const succInfo = mainG.mapInEdges(file.basename, (k, a2, s2, t) => {
    const { field, dir } = a2;
    const oppField = getOppFields(userHiers, field, dir)[0];
    return { succ: s2, field: oppField };
  });
  for (const { succ, field } of succInfo) {
    if (!limitWriteBCCheckboxes.includes(field))
      return;
    const content = await app.vault.read(file);
    const [yaml, afterYaml] = splitAtYaml2(content);
    if (!writeBCsInline) {
      const inner = yaml === "" ? yaml : yaml.slice(4, -4);
      const newYaml = changeYaml(inner, field, succ);
      const newContent = `---
${newYaml}
---${afterYaml}`;
      await app.vault.modify(file, newContent);
    } else {
      const newContent = yaml + (yaml.length ? "\n" : "") + `${field}:: [[${succ}]]` + (afterYaml.length ? "\n" : "") + afterYaml;
      await app.vault.modify(file, newContent);
    }
  }
}
async function writeBCsToAllFiles(plugin) {
  if (!plugin.settings.showWriteAllBCsCmd) {
    new import_obsidian19.Notice(
      "You first need to enable this command in Breadcrumbs' settings."
    );
    return;
  }
  if (window.confirm(
    "This action will write the implied Breadcrumbs of each file to that file.\nIt uses the MetaEdit plugins API to update the YAML, so it should only affect that frontmatter of your note.\nI can't promise that nothing bad will happen. **This operation cannot be undone**."
  )) {
    if (window.confirm(
      "Are you sure? You have been warned that this operation will attempt to update all files with implied breadcrumbs."
    )) {
      if (window.confirm("For real, please make a back up before.")) {
        const notice = new import_obsidian19.Notice("Operation Started");
        const problemFiles = [];
        for (const file of app.vault.getMarkdownFiles()) {
          try {
            await writeBCToFile(plugin, file);
          } catch (e) {
            problemFiles.push(file.path);
          }
        }
        notice.setMessage("Operation Complete");
        if (problemFiles.length) {
          new import_obsidian19.Notice(
            "Some files were not updated due to errors. Check the console to see which ones."
          );
          (0, import_loglevel17.warn)({ problemFiles });
        }
      }
    }
  }
}

// src/FieldSuggestor.ts
var import_obsidian20 = require("obsidian");
var FieldSuggestor = class extends import_obsidian20.EditorSuggest {
  constructor(plugin) {
    super(app);
    this.getSuggestions = (context) => {
      const { query } = context;
      return BC_FIELDS_INFO.map((sug) => sug.field).filter(
        (sug) => sug.includes(query)
      );
    };
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, _) {
    var _a;
    const sub = editor.getLine(cursor.line).substring(0, cursor.ch);
    const match2 = (_a = sub.match(/^BC-(.*)$/)) == null ? void 0 : _a[1];
    if (match2 !== void 0) {
      return {
        end: cursor,
        start: {
          ch: sub.lastIndexOf(match2),
          line: cursor.line
        },
        query: match2
      };
    }
    return null;
  }
  renderSuggestion(suggestion, el) {
    var _a;
    el.createDiv({
      text: suggestion.replace("BC-", ""),
      cls: "BC-suggester-container",
      attr: {
        "aria-label": (_a = BC_FIELDS_INFO.find((f) => f.field === suggestion)) == null ? void 0 : _a.desc,
        "aria-label-position": "right"
      }
    });
  }
  selectSuggestion(suggestion) {
    const { context, plugin } = this;
    if (!context)
      return;
    const field = BC_FIELDS_INFO.find((f) => f.field === suggestion);
    const replacement = `${suggestion}${field == null ? void 0 : field[isInsideYaml() ? "afterYaml" : "afterInline"]}`;
    context.editor.replaceRange(
      replacement,
      { ch: 0, line: context.start.line },
      context.end
    );
  }
};

// src/RelationSuggestor.ts
var import_obsidian21 = require("obsidian");
var RelationSuggestor = class extends import_obsidian21.EditorSuggest {
  constructor(plugin) {
    super(app);
    this.getSuggestions = (context) => {
      const { query } = context;
      const { userHiers } = this.plugin.settings;
      return getFields(userHiers).filter((sug) => sug.includes(query));
    };
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, _) {
    var _a;
    const trig = this.plugin.settings.relSuggestorTrigger;
    const sub = editor.getLine(cursor.line).substring(0, cursor.ch);
    const regex = new RegExp(`.*?${escapeRegex(trig)}(.*)$`);
    const match2 = (_a = regex.exec(sub)) == null ? void 0 : _a[1];
    if (match2 === void 0)
      return null;
    return {
      start: {
        ch: sub.lastIndexOf(trig),
        line: cursor.line
      },
      end: cursor,
      query: match2
    };
  }
  renderSuggestion(suggestion, el) {
    el.createDiv({
      text: suggestion,
      cls: "codeblock-suggestion"
    });
  }
  selectSuggestion(suggestion) {
    const { context, plugin } = this;
    if (!context)
      return;
    const trig = plugin.settings.relSuggestorTrigger;
    const { start: start2, end, editor } = context;
    const replacement = suggestion + (isInsideYaml() ? ": " : ":: ") + "[[";
    editor.replaceRange(
      replacement,
      { ch: start2.ch + 1 - trig.length, line: start2.line },
      end
    );
  }
};

// src/Settings/BreadcrumbsSettingTab.ts
var import_obsidian40 = require("obsidian");

// src/Components/KoFi.svelte
function add_css9(target) {
  append_styles(target, "svelte-1j4tt4j", ".BC-Kofi-button.svelte-1j4tt4j{margin-top:10px}");
}
function create_fragment11(ctx) {
  let script;
  let script_src_value;
  let t;
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      script = element("script");
      t = space();
      div = element("div");
      attr(script, "type", "text/javascript");
      if (!src_url_equal(script.src, script_src_value = "https://ko-fi.com/widgets/widget_2.js"))
        attr(script, "src", script_src_value);
      attr(div, "class", "BC-Kofi-button svelte-1j4tt4j");
    },
    m(target, anchor) {
      append(document.head, script);
      insert(target, t, anchor);
      insert(target, div, anchor);
      ctx[2](div);
      if (!mounted) {
        dispose = listen(
          script,
          "load",
          /*initializeKofi*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      detach(script);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      ctx[2](null);
      mounted = false;
      dispose();
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let button;
  const initializeKofi = () => {
    kofiwidget2.init("Support Breadcrumbs development!", "#29abe0", "G2G454TZF");
    $$invalidate(0, button.innerHTML = kofiwidget2.getHTML(), button);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      button = $$value;
      $$invalidate(0, button);
    });
  }
  return [button, initializeKofi, div_binding];
}
var KoFi = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {}, add_css9);
  }
};
var KoFi_default = KoFi;

// src/Settings/CreateIndexSettings.ts
var import_obsidian22 = require("obsidian");
function addCreateIndexSettings(plugin, cmdsDetails) {
  const { settings } = plugin;
  const createIndexDetails = subDetails("Create Index", cmdsDetails);
  new import_obsidian22.Setting(createIndexDetails).setName("Add wiklink brackets").setDesc(
    fragWithHTML(
      "When creating an index, should it wrap the note name in wikilinks <code>[[]]</code> or not.\n\u2705 = yes, \u274C = no."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.wikilinkIndex).onChange(async (value) => {
      settings.wikilinkIndex = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian22.Setting(createIndexDetails).setName("Indent Character").setDesc(
    fragWithHTML(
      "The character(s) used to indent the index. These can be anything you want, but will usually be either spaces or tabs. Enter <code>\\t</code> to use tabs."
    )
  ).addText((text2) => {
    text2.setValue(settings.createIndexIndent).onChange(async (value) => {
      settings.createIndexIndent = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian22.Setting(createIndexDetails).setName("Show aliases of notes in index").setDesc("Show the aliases of each note in brackets.\n\u2705 = yes, \u274C = no.").addToggle(
    (toggle) => toggle.setValue(settings.aliasesInIndex).onChange(async (value) => {
      settings.aliasesInIndex = value;
      await plugin.saveSettings();
    })
  );
}

// src/Settings/CSVSettings.ts
var import_obsidian23 = require("obsidian");
function addCSVSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const csvDetails = subDetails("CSV Notes", alternativeHierarchyDetails);
  new import_obsidian23.Setting(csvDetails).setName("CSV Breadcrumb Paths").setDesc("The file path of a csv files with breadcrumbs information.").addText((text2) => {
    text2.setValue(settings.CSVPaths);
    text2.inputEl.onblur = async () => {
      settings.CSVPaths = text2.inputEl.value;
      await plugin.saveSettings();
    };
  });
}

// src/Settings/DataviewNoteSettings.ts
var import_obsidian24 = require("obsidian");
function addDataviewSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  const dvDetails = subDetails("Dataview Notes", alternativeHierarchyDetails);
  new import_obsidian24.Setting(dvDetails).setName("Default Dataview Note Field").setDesc(
    fragWithHTML(
      "By default, Dataview notes use the first field in your hierarchies (usually an <code>\u2191</code> field). Choose a different one to use by default, without having to specify <code>BC-dataview-note-field: {field}</code>.</br>If you don't want to choose a default, select the blank option at the bottom of the list."
    )
  ).addDropdown((dd) => {
    fields.forEach((field) => dd.addOption(field, field));
    dd.addOption("", "").setValue(settings.dataviewNoteField).onChange(async (field) => {
      settings.dataviewNoteField = field;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Settings/DateNoteSettings.ts
var import_obsidian25 = require("obsidian");
function addDateNoteSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  const fieldOptions = { "": "" };
  fields.forEach((field) => fieldOptions[field] = field);
  const dateNoteDetails = subDetails("Date Notes", alternativeHierarchyDetails);
  new import_obsidian25.Setting(dateNoteDetails).setName("Add Date Notes to Graph").setDesc(
    "Breadcrumbs will try to link each daily note to the next one using the date format you provide in the settings below."
  ).addToggle((toggle) => {
    toggle.setValue(settings.addDateNotes).onChange(async (value) => {
      settings.addDateNotes = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
  new import_obsidian25.Setting(dateNoteDetails).setName("Daily Note Format").setDesc(
    fragWithHTML(
      `The Luxon date format of your daily notes.</br><strong>Note</strong>: Luxon uses different formats to Moment, so your format for the Daily Notes plugin may not work here. Be sure to check out <a href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">the docs</a> to find the right format.<br>You can escape characters by wrapping them in single quotes (e.g. <code>yyyy-MM-dd 'Daily Note'</code>)`
    )
  ).addText((text2) => {
    text2.setValue(settings.dateNoteFormat);
    text2.inputEl.onblur = async () => {
      settings.dateNoteFormat = text2.getValue();
      await plugin.saveSettings();
      await refreshIndex(plugin);
    };
  });
  new import_obsidian25.Setting(dateNoteDetails).setName("Date Note Field").setDesc(
    fragWithHTML(
      "Select a field to point to tomorrow's note from the current note. The opposite field will be used to point to yesterday's note."
    )
  ).addDropdown((dd) => {
    dd.addOptions(fieldOptions).setValue(settings.dateNoteField).onChange(async (field) => {
      settings.dateNoteField = field;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Settings/DebuggingSettings.ts
var import_loglevel18 = __toESM(require_loglevel());
var import_obsidian26 = require("obsidian");
function addDebuggingsSettings(plugin, containerEl) {
  const { settings } = plugin;
  const debugDetails = details("Debugging", containerEl);
  new import_obsidian26.Setting(debugDetails).setName("Debug Mode").setDesc(
    fragWithHTML(
      "Set the minimum level of debug messages to console log. If you choose <code>TRACE</code>, then everything will be logged. If you choose <code>ERROR</code>, then only the most necessary issues will be logged. <code>SILENT</code> will turn off all logs."
    )
  ).addDropdown((dd) => {
    Object.keys(import_loglevel18.default.levels).forEach((key) => dd.addOption(key, key));
    dd.setValue(settings.debugMode).onChange(async (value) => {
      import_loglevel18.default.setLevel(value);
      settings.debugMode = value;
      await plugin.saveSettings();
    });
  });
  debugDetails.createEl("button", { text: "Console log settings" }, (el) => {
    el.addEventListener("click", () => console.log(settings));
  });
}

// src/Settings/DendronSettings.ts
var import_obsidian27 = require("obsidian");
function addDendronSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  const dendronDetails = subDetails(
    "Dendron Notes",
    alternativeHierarchyDetails
  );
  new import_obsidian27.Setting(dendronDetails).setName("Add Dendron notes to graph").setDesc(
    fragWithHTML(
      "Dendron notes create a hierarchy using note names.</br><code>nmath.algebra</code> is a note about algebra, whose parent is <code>math</code>.</br><code>nmath.calculus.limits</code> is a note about limits whose parent is the note <code>math.calculus</code>, the parent of which is <code>math</code>."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.addDendronNotes).onChange(async (value) => {
      settings.addDendronNotes = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian27.Setting(dendronDetails).setName("Delimiter").setDesc(
    fragWithHTML(
      "Which delimiter should Breadcrumbs look for? The default is <code>.</code>."
    )
  ).addText((text2) => {
    text2.setPlaceholder("Delimiter").setValue(settings.dendronNoteDelimiter);
    text2.inputEl.onblur = async () => {
      const value = text2.getValue();
      if (value)
        settings.dendronNoteDelimiter = value;
      else {
        new import_obsidian27.Notice(`The delimiter can't be blank`);
        settings.dendronNoteDelimiter = DEFAULT_SETTINGS.dendronNoteDelimiter;
      }
      await plugin.saveSettings();
    };
  });
  new import_obsidian27.Setting(dendronDetails).setName("Trim Dendron Note Names").setDesc(
    fragWithHTML(
      "When displaying a dendron note name, should it be trimmed to only show the last item in the chain?</br>e.g. <code>A.B.C</code> \u2192 <code>C</code>."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.trimDendronNotes).onChange(async (value) => {
      settings.trimDendronNotes = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian27.Setting(dendronDetails).setName("Dendron Note Field").setDesc("Which field should Breadcrumbs use for Dendron notes?").addDropdown((dd) => {
    fields.forEach((field) => dd.addOption(field, field));
    dd.setValue(settings.dendronNoteField);
    dd.onChange(async (value) => {
      settings.dendronNoteField = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Settings/GeneralSettings.ts
var import_obsidian28 = require("obsidian");
function addGeneralSettings(plugin, containerEl) {
  const { settings } = plugin;
  const generalDetails = details("General Options", containerEl);
  new import_obsidian28.Setting(generalDetails).setName("Refresh Index on Note Change").setDesc(
    fragWithHTML(
      "Refresh the Breadcrumbs index data everytime you change notes.</br><strong>Note</strong>: This can be very slow on large vaults."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.refreshOnNoteChange).onChange(async (value) => {
      settings.refreshOnNoteChange = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Refresh Index On Note Save").addToggle(
    (toggle) => toggle.setValue(settings.refreshOnNoteSave).onChange(async (value) => {
      settings.refreshOnNoteSave = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Show Refresh Index Notice").setDesc(
    "When Refreshing Index, should it show a notice once the operation is complete?"
  ).addToggle(
    (toggle) => toggle.setValue(settings.showRefreshNotice).onChange(async (value) => {
      settings.showRefreshNotice = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Alias Fields").setDesc(
    fragWithHTML(
      "A comma-separated list of fields used to specify aliases. These fields will be checked, in order, to display an alternate note title in different views.</br>This field will probably be <code>alias</code> or <code>aliases</code>, but it can be anything, like <code>title</code>."
    )
  ).addText((text2) => {
    text2.setValue(settings.altLinkFields.join(", "));
    text2.inputEl.onblur = async () => {
      settings.altLinkFields = splitAndTrim(text2.getValue());
      await plugin.saveSettings();
    };
  });
  new import_obsidian28.Setting(generalDetails).setName("Only show first alias").setDesc(
    "If a note has an alias (using the fields in the setting above), should only the first one be shown?"
  ).addToggle(
    (toggle) => toggle.setValue(!settings.showAllAliases).onChange(async (value) => {
      settings.showAllAliases = !value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Use yaml or inline fields for hierarchy data").setDesc(
    "If enabled, Breadcrumbs will make it's hierarchy using yaml fields, and inline Dataview fields.\nIf this is disabled, it will only use Juggl links (See below)."
  ).addToggle(
    (toggle) => toggle.setValue(settings.useAllMetadata).onChange(async (value) => {
      settings.useAllMetadata = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Use Juggl link syntax without having Juggl installed.").setDesc(
    fragWithHTML(
      `Should Breadcrumbs look for <a href="https://juggl.io/Link+Types" aria-label="https://juggl.io/Link+Types">Juggl links</a> even if you don't have Juggl installed? If you do have Juggl installed, it will always look for Juggl links.`
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.parseJugglLinksWithoutJuggl).onChange(async (value) => {
      settings.parseJugglLinksWithoutJuggl = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Enable Field Suggestor").setDesc(
    fragWithHTML(
      "Alot of Breadcrumbs features require a metadata (or inline Dataview) field to work. For example, `BC-folder-note`.</br>The Field Suggestor will show an autocomplete menu with all available Breadcrumbs field options when you type <code>BC-</code> at the start of a line."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.fieldSuggestor).onChange(async (value) => {
      settings.fieldSuggestor = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Enable Relation Suggestor").setDesc(
    fragWithHTML(
      "Enable an editor suggestor which gets triggered by a custom string to show a list of relations from your hierarchies to insert."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.enableRelationSuggestor).onChange(async (value) => {
      settings.enableRelationSuggestor = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian28.Setting(generalDetails).setName("Relation Suggestor Trigger").setDesc(
    fragWithHTML(
      "The string used to trigger the relation suggestor. Default is <code>\\</code>."
    )
  ).addText(
    (text2) => text2.setValue(settings.relSuggestorTrigger).onChange(async (value) => {
      settings.relSuggestorTrigger = value;
      await plugin.saveSettings();
    })
  );
  if (app.plugins.plugins.dataview !== void 0) {
    new import_obsidian28.Setting(generalDetails).setName("Dataview Wait Time").setDesc(
      "Enter an integer number of seconds to wait for the Dataview Index to load. The larger your vault, the longer it will take. The default is 5 seconds."
    ).addText(
      (text2) => text2.setPlaceholder("Seconds").setValue((settings.dvWaitTime / 1e3).toString()).onChange(async (value) => {
        const num = Number(value);
        if (num > 0) {
          settings.dvWaitTime = num * 1e3;
          await plugin.saveSettings();
        } else {
          new import_obsidian28.Notice("The interval must be a non-negative number");
        }
      })
    );
  }
}

// src/Settings/HierarchyNoteSettings.ts
var import_obsidian29 = require("obsidian");
function addHierarchyNoteSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const hierarchyNoteDetails = subDetails(
    "Hierarchy Notes",
    alternativeHierarchyDetails
  );
  new import_obsidian29.Setting(hierarchyNoteDetails).setName("Hierarchy Note(s)").setDesc(
    fragWithHTML(
      "A comma-separated list of notes used to create external Breadcrumb structures.<br>You can also point to a <em>folder</em> of hierarchy notes by entering <code>folderName/</code> (ending with a <code>/</code>).<br>Hierarchy note names and folders of hierarchy notes can both be entered in the same comma-separated list."
    )
  ).addText((text2) => {
    text2.setPlaceholder("Hierarchy Note(s)").setValue(settings.hierarchyNotes.join(", "));
    text2.inputEl.onblur = async () => {
      const splits = splitAndTrim(text2.getValue());
      settings.hierarchyNotes = splits;
      await plugin.saveSettings();
    };
  });
  new import_obsidian29.Setting(hierarchyNoteDetails).setName("Hierarchy note is parent of top-level items").setDesc("Should the actual hierarchy note be treated as the parent of all the top-level items in the list? \u2705 = Yes, \u274C = No").addToggle((toggle) => {
    toggle.setValue(settings.hierarchyNoteIsParent).onChange(async (value) => {
      settings.hierarchyNoteIsParent = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
  new import_obsidian29.Setting(hierarchyNoteDetails).setName("Default Hierarchy Note Field").setDesc(
    fragWithHTML(
      "By default, hierarchy notes use the first <code>up</code> field in your hierarchies. Choose a different one to use by default. If you don't want to choose a default, select the blank option at the bottom of the list."
    )
  ).addDropdown((dd) => {
    const upFields = getFields(settings.userHiers, "up");
    const options = {};
    upFields.forEach(
      (field) => options[field] = field
    );
    dd.addOptions(options).setValue(settings.HNUpField || upFields[0]).onChange(async (field) => {
      settings.HNUpField = field;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Components/UserHierarchies.svelte
var import_obsidian30 = require("obsidian");

// node_modules/svelte-icons/components/IconBase.svelte
function add_css10(target) {
  append_styles(target, "svelte-c8tyih", "svg.svelte-c8tyih{stroke:currentColor;fill:currentColor;stroke-width:0;width:100%;height:auto;max-height:100%}");
}
function create_if_block7(ctx) {
  let title_1;
  let t;
  return {
    c() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, title_1, anchor);
      append(title_1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*title*/
      1)
        set_data(
          t,
          /*title*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching)
        detach(title_1);
    }
  };
}
function create_fragment12(ctx) {
  let svg;
  let if_block_anchor;
  let current;
  let if_block = (
    /*title*/
    ctx[0] && create_if_block7(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[1]
      );
      attr(svg, "class", "svelte-c8tyih");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append(svg, if_block_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(svg, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*viewBox*/
      2) {
        attr(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svg);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = null } = $$props;
  let { viewBox } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("viewBox" in $$props2)
      $$invalidate(1, viewBox = $$props2.viewBox);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [title, viewBox, $$scope, slots];
}
var IconBase = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, { title: 0, viewBox: 1 }, add_css10);
  }
};
var IconBase_default = IconBase;

// node_modules/svelte-icons/fa/FaListUl.svelte
function create_default_slot(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment13(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 512 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaListUl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var FaListUl_default = FaListUl;

// node_modules/svelte-icons/fa/FaPlus.svelte
function create_default_slot2(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment14(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 448 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaPlus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var FaPlus_default = FaPlus;

// node_modules/svelte-icons/fa/FaRegTrashAlt.svelte
function create_default_slot3(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M268 416h24a12 12 0 0 0 12-12V188a12 12 0 0 0-12-12h-24a12 12 0 0 0-12 12v216a12 12 0 0 0 12 12zM432 80h-82.41l-34-56.7A48 48 0 0 0 274.41 0H173.59a48 48 0 0 0-41.16 23.3L98.41 80H16A16 16 0 0 0 0 96v16a16 16 0 0 0 16 16h16v336a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128h16a16 16 0 0 0 16-16V96a16 16 0 0 0-16-16zM171.84 50.91A6 6 0 0 1 177 48h94a6 6 0 0 1 5.15 2.91L293.61 80H154.39zM368 464H80V128h288zm-212-48h24a12 12 0 0 0 12-12V188a12 12 0 0 0-12-12h-24a12 12 0 0 0-12 12v216a12 12 0 0 0 12 12z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment15(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 448 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaRegTrashAlt = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var FaRegTrashAlt_default = FaRegTrashAlt;

// src/Components/UserHierarchies.svelte
function add_css11(target) {
  append_styles(target, "svelte-1e9on6f", "label.BC-Arrow-Label.svelte-1e9on6f.svelte-1e9on6f{display:inline-block;width:20px !important}div.BC-Buttons.svelte-1e9on6f.svelte-1e9on6f{padding-bottom:5px}details.BC-Hier-Details.svelte-1e9on6f.svelte-1e9on6f{border:1px solid var(--background-modifier-border);border-radius:10px;padding:10px 5px 10px 10px;margin-bottom:15px}.BC-Hier-Details.svelte-1e9on6f summary.svelte-1e9on6f::marker{font-size:10px}.BC-Hier-Details.svelte-1e9on6f summary button.svelte-1e9on6f{float:right}.icon.svelte-1e9on6f.svelte-1e9on6f{color:var(--text-normal);display:inline-block;padding-top:3px;width:17px;height:17px}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context_15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_each_block_15(ctx) {
  let div;
  let label;
  let t0_value = ARROW_DIRECTIONS[
    /*dir*/
    ctx[16]
  ] + "";
  let t0;
  let label_for_value;
  let t1;
  let input;
  let input_name_value;
  let input_value_value;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx[11](
        /*i*/
        ctx[15],
        /*dir*/
        ctx[16],
        ...args
      )
    );
  }
  return {
    c() {
      var _a, _b;
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(label, "class", "BC-Arrow-Label svelte-1e9on6f");
      attr(label, "for", label_for_value = /*dir*/
      ctx[16]);
      attr(input, "type", "text");
      attr(input, "size", "20");
      attr(input, "name", input_name_value = /*dir*/
      ctx[16]);
      input.value = input_value_value = /*hier*/
      (_b = (_a = ctx[13][
        /*dir*/
        ctx[16]
      ]) == null ? void 0 : _a.join(", ")) != null ? _b : "";
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(div, t1);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a, _b;
      ctx = new_ctx;
      if (dirty & /*currHiers*/
      2 && input_value_value !== (input_value_value = /*hier*/
      (_b = (_a = ctx[13][
        /*dir*/
        ctx[16]
      ]) == null ? void 0 : _a.join(", ")) != null ? _b : "") && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block6(ctx) {
  let details2;
  let summary;
  let t0_value = DIRECTIONS.map(func).map(func_1).join(" ") + "";
  let t0;
  let t1;
  let span;
  let button0;
  let t3;
  let button1;
  let t5;
  let button2;
  let t7;
  let t8;
  let mounted;
  let dispose;
  function func(...args) {
    return (
      /*func*/
      ctx[7](
        /*hier*/
        ctx[13],
        ...args
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[8](
        /*i*/
        ctx[15]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[9](
        /*i*/
        ctx[15]
      )
    );
  }
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[10](
        /*i*/
        ctx[15]
      )
    );
  }
  let each_value_1 = DIRECTIONS;
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));
  }
  return {
    c() {
      details2 = element("details");
      summary = element("summary");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      button0 = element("button");
      button0.textContent = "\u2191";
      t3 = space();
      button1 = element("button");
      button1.textContent = "\u2193";
      t5 = space();
      button2 = element("button");
      button2.textContent = "X";
      t7 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t8 = space();
      attr(button0, "aria-label", "Swap with Hierarchy Above");
      attr(button0, "class", "svelte-1e9on6f");
      attr(button1, "aria-label", "Swap with Hierarchy Below");
      attr(button1, "class", "svelte-1e9on6f");
      attr(button2, "aria-label", "Remove Hierarchy");
      attr(button2, "class", "svelte-1e9on6f");
      attr(span, "class", "BC-Buttons");
      attr(summary, "class", "svelte-1e9on6f");
      attr(details2, "class", "BC-Hier-Details svelte-1e9on6f");
    },
    m(target, anchor) {
      insert(target, details2, anchor);
      append(details2, summary);
      append(summary, t0);
      append(summary, t1);
      append(summary, span);
      append(span, button0);
      append(span, t3);
      append(span, button1);
      append(span, t5);
      append(span, button2);
      append(details2, t7);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(details2, null);
        }
      }
      append(details2, t8);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_3),
          listen(button1, "click", click_handler_4),
          listen(button2, "click", click_handler_5)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*currHiers*/
      2 && t0_value !== (t0_value = DIRECTIONS.map(func).map(func_1).join(" ") + ""))
        set_data(t0, t0_value);
      if (dirty & /*DIRECTIONS, currHiers, splitAndTrim, update, settings, plugin, ARROW_DIRECTIONS*/
      15) {
        each_value_1 = DIRECTIONS;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_15(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_15(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(details2, t8);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(details2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment16(ctx) {
  let div4;
  let div3;
  let button0;
  let div0;
  let faplus;
  let t0;
  let button1;
  let div1;
  let faregtrashalt;
  let t1;
  let button2;
  let div2;
  let falistul;
  let t2;
  let current;
  let mounted;
  let dispose;
  faplus = new FaPlus_default({});
  faregtrashalt = new FaRegTrashAlt_default({});
  falistul = new FaListUl_default({});
  let each_value = (
    /*currHiers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      button0 = element("button");
      div0 = element("div");
      create_component(faplus.$$.fragment);
      t0 = space();
      button1 = element("button");
      div1 = element("div");
      create_component(faregtrashalt.$$.fragment);
      t1 = space();
      button2 = element("button");
      div2 = element("div");
      create_component(falistul.$$.fragment);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "icon svelte-1e9on6f");
      attr(button0, "aria-label", "Add New Hierarchy");
      attr(div1, "class", "icon svelte-1e9on6f");
      attr(button1, "aria-label", "Reset All Hierarchies");
      attr(div2, "class", "icon svelte-1e9on6f");
      attr(button2, "aria-label", "Show Hierarchies");
      attr(div3, "class", "BC-Buttons svelte-1e9on6f");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, button0);
      append(button0, div0);
      mount_component(faplus, div0, null);
      append(div3, t0);
      append(div3, button1);
      append(button1, div1);
      mount_component(faregtrashalt, div1, null);
      append(div3, t1);
      append(div3, button2);
      append(button2, div2);
      mount_component(falistul, div2, null);
      append(div4, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*DIRECTIONS, currHiers, splitAndTrim, update, settings, plugin, ARROW_DIRECTIONS, swapItems*/
      15) {
        each_value = /*currHiers*/
        ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div4, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(faplus.$$.fragment, local);
      transition_in(faregtrashalt.$$.fragment, local);
      transition_in(falistul.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(faplus.$$.fragment, local);
      transition_out(faregtrashalt.$$.fragment, local);
      transition_out(falistul.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(faplus);
      destroy_component(faregtrashalt);
      destroy_component(falistul);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
var func_1 = (dirFields) => `(${dirFields})`;
function instance16($$self, $$props, $$invalidate) {
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  ;
  ;
  let { plugin } = $$props;
  const { settings } = plugin;
  let currHiers = [...plugin.settings.userHiers];
  function update2(currHiers2) {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(0, plugin.settings.userHiers = currHiers2, plugin);
      yield plugin.saveSettings();
    });
  }
  const click_handler = async () => $$invalidate(1, currHiers = [...currHiers, blankUserHier()]);
  const click_handler_1 = async () => {
    if (window.confirm("Are you sure you want to reset all hierarchies?")) {
      $$invalidate(1, currHiers = []);
      await update2(currHiers);
    }
  };
  const click_handler_2 = () => new import_obsidian30.Notice(currHiers.map(hierToStr).join("\n\n"));
  const func = (hier, dir) => {
    var _a, _b;
    return (_b = (_a = hier[dir]) == null ? void 0 : _a.join(", ")) != null ? _b : "";
  };
  const click_handler_3 = async (i) => {
    $$invalidate(1, currHiers = swapItems(i, i - 1, currHiers));
    await update2(currHiers);
  };
  const click_handler_4 = async (i) => {
    $$invalidate(1, currHiers = swapItems(i, i + 1, currHiers));
    await update2(currHiers);
  };
  const click_handler_5 = async (i) => {
    const oldHier = currHiers.splice(i, 1)[0];
    oldHier.up.forEach((upField) => {
      const index2 = settings.limitTrailCheckboxes.indexOf(upField);
      if (index2 > -1)
        settings.limitTrailCheckboxes.splice(index2, 1);
    });
    DIRECTIONS.forEach((dir) => {
      oldHier[dir].forEach((field) => {
        const indexI = settings.limitJumpToFirstFields.indexOf(field);
        if (indexI > -1)
          settings.limitJumpToFirstFields.splice(indexI, 1);
        const indexJ = settings.limitWriteBCCheckboxes.indexOf(field);
        if (indexJ > -1)
          settings.limitJumpToFirstFields.splice(indexJ, 1);
      });
    });
    $$invalidate(1, currHiers);
    await update2(currHiers);
  };
  const change_handler = async (i, dir, e) => {
    const { value } = e.target;
    const splits = splitAndTrim(value);
    $$invalidate(1, currHiers[i][dir] = splits, currHiers);
    await update2(currHiers);
    splits.forEach((split) => {
      if (dir === "up" && !settings.limitTrailCheckboxes.includes(split))
        settings.limitTrailCheckboxes.push(split);
      if (!settings.limitJumpToFirstFields.includes(split))
        settings.limitJumpToFirstFields.push(split);
      if (!settings.limitWriteBCCheckboxes.includes(split))
        settings.limitWriteBCCheckboxes.push(split);
    });
    await plugin.saveSettings();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    currHiers,
    settings,
    update2,
    click_handler,
    click_handler_1,
    click_handler_2,
    func,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    change_handler
  ];
}
var UserHierarchies = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { plugin: 0 }, add_css11);
  }
};
var UserHierarchies_default = UserHierarchies;

// src/Settings/HierarchySettings.ts
function addHierarchySettings(plugin, containerEl) {
  const fieldDetails = details("Hierarchies", containerEl);
  fieldDetails.createEl("p", {
    text: "Here you can set up different hierarchies you use in your vault. To add a new hierarchy, click the plus button. Then, fill in the field names of your hierachy into the 5 boxes that appear."
  });
  fieldDetails.createEl("p", {
    text: "For each direction, you can enter multiple field names in a comma-seperated list. For example: `parent, broader, upper`"
  });
  new UserHierarchies_default({
    target: fieldDetails,
    props: { plugin }
  });
}

// src/Components/Checkboxes.svelte
var import_loglevel19 = __toESM(require_loglevel());
function add_css12(target) {
  append_styles(target, "svelte-d1my4i", ".grid.svelte-d1my4i{display:grid;grid-template-columns:repeat(auto-fit, minmax(100px, 1fr))}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let div;
  let label;
  let input;
  let input_value_value;
  let value_has_changed = false;
  let t0;
  let t1_value = (
    /*option*/
    ctx[12] + ""
  );
  let t1;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[8][0]
  );
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      input.__value = input_value_value = /*option*/
      ctx[12];
      input.value = input.__value;
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ~/*selected*/
      (ctx[1] || []).indexOf(input.__value);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[7]
          ),
          listen(
            input,
            "change",
            /*change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      1 && input_value_value !== (input_value_value = /*option*/
      ctx2[12])) {
        input.__value = input_value_value;
        input.value = input.__value;
        value_has_changed = true;
      }
      if (value_has_changed || dirty & /*selected, options*/
      3) {
        input.checked = ~/*selected*/
        (ctx2[1] || []).indexOf(input.__value);
      }
      if (dirty & /*options*/
      1 && t1_value !== (t1_value = /*option*/
      ctx2[12] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment17(ctx) {
  let div0;
  let button;
  let t0;
  let t1_value = (
    /*toNone*/
    ctx[2] ? "None" : "All"
  );
  let t1;
  let t2;
  let div1;
  let mounted;
  let dispose;
  let each_value = (
    /*options*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  return {
    c() {
      div0 = element("div");
      button = element("button");
      t0 = text("Select ");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div1, "class", "grid svelte-d1my4i");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, button);
      append(button, t0);
      append(button, t1);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*toNone*/
      4 && t1_value !== (t1_value = /*toNone*/
      ctx2[2] ? "None" : "All"))
        set_data(t1, t1_value);
      if (dirty & /*options, selected, save*/
      11) {
        each_value = /*options*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let toNone;
  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  ;
  let { plugin } = $$props;
  let { settingName } = $$props;
  let { options } = $$props;
  const { settings } = plugin;
  let selected = settings[settingName];
  function save() {
    return __awaiter(this, void 0, void 0, function* () {
      if (settings[settingName] === void 0)
        return (0, import_loglevel19.warn)(settingName + " not found in BC settings");
      settings[settingName] = selected;
      yield plugin.saveSettings();
      yield refreshIndex(plugin);
    });
  }
  const $$binding_groups = [[]];
  const click_handler = async () => {
    if (toNone)
      $$invalidate(1, selected = []);
    else
      $$invalidate(1, selected = options);
    await save();
  };
  function input_change_handler() {
    selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    $$invalidate(1, selected);
  }
  const change_handler = async () => await save();
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(4, plugin = $$props2.plugin);
    if ("settingName" in $$props2)
      $$invalidate(5, settingName = $$props2.settingName);
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected*/
    2) {
      $:
        $$invalidate(2, toNone = selected.length === 0 ? false : true);
    }
  };
  return [
    options,
    selected,
    toNone,
    save,
    plugin,
    settingName,
    click_handler,
    input_change_handler,
    $$binding_groups,
    change_handler
  ];
}
var Checkboxes = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { plugin: 4, settingName: 5, options: 0 }, add_css12);
  }
};
var Checkboxes_default = Checkboxes;

// src/Settings/JumpToNextSettings.ts
function addJumpToNextSettings(plugin, viewDetails) {
  const { settings } = plugin;
  const jumpToDirDetails = subDetails("Jump to Next Direction", viewDetails);
  jumpToDirDetails.createDiv({ cls: "setting-item-name", text: "Limit which fields to jump to" });
  new Checkboxes_default({
    target: jumpToDirDetails,
    props: {
      plugin,
      settingName: "limitJumpToFirstFields",
      options: getFields(settings.userHiers)
    }
  });
}

// src/Settings/MatrixViewSettings.ts
var import_obsidian31 = require("obsidian");
function addMatrixViewSettings(plugin, viewDetails) {
  const { settings } = plugin;
  const MLViewDetails = subDetails("Matrix View", viewDetails);
  new import_obsidian31.Setting(MLViewDetails).setName("Show all field names or just relation types").setDesc(
    fragWithHTML(
      "Show the list of metadata fields for each relation type (e.g. <code>parent, broader, upper</code>), or just the name of the relation type, i.e. '<code>Parent</code>', '<code>Sibling</code>', '<code>Child</code>'.</br>\u2705 = show the full list."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.showNameOrType).onChange(async (value) => {
      settings.showNameOrType = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Show Relationship Type").setDesc(
    fragWithHTML(
      "Show whether a link is real or implied."
    )
  ).addToggle(
    (toggle) => toggle.setValue(settings.showRelationType).onChange(async (value) => {
      settings.showRelationType = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Directions Order").setDesc(
    fragWithHTML(
      `Change the order in which the directions appear in the Matrix view.</br>The default is "up, same, down, next, prev" (<code>01234</code>).
          <ul>
            <li>0 \u2192 up</li>
            <li>1 \u2192 same</li>
            <li>2 \u2192 down</li>
            <li>3 \u2192 next</li>
            <li>4 \u2192 prev</li>
          </ul>
          <strong>Note</strong>: You can remove numbers to hide those directions in the Matrix View. For example, <code>02</code> will only show up and down, in that order.`
    )
  ).addText((text2) => {
    text2.setValue(settings.squareDirectionsOrder.join(""));
    text2.inputEl.onblur = async () => {
      const value = text2.getValue();
      const values = value.split("");
      if (value.length <= 5 && values.every((value2) => ["0", "1", "2", "3", "4"].includes(value2))) {
        settings.squareDirectionsOrder = values.map(
          (order) => Number.parseInt(order)
        );
        await plugin.saveSettings();
        await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
      } else {
        new import_obsidian31.Notice(
          'The value must be a 5 digit number using only the digits "0", "1", "2", "3", "4"'
        );
      }
    };
  });
  new import_obsidian31.Setting(MLViewDetails).setName("Enable Alphabetical Sorting").setDesc(
    "By default, items in the Matrix view are sorted by the order they appear in your notes. Toggle this on to enable alphabetical sorting."
  ).addToggle(
    (toggle) => toggle.setValue(settings.enableAlphaSort).onChange(async (value) => {
      settings.enableAlphaSort = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Sort Alphabetically Ascending/Descending").setDesc(
    "Sort square items alphabetically in Ascending (\u2705) or Descending (\u274C) order."
  ).addToggle(
    (toggle) => toggle.setValue(settings.alphaSortAsc).onChange(async (value) => {
      settings.alphaSortAsc = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Sort by note name, but show alias").setDesc(
    "When this is turned off, notes will first be sorted by their alias, and then by their name if no alias is found. Turn this on to sort by note name always, but still show the alias in the results."
  ).addToggle(
    (toggle) => toggle.setValue(settings.sortByNameShowAlias).onChange(async (value) => {
      settings.sortByNameShowAlias = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Show Implied Relations").setDesc("Whether or not to show implied relations at all.").addToggle(
    (toggle) => toggle.setValue(settings.showImpliedRelations).onChange(async (value) => {
      settings.showImpliedRelations = value;
      await plugin.saveSettings();
      await plugin.getActiveTYPEView(MATRIX_VIEW).draw();
    })
  );
  new import_obsidian31.Setting(MLViewDetails).setName("Open View in Right or Left side").setDesc(
    "When loading the matrix view, should it open on the left or right side leaf? \u2705 = Right, \u274C = Left."
  ).addToggle(
    (toggle) => toggle.setValue(settings.rlLeaf).onChange(async (value) => {
      settings.rlLeaf = value;
      await plugin.saveSettings();
      app.workspace.detachLeavesOfType(MATRIX_VIEW);
      await openView(
        MATRIX_VIEW,
        MatrixView,
        value ? "right" : "left"
      );
    })
  );
}

// src/Settings/NoSystemSettings.ts
var import_obsidian32 = require("obsidian");
function addNoSystemSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const { userHiers } = settings;
  const fields = getFields(userHiers);
  const noSystemDetails = subDetails(
    "Naming System",
    alternativeHierarchyDetails
  );
  new import_obsidian32.Setting(noSystemDetails).setName("Naming System Regex").setDesc(
    fragWithHTML(
      "If you name your notes using the Johnny Decimal System or a related system, enter a regular expression matching the longest possible naming system you use. The regex should only match the naming system part of the name, not the actual note title.</br> For example, if you use the Johnny Decimal System, you might use <code>/^\\d\\.\\d\\.\\w/g</code> to match the note named <code>1.2.a Cars</code>.</br>If you don't want to choose a default, select the blank option at the bottom of the list."
    )
  ).addText((text2) => {
    text2.setValue(settings.namingSystemRegex);
    text2.inputEl.onblur = async () => {
      const value = text2.getValue();
      if (value === "" || strToRegex(value)) {
        settings.namingSystemRegex = value;
        await plugin.saveSettings();
        await refreshIndex(plugin);
      } else {
        new import_obsidian32.Notice("Invalid Regex");
      }
    };
  });
  new import_obsidian32.Setting(noSystemDetails).setName("Naming System Delimiter").setDesc(
    fragWithHTML(
      "What character do you use to split up your naming convention? For example, if you use <code>1.2.a.b</code>, then your delimiter is a period (<code>.</code>)."
    )
  ).addText((text2) => {
    text2.setValue(settings.namingSystemSplit);
    text2.inputEl.onblur = async () => {
      const value = text2.getValue();
      settings.namingSystemSplit = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    };
  });
  new import_obsidian32.Setting(noSystemDetails).setName("Naming System Field").setDesc("Which field should Breadcrumbs use for Naming System notes?").addDropdown((dd) => {
    fields.forEach((field) => {
      dd.addOption(field, field);
    });
    dd.setValue(settings.namingSystemField);
    dd.onChange(async (value) => {
      settings.namingSystemField = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
  new import_obsidian32.Setting(noSystemDetails).setName("Naming System Ends with Delimiter").setDesc(
    fragWithHTML(
      "Does your naming convention end with the delimiter? For example, <code>1.2. Note</code> does end with the delimiter, but <code>1.2 Note</code> does not.</br>For matching purposes, it is highly recommended to name your notes with the delimiter on the end. Only turn this setting on if you do name your notes this way, but know that the results may not be as accurate if you don't."
    )
  ).addToggle(
    (tog) => tog.setValue(settings.namingSystemEndsWithDelimiter).onChange(async (value) => {
      settings.namingSystemEndsWithDelimiter = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
}

// src/Settings/RegexNoteSettings.ts
var import_obsidian33 = require("obsidian");
function addRegexNoteSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const regexNoteDetails = subDetails(
    "Regex Notes",
    alternativeHierarchyDetails
  );
  new import_obsidian33.Setting(regexNoteDetails).setName("Default Regex Note Field").setDesc(
    fragWithHTML(
      "By default, regex notes use the first field in your hierarchies (usually an <code>\u2191</code> field). Choose a different one to use by default, without having to specify <code>BC-regex-note-field: {field}</code>.</br>If you don't want to choose a default, select the blank option at the bottom of the list."
    )
  ).addDropdown((dd) => {
    const options = {};
    getFields(settings.userHiers).forEach(
      (field) => options[field] = field
    );
    dd.addOptions(Object.assign(options, { "": "" })).setValue(settings.regexNoteField).onChange(async (field) => {
      settings.regexNoteField = field;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Settings/RelationSettings.ts
var import_obsidian34 = require("obsidian");
function addRelationSettings(plugin, containerEl) {
  const { settings } = plugin;
  const relationDetails = details("Relationships", containerEl);
  function mermaidDiagram(diagramStr) {
    import_obsidian34.MarkdownRenderer.renderMarkdown(
      diagramStr,
      relationDetails.createDiv(),
      "",
      null
    );
  }
  relationDetails.createEl("p", {
    text: "Here you can toggle on/off different types of implied relationships. All of your explicit (real) relationships will still show, but you can choose which implied ones get filled in.\nAll implied relationships are given a CSS class of the type of implied relation, so you can style them differently. For example `.BC-Aunt`."
  });
  new import_obsidian34.Setting(relationDetails).setName("Same Parent is Siblings").setDesc("If one note shares a parent with another, treat them as siblings").addToggle(
    (tg) => tg.setValue(settings.impliedRelations.sameParentIsSibling).onChange(async (val) => {
      settings.impliedRelations.sameParentIsSibling = val;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  mermaidDiagram("```mermaid\nflowchart LR\nMe -->|up| Dad\nSister -->|up| Dad\nMe <-.->|same| Sister\n```");
  new import_obsidian34.Setting(relationDetails).setName("Siblings' Siblings").setDesc("Treat your siblings' siblings as your siblings").addToggle(
    (tg) => tg.setValue(settings.impliedRelations.siblingsSiblingIsSibling).onChange(async (val) => {
      settings.impliedRelations.siblingsSiblingIsSibling = val;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  mermaidDiagram("```mermaid\nflowchart LR\nMe -->|same| Sister\nMe -->|same| Brother\nSister <-.->|same| Brother\n```");
  new import_obsidian34.Setting(relationDetails).setName("Siblings' Parent is Parent").setDesc("Your siblings' parents are your parents").addToggle(
    (tg) => tg.setValue(settings.impliedRelations.siblingsParentIsParent).onChange(async (val) => {
      settings.impliedRelations.siblingsParentIsParent = val;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  mermaidDiagram("```mermaid\nflowchart LR\nSister -->|up| Dad\nSister <-->|same| Me\nMe -.->|up| Dad\n```");
  new import_obsidian34.Setting(relationDetails).setName("Aunt/Uncle").setDesc("Treat your parent's siblings as your parents (aunts/uncles)").addToggle(
    (tg) => tg.setValue(settings.impliedRelations.parentsSiblingsIsParents).onChange(async (val) => {
      settings.impliedRelations.parentsSiblingsIsParents = val;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  mermaidDiagram("```mermaid\nflowchart LR\nMe -->|up| Dad\nDad -->|same| Uncle\nMe -.->|up| Uncle\n```");
  new import_obsidian34.Setting(relationDetails).setName("Cousins").setDesc(
    "Treat the cousins of a note as siblings (parents' siblings' children are cousins)"
  ).addToggle(
    (tg) => tg.setValue(settings.impliedRelations.cousinsIsSibling).onChange(async (val) => {
      settings.impliedRelations.cousinsIsSibling = val;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
  mermaidDiagram("```mermaid\nflowchart LR\nMe -->|up| Dad\nDad -->|same| Uncle\nUncle -->|down| Cousin\nMe <-.->|same| Cousin\n```");
  new import_obsidian34.Setting(relationDetails).setName("Make Current Note an Implied Sibling").setDesc(
    "Techincally, the current note is always it's own implied sibling. By default, it is not show as such. Toggle this on to make it show."
  ).addToggle(
    (toggle) => toggle.setValue(settings.treatCurrNodeAsImpliedSibling).onChange(async (value) => {
      settings.treatCurrNodeAsImpliedSibling = value;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    })
  );
}

// src/Settings/TagNoteSettings.ts
var import_obsidian35 = require("obsidian");
function addTagNoteSettings(plugin, alternativeHierarchyDetails) {
  const { settings } = plugin;
  const tagNoteDetails = subDetails("Tag Notes", alternativeHierarchyDetails);
  new import_obsidian35.Setting(tagNoteDetails).setName("Default Tag Note Field").setDesc(
    fragWithHTML(
      "By default, tag notes use the first field in your hierarchies (usually an <code>\u2191</code> field). Choose a different one to use by default, without having to specify <code>BC-tag-note-field: {field}</code>.</br>If you don't want to choose a default, select the blank option at the bottom of the list."
    )
  ).addDropdown((dd) => {
    const options = {};
    getFields(settings.userHiers).forEach(
      (field) => options[field] = field
    );
    dd.addOptions(Object.assign(options, { "": "" })).setValue(settings.tagNoteField).onChange(async (field) => {
      settings.tagNoteField = field;
      await plugin.saveSettings();
      await refreshIndex(plugin);
    });
  });
}

// src/Settings/ThreadingSettings.ts
var import_obsidian36 = require("obsidian");
function addThreadingSettings(plugin, cmdsDetails) {
  const { settings } = plugin;
  const threadingDetails = subDetails("Threading", cmdsDetails);
  threadingDetails.createDiv({
    text: "Settings for the commands `Create new <field> from current note`"
  });
  new import_obsidian36.Setting(threadingDetails).setName("Open new threads in new pane or current pane").addToggle((tog) => {
    tog.setValue(settings.threadIntoNewPane);
    tog.onChange(async (value) => {
      settings.threadIntoNewPane = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian36.Setting(threadingDetails).setName("Thread under Cursor").setDesc(
    fragWithHTML(
      "If the setting <code>Write Breadcrumbs Inline</code> is enabled, where should the new Breadcrumb be added to the current note? \u2705 = Under the cursor, \u274C = At the top of the note (under the yaml, if applicable)"
    )
  ).addToggle((tog) => {
    tog.setValue(settings.threadUnderCursor);
    tog.onChange(async (value) => {
      settings.threadUnderCursor = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian36.Setting(threadingDetails).setName("New Note Name Template").setDesc(
    fragWithHTML(
      `When threading into a new note, choose the template for the new note name.</br>
        Options include:</br>
        <ul>
          <li><code>{{field}}</code>: the field being thread into</li>
          <li><code>{{dir}}</code>: the direction being thread into</li>
          <li><code>{{current}}</code>: the current note name</li>
          <li><code>{{date}}</code>: the current date (Set the format in the setting below)</li>
        </ul>`
    )
  ).addText((text2) => {
    text2.setValue(settings.threadingTemplate);
    text2.inputEl.onblur = async () => {
      const value = text2.getValue();
      if (ILLEGAL_FILENAME_CHARS.some((char) => value.includes(char))) {
        new import_obsidian36.Notice(
          `File name cannot contain any of these characters: ${ILLEGAL_FILENAME_CHARS.join(
            " "
          )}`
        );
        text2.setValue(settings.threadingTemplate);
      } else {
        settings.threadingTemplate = value;
        await plugin.saveSettings();
      }
    };
  });
  new import_obsidian36.Setting(threadingDetails).setName("Date Format").setDesc("The date format used in the Threading Template (setting above)").addMomentFormat((format2) => {
    format2.setDefaultFormat(DEFAULT_SETTINGS.dateFormat).setValue(settings.dateFormat).onChange(async (value) => {
      settings.dateFormat = value;
      await plugin.saveSettings();
    });
  });
  const threadDirTemplatesSetting = new import_obsidian36.Setting(threadingDetails).setClass("thread-dir-templates").setName("Templater Template per Direction").setDesc(
    fragWithHTML(
      `For each direction to be thread into, choose a Templater template to insert into the new note.</br>
          Give the basename, or the full file path (e.g. <code>Templates/Parent Template</code>).`
    )
  );
  DIRECTIONS.forEach(
    (dir) => threadDirTemplatesSetting.addText((text2) => {
      text2.setPlaceholder(ARROW_DIRECTIONS[dir]).setValue(settings.threadingDirTemplates[dir]);
      text2.inputEl.onblur = async () => {
        settings.threadingDirTemplates[dir] = text2.getValue();
        await plugin.saveSettings();
      };
    })
  );
}

// src/Settings/TrailSettings.ts
var import_obsidian37 = require("obsidian");
function addTrailViewSettings(plugin, viewDetails) {
  const { settings } = plugin;
  const trailDetails = subDetails("Trail/Grid/Juggl", viewDetails);
  new import_obsidian37.Setting(trailDetails).setName("Show Breadcrumbs in Edit/Live-Preview Mode").setDesc(
    "It always shows in preview mode, but should it also show in the other two?"
  ).addToggle(
    (toggle) => toggle.setValue(settings.showBCsInEditLPMode).onChange(async (value) => {
      settings.showBCsInEditLPMode = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    })
  );
  trailDetails.createEl("hr");
  trailDetails.createDiv({
    cls: "setting-item-name",
    text: "Limit Trail View to only show certain fields"
  });
  new Checkboxes_default({
    target: trailDetails,
    props: {
      plugin,
      settingName: "limitTrailCheckboxes",
      options: getFields(settings.userHiers, "up")
    }
  });
  const viewsToShow = new import_obsidian37.Setting(trailDetails).setName("Views to show").setDesc(
    "Choose which of the views to show at the top of the note. Juggl View requires the Juggl plugin."
  ).addToggle((toggle) => {
    toggle.setTooltip("Trail view").setValue(settings.showTrail).onChange(async (value) => {
      settings.showTrail = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    });
  }).addToggle((toggle) => {
    toggle.setTooltip("Grid view").setValue(settings.showGrid).onChange(async (value) => {
      settings.showGrid = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    });
  }).addToggle((toggle) => {
    toggle.setTooltip("Next/Previous view").setValue(settings.showPrevNext).onChange(async (value) => {
      settings.showPrevNext = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    });
  });
  if (app.plugins.plugins.juggl !== void 0) {
    viewsToShow.addToggle((toggle) => {
      toggle.setTooltip("Juggl view").setValue(settings.showJuggl).onChange(async (value) => {
        settings.showJuggl = value;
        await plugin.saveSettings();
        await drawTrail(plugin);
      });
    });
  }
  new import_obsidian37.Setting(trailDetails).setName("Grid view depth").setDesc("Limit the initial depth of the grid view").addSlider((slider) => {
    slider.setLimits(0, 25, 1).setValue(settings.gridDefaultDepth).setDynamicTooltip();
    slider.sliderEl.onblur = async () => {
      settings.gridDefaultDepth = slider.getValue();
      await plugin.saveSettings();
      await drawTrail(plugin);
    };
  });
  new import_obsidian37.Setting(trailDetails).setName("Index Note(s)").setDesc(
    fragWithHTML(
      "The note that all of your other notes lead back to. The parent of all your parent notes. Just enter the basename.</br>You can also have multiple index notes (comma-separated list).</br>Leaving this field empty will make the trail show all paths going as far up the parent-tree as possible."
    )
  ).addText((text2) => {
    text2.setPlaceholder("Index Note").setValue(settings.indexNotes.join(", "));
    text2.inputEl.onblur = async () => {
      const splits = splitAndTrim(text2.getValue());
      if (splits[0] === void 0 || splits.every((index2) => isInVault(index2))) {
        settings.indexNotes = splits;
        await plugin.saveSettings();
      } else
        new import_obsidian37.Notice("Atleast one of the notes is not in your vault");
    };
  });
  new import_obsidian37.Setting(trailDetails).setName("Shows all paths if none to index note are found").setDesc(
    "If you have an index note chosen, but the trail view has no paths going up to those index notes, should it show all paths instead?"
  ).addToggle(
    (toggle) => toggle.setValue(settings.showAllPathsIfNoneToIndexNote).onChange(async (value) => {
      settings.showAllPathsIfNoneToIndexNote = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    })
  );
  new import_obsidian37.Setting(trailDetails).setName("Default: All, Longest, or Shortest").setDesc(
    "If multiple paths are found going up the parent tree, which of them should show?"
  ).addDropdown((dd) => {
    const options = {};
    TRAIL_LENGTHS.forEach((length) => {
      options[length] = length;
    });
    dd.addOptions(options);
    dd.setValue(settings.showAll);
    dd.onChange(async (val) => {
      settings.showAll = val;
      await plugin.saveSettings();
      await drawTrail(plugin);
    });
  });
  new import_obsidian37.Setting(trailDetails).setName("Seperator").setDesc(
    fragWithHTML(
      "The character to show between crumbs in the breadcrumb trail. The default is <code>\u2192</code>"
    )
  ).addText(
    (text2) => text2.setPlaceholder("\u2192").setValue(settings.trailSeperator).onChange(async (value) => {
      settings.trailSeperator = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    })
  );
  new import_obsidian37.Setting(trailDetails).setName("No path found message").setDesc(
    "The text to display when no path to the index note is found, or the current note has no parent."
  ).addText(
    (text2) => text2.setPlaceholder("No path to index note was found").setValue(settings.noPathMessage).onChange(async (value) => {
      settings.noPathMessage = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    })
  );
  new import_obsidian37.Setting(trailDetails).setName("Respect Readable Line Length").setDesc(
    "Should the breadcrumbs trail adjust its width to the readable line length, or use as much space as possible? \u2705 = use readable line length."
  ).addToggle(
    (toggle) => toggle.setValue(settings.respectReadableLineLength).onChange(async (value) => {
      settings.respectReadableLineLength = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    })
  );
  new import_obsidian37.Setting(trailDetails).setName("Show up fields in Juggl").setDesc("Juggl will show both up and down fields").addToggle((toggle) => {
    toggle.setValue(settings.showUpInJuggl).onChange(async (value) => {
      settings.showUpInJuggl = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian37.Setting(trailDetails).setName("Juggl view layout").setDesc(
    fragWithHTML(
      "The layout type to use for the Juggl view.<br>The hierarchy layout is most natural for Breadcrumbs, but for large graphs D3 Force is recommended."
    )
  ).addDropdown((dc) => {
    dc.addOption("hierarchy", "Hierarchy");
    dc.addOption("d3-force", "D3 Force");
    dc.addOption("cola", "Cola Force");
    dc.addOption("grid", "Grid");
    dc.addOption("concentric", "Concentric");
    dc.setValue(settings.jugglLayout);
    dc.onChange(async (value) => {
      settings.jugglLayout = value;
      await plugin.saveSettings();
      await drawTrail(plugin);
    });
  });
}

// src/Settings/VisModalSettings.ts
var import_obsidian38 = require("obsidian");
function addVisModalSettings(plugin, viewDetails) {
  const { settings } = plugin;
  const visModalDetails = subDetails("Visualisation Modal", viewDetails);
  new import_obsidian38.Setting(visModalDetails).setName("Default Visualisation Type").setDesc("Which visualisation to show by default").addDropdown((cb) => {
    VISTYPES.forEach((option) => {
      cb.addOption(option, option);
    });
    cb.setValue(settings.visGraph);
    cb.onChange(async (value) => {
      settings.visGraph = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian38.Setting(visModalDetails).setName("Default Relation").setDesc("Which relation type to show first when opening the modal").addDropdown((dd) => {
    RELATIONS.forEach((option) => {
      dd.addOption(option, option);
    });
    dd.setValue(settings.visRelation);
    dd.onChange(async (value) => {
      settings.visRelation = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian38.Setting(visModalDetails).setName("Default Real/Closed").setDesc("Show the real or closed graph by default").addDropdown((cb) => {
    REAlCLOSED.forEach((option) => {
      cb.addOption(option, option);
    });
    cb.setValue(settings.visClosed);
    cb.onChange(async (value) => {
      settings.visClosed = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian38.Setting(visModalDetails).setName("Default Unlinked").setDesc("Show all nodes or only those which have links by default").addDropdown((cb) => {
    ALLUNLINKED.forEach((option) => {
      cb.addOption(option, option);
    });
    cb.setValue(settings.visAll);
    cb.onChange(async (value) => {
      settings.visAll = value;
      await plugin.saveSettings();
    });
  });
}

// src/Settings/WriteBCsSettings.ts
var import_obsidian39 = require("obsidian");
function addWriteBCsSettings(plugin, cmdsDetails) {
  const { settings } = plugin;
  const writeBCsToFileDetails = subDetails(
    "Write Breadcrumbs to File",
    cmdsDetails
  );
  writeBCsToFileDetails.createDiv({
    cls: "setting-item-name",
    text: "Limit to only write certain fields"
  });
  new Checkboxes_default({
    target: writeBCsToFileDetails,
    props: {
      plugin,
      options: getFields(settings.userHiers),
      settingName: "limitWriteBCCheckboxes"
    }
  });
  new import_obsidian39.Setting(writeBCsToFileDetails).setName("Write Inline").setDesc(
    "When writing BCs to file, should they be written inline (using Dataview syntax), or into the YAML of the note?"
  ).addToggle(
    (toggle) => toggle.setValue(settings.writeBCsInline).onChange(async (value) => {
      settings.writeBCsInline = value;
      await plugin.saveSettings();
    })
  );
  new import_obsidian39.Setting(writeBCsToFileDetails).setName(
    fragWithHTML(
      "Show the <code>Write Breadcrumbs to ALL Files</code> command"
    )
  ).setDesc(
    "This command attempts to update ALL files with implied breadcrumbs pointing to them. So, it is not shown by default (even though it has 3 confirmation boxes to ensure you want to run it"
  ).addToggle(
    (toggle) => toggle.setValue(settings.showWriteAllBCsCmd).onChange(async (value) => {
      settings.showWriteAllBCsCmd = value;
      await plugin.saveSettings();
    })
  );
}

// src/Settings/BreadcrumbsSettingTab.ts
var fragWithHTML = (html) => createFragment((frag) => frag.createDiv().innerHTML = html);
var details = (text2, parent) => parent.createEl("details", {}, (d) => d.createEl("summary", { text: text2 }));
var subDetails = (text2, parent) => parent.createDiv({
  attr: { style: "padding-left: 10px;" }
}).createEl("details", {}, (d) => d.createEl("summary", { text: text2 }));
var BCSettingTab = class extends import_obsidian40.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { plugin, containerEl } = this;
    const { settings } = plugin;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Breadcrumbs Settings" });
    containerEl.addClass("BC-settings-tab");
    addHierarchySettings(plugin, containerEl);
    addRelationSettings(plugin, containerEl);
    addGeneralSettings(plugin, containerEl);
    const viewDetails = details("Views", containerEl);
    new import_obsidian40.Setting(viewDetails).setName("Open Views by Default").setDesc(fragWithHTML("Choose which of the views to open onload<br/>Order is: Trail/Grid/Juggl, Matrix, Ducks, Tree")).addToggle(
      (toggle) => toggle.setTooltip("Trail/Grid/Juggl").setValue(settings.showBCs).onChange(async (value) => {
        settings.showBCs = value;
        await plugin.saveSettings();
        await drawTrail(plugin);
      })
    ).addToggle((toggle) => {
      toggle.setTooltip("Matrix View").setValue(settings.openMatrixOnLoad).onChange(async (value) => {
        settings.openMatrixOnLoad = value;
        await plugin.saveSettings();
      });
    }).addToggle((toggle) => {
      toggle.setTooltip("Ducks View").setValue(settings.openDuckOnLoad).onChange(async (value) => {
        settings.openDuckOnLoad = value;
        await plugin.saveSettings();
      });
    }).addToggle((toggle) => {
      toggle.setTooltip("Tree View").setValue(settings.openDownOnLoad).onChange(async (value) => {
        settings.openDownOnLoad = value;
        await plugin.saveSettings();
      });
    });
    viewDetails.createEl("hr");
    addMatrixViewSettings(plugin, viewDetails);
    addTrailViewSettings(plugin, viewDetails);
    addVisModalSettings(plugin, viewDetails);
    const alternativeHierarchyDetails = details(
      "Alternative Hierarchies",
      containerEl
    );
    addTagNoteSettings(plugin, alternativeHierarchyDetails);
    addRegexNoteSettings(plugin, alternativeHierarchyDetails);
    addNoSystemSettings(plugin, alternativeHierarchyDetails);
    addHierarchyNoteSettings(plugin, alternativeHierarchyDetails);
    addCSVSettings(plugin, alternativeHierarchyDetails);
    addDendronSettings(plugin, alternativeHierarchyDetails);
    addDataviewSettings(plugin, alternativeHierarchyDetails);
    addDateNoteSettings(plugin, alternativeHierarchyDetails);
    const cmdsDetails = details("Commands", containerEl);
    addWriteBCsSettings(plugin, cmdsDetails);
    addCreateIndexSettings(plugin, cmdsDetails);
    addThreadingSettings(plugin, cmdsDetails);
    addJumpToNextSettings(plugin, cmdsDetails);
    addDebuggingsSettings(plugin, containerEl);
    new KoFi_default({ target: containerEl });
  }
};

// src/Views/DucksView.ts
var import_obsidian41 = require("obsidian");

// node_modules/svelte-icons/fa/FaInfo.svelte
function create_default_slot4(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment18(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 192 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaInfo = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var FaInfo_default = FaInfo;

// src/Components/Ducks.svelte
function add_css13(target) {
  append_styles(target, "svelte-gmdm3a", ".icon.svelte-gmdm3a{color:var(--text-normal);display:inline-block;padding-top:5px !important;width:20px;height:20px}");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block8(ctx) {
  let div;
  let a2;
  let t0_value = (
    /*duck*/
    ctx[13] + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[8](
        /*duck*/
        ctx[13],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[9](
        /*duck*/
        ctx[13],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      a2 = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a2, "class", "internal-link");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a2);
      append(a2, t0);
      append(div, t1);
      if (!mounted) {
        dispose = [
          listen(div, "click", click_handler),
          listen(div, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*ducks*/
      8 && t0_value !== (t0_value = /*duck*/
      ctx[13] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment19(ctx) {
  let div;
  let h6;
  let t1;
  let span;
  let fainfo;
  let span_aria_label_value;
  let t2;
  let label;
  let t3;
  let input0;
  let t4;
  let input1;
  let t5;
  let current;
  let mounted;
  let dispose;
  fainfo = new FaInfo_default({});
  let each_value = (
    /*ducks*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      h6 = element("h6");
      h6.textContent = "Notes without Breadcrumbs";
      t1 = space();
      span = element("span");
      create_component(fainfo.$$.fragment);
      t2 = space();
      label = element("label");
      t3 = text("Filter:\n    ");
      input0 = element("input");
      t4 = space();
      input1 = element("input");
      t5 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "icon svelte-gmdm3a");
      attr(span, "aria-label", span_aria_label_value = `A Regex used to filter the results.
If 'Include' is checked, it will only show notes that match the regex.
If 'Include' is not checked, this regex will filter out notes that match it.`);
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Regex");
      attr(input1, "aria-label", "Include");
      attr(input1, "type", "checkbox");
      attr(div, "class", "BC-Ducks markdown-preview-view");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h6);
      append(div, t1);
      append(div, span);
      mount_component(fainfo, span, null);
      append(div, t2);
      append(div, label);
      append(label, t3);
      append(label, input0);
      set_input_value(
        input0,
        /*query*/
        ctx[1]
      );
      append(div, t4);
      append(div, input1);
      input1.checked = /*include*/
      ctx[2];
      append(div, t5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[6]
          ),
          listen(
            input1,
            "change",
            /*input1_change_handler*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*query*/
      2 && input0.value !== /*query*/
      ctx2[1]) {
        set_input_value(
          input0,
          /*query*/
          ctx2[1]
        );
      }
      if (dirty & /*include*/
      4) {
        input1.checked = /*include*/
        ctx2[2];
      }
      if (dirty & /*openOrSwitch, ducks, hoverPreview, ducksView*/
      9) {
        each_value = /*ducks*/
        ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fainfo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fainfo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(fainfo);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let ducks;
  ;
  ;
  let { plugin } = $$props;
  let { ducksView } = $$props;
  const { mainG } = plugin;
  const files = app.vault.getMarkdownFiles();
  let query = "";
  let regex = new RegExp(query, "g");
  let include = true;
  const getDucks = (regex2) => {
    if (!regex2)
      return;
    return files.map((file) => file.basename).filter((name) => !mainG.neighbors(name).length && include === regex2.test(name));
  };
  function input0_input_handler() {
    query = this.value;
    $$invalidate(1, query);
  }
  function input1_change_handler() {
    include = this.checked;
    $$invalidate(2, include);
  }
  const click_handler = async (duck, e) => await openOrSwitch(duck, e);
  const mouseover_handler = (duck, e) => hoverPreview(e, ducksView, duck);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(4, plugin = $$props2.plugin);
    if ("ducksView" in $$props2)
      $$invalidate(0, ducksView = $$props2.ducksView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*query*/
    2) {
      $: {
        try {
          const newReg = new RegExp(query, "g");
          $$invalidate(5, regex = newReg);
        } catch (e) {
        }
      }
    }
    if ($$self.$$.dirty & /*regex*/
    32) {
      $:
        $$invalidate(3, ducks = getDucks(regex));
    }
  };
  return [
    ducksView,
    query,
    include,
    ducks,
    plugin,
    regex,
    input0_input_handler,
    input1_change_handler,
    click_handler,
    mouseover_handler
  ];
}
var Ducks = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { plugin: 4, ducksView: 0 }, add_css13);
  }
};
var Ducks_default = Ducks;

// src/Views/DucksView.ts
var DucksView = class extends import_obsidian41.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // TODO Duck icon
    this.icon = DUCK_ICON;
    this.plugin = plugin;
  }
  async onload() {
    super.onload();
    await this.plugin.saveSettings();
    app.workspace.onLayoutReady(async () => {
      await this.draw();
    });
  }
  getViewType() {
    return DUCK_VIEW;
  }
  getDisplayText() {
    return "Breadcrumbs Ducks";
  }
  async onOpen() {
  }
  onClose() {
    var _a;
    (_a = this.view) == null ? void 0 : _a.$destroy();
    return Promise.resolve();
  }
  async draw() {
    this.contentEl.empty();
    this.view = new Ducks_default({
      target: this.contentEl,
      props: { plugin: this.plugin, ducksView: this }
    });
  }
};

// src/Views/TreeView.ts
var import_obsidian42 = require("obsidian");

// src/Components/SideTree.svelte
var import_loglevel20 = __toESM(require_loglevel());

// node_modules/svelte-icons/fa/FaFire.svelte
function create_default_slot5(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M216 23.86c0-23.8-30.65-32.77-44.15-13.04C48 191.85 224 200 224 288c0 35.63-29.11 64.46-64.85 63.99-35.17-.45-63.15-29.77-63.15-64.94v-85.51c0-21.7-26.47-32.23-41.43-16.5C27.8 213.16 0 261.33 0 320c0 105.87 86.13 192 192 192s192-86.13 192-192c0-170.29-168-193-168-296.14z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment20(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 384 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaFire = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var FaFire_default = FaFire;

// node_modules/svelte-icons/fa/FaRegSnowflake.svelte
function create_default_slot6(ctx) {
  let path2;
  return {
    c() {
      path2 = svg_element("path");
      attr(path2, "d", "M440.1 355.2l-39.2-23 34.1-9.3c8.4-2.3 13.4-11.1 11.1-19.6l-4.1-15.5c-2.2-8.5-10.9-13.6-19.3-11.3L343 298.2 271.2 256l71.9-42.2 79.7 21.7c8.4 2.3 17-2.8 19.3-11.3l4.1-15.5c2.2-8.5-2.7-17.3-11.1-19.6l-34.1-9.3 39.2-23c7.5-4.4 10.1-14.2 5.8-21.9l-7.9-13.9c-4.3-7.7-14-10.3-21.5-5.9l-39.2 23 9.1-34.7c2.2-8.5-2.7-17.3-11.1-19.6l-15.2-4.1c-8.4-2.3-17 2.8-19.3 11.3l-21.3 81-71.9 42.2v-84.5L306 70.4c6.1-6.2 6.1-16.4 0-22.6l-11.1-11.3c-6.1-6.2-16.1-6.2-22.2 0l-24.9 25.4V16c0-8.8-7-16-15.7-16h-15.7c-8.7 0-15.7 7.2-15.7 16v46.1l-24.9-25.4c-6.1-6.2-16.1-6.2-22.2 0L142.1 48c-6.1 6.2-6.1 16.4 0 22.6l58.3 59.3v84.5l-71.9-42.2-21.3-81c-2.2-8.5-10.9-13.6-19.3-11.3L72.7 84c-8.4 2.3-13.4 11.1-11.1 19.6l9.1 34.7-39.2-23c-7.5-4.4-17.1-1.8-21.5 5.9l-7.9 13.9c-4.3 7.7-1.8 17.4 5.8 21.9l39.2 23-34.1 9.1c-8.4 2.3-13.4 11.1-11.1 19.6L6 224.2c2.2 8.5 10.9 13.6 19.3 11.3l79.7-21.7 71.9 42.2-71.9 42.2-79.7-21.7c-8.4-2.3-17 2.8-19.3 11.3l-4.1 15.5c-2.2 8.5 2.7 17.3 11.1 19.6l34.1 9.3-39.2 23c-7.5 4.4-10.1 14.2-5.8 21.9L10 391c4.3 7.7 14 10.3 21.5 5.9l39.2-23-9.1 34.7c-2.2 8.5 2.7 17.3 11.1 19.6l15.2 4.1c8.4 2.3 17-2.8 19.3-11.3l21.3-81 71.9-42.2v84.5l-58.3 59.3c-6.1 6.2-6.1 16.4 0 22.6l11.1 11.3c6.1 6.2 16.1 6.2 22.2 0l24.9-25.4V496c0 8.8 7 16 15.7 16h15.7c8.7 0 15.7-7.2 15.7-16v-46.1l24.9 25.4c6.1 6.2 16.1 6.2 22.2 0l11.1-11.3c6.1-6.2 6.1-16.4 0-22.6l-58.3-59.3v-84.5l71.9 42.2 21.3 81c2.2 8.5 10.9 13.6 19.3 11.3L375 428c8.4-2.3 13.4-11.1 11.1-19.6l-9.1-34.7 39.2 23c7.5 4.4 17.1 1.8 21.5-5.9l7.9-13.9c4.6-7.5 2.1-17.3-5.5-21.7z");
    },
    m(target, anchor) {
      insert(target, path2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(path2);
    }
  };
}
function create_fragment21(ctx) {
  let iconbase;
  let current;
  const iconbase_spread_levels = [
    { viewBox: "0 0 448 512" },
    /*$$props*/
    ctx[0]
  ];
  let iconbase_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
  }
  iconbase = new IconBase_default({ props: iconbase_props });
  return {
    c() {
      create_component(iconbase.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbase, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const iconbase_changes = dirty & /*$$props*/
      1 ? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(
        /*$$props*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      2) {
        iconbase_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbase.$set(iconbase_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbase.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbase.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbase, detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var FaRegSnowflake = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
  }
};
var FaRegSnowflake_default = FaRegSnowflake;

// src/Components/SideTree.svelte
function add_css14(target) {
  append_styles(target, "svelte-8j6nux", "button.svelte-8j6nux{display:inline;padding:1px 6px 2px 6px}.BC-downs.svelte-8j6nux{padding-left:5px}pre.svelte-8j6nux{display:inline}.is-unresolved.svelte-8j6nux{color:var(--text-muted)}.icon.svelte-8j6nux{color:var(--text-normal);display:inline-block;padding-top:5px !important;width:20px;height:20px}");
}
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_else_block4(ctx) {
  let fafire;
  let current;
  fafire = new FaFire_default({});
  return {
    c() {
      create_component(fafire.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fafire, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(fafire.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fafire.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fafire, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let faregsnowflake;
  let current;
  faregsnowflake = new FaRegSnowflake_default({});
  return {
    c() {
      create_component(faregsnowflake.$$.fragment);
    },
    m(target, anchor) {
      mount_component(faregsnowflake, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(faregsnowflake.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(faregsnowflake.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(faregsnowflake, detaching);
    }
  };
}
function create_each_block_16(ctx) {
  let option;
  let t_value = (
    /*direction*/
    ctx[19] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*direction*/
      ctx[19];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block8(ctx) {
  let div;
  let pre;
  let t0_value = (
    /*line*/
    ctx[16][0] + "-"
  );
  let t0;
  let t1;
  let span;
  let a2;
  let t2_value = dropDendron(
    /*line*/
    ctx[16][1],
    /*settings*/
    ctx[6]
  ) + "";
  let t2;
  let a_class_value;
  let t3;
  let mounted;
  let dispose;
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[10](
        /*line*/
        ctx[16],
        ...args
      )
    );
  }
  function mouseover_handler(...args) {
    return (
      /*mouseover_handler*/
      ctx[11](
        /*line*/
        ctx[16],
        ...args
      )
    );
  }
  return {
    c() {
      div = element("div");
      pre = element("pre");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      a2 = element("a");
      t2 = text(t2_value);
      t3 = space();
      attr(pre, "class", "svelte-8j6nux");
      attr(a2, "class", a_class_value = "internal-link " + (isInVault(
        /*line*/
        ctx[16][1]
      ) ? "" : "is-unresolved") + " svelte-8j6nux");
      attr(span, "class", "internal-link");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(pre, t0);
      append(div, t1);
      append(div, span);
      append(span, a2);
      append(a2, t2);
      append(div, t3);
      if (!mounted) {
        dispose = [
          listen(span, "click", click_handler_2),
          listen(span, "mouseover", mouseover_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*lines*/
      32 && t0_value !== (t0_value = /*line*/
      ctx[16][0] + "-"))
        set_data(t0, t0_value);
      if (dirty & /*lines*/
      32 && t2_value !== (t2_value = dropDendron(
        /*line*/
        ctx[16][1],
        /*settings*/
        ctx[6]
      ) + ""))
        set_data(t2, t2_value);
      if (dirty & /*lines*/
      32 && a_class_value !== (a_class_value = "internal-link " + (isInVault(
        /*line*/
        ctx[16][1]
      ) ? "" : "is-unresolved") + " svelte-8j6nux")) {
        attr(a2, "class", a_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block9(ctx) {
  let if_block_anchor;
  let if_block = (
    /*line*/
    ctx[16].length > 1 && create_if_block8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*line*/
        ctx2[16].length > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment22(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let span_aria_label_value;
  let t0;
  let button;
  let t2;
  let select;
  let t3;
  let div;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_15, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*frozen*/
      ctx2[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value_1 = DIRECTIONS;
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));
  }
  let each_value = (
    /*lines*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  return {
    c() {
      span = element("span");
      if_block.c();
      t0 = space();
      button = element("button");
      button.textContent = "\u21BB";
      t2 = space();
      select = element("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "icon svelte-8j6nux");
      attr(span, "aria-label", span_aria_label_value = /*frozen*/
      ctx[4] ? `Frozen on: ${/*basename*/
      ctx[3]}` : "Unfrozen");
      attr(span, "aria-label-position", "left");
      attr(button, "aria-label", "Refresh Stats View (also refreshes Breadcrumbs Index)");
      attr(button, "class", "svelte-8j6nux");
      attr(select, "class", "dropdown");
      if (
        /*dir*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[9].call(select)
        ));
      attr(div, "class", "BC-downs svelte-8j6nux");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      insert(target, t2, anchor);
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select, null);
        }
      }
      select_option(
        select,
        /*dir*/
        ctx[2],
        true
      );
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            span,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button,
            "click",
            /*click_handler_1*/
            ctx[8]
          ),
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
      if (!current || dirty & /*frozen, basename*/
      24 && span_aria_label_value !== (span_aria_label_value = /*frozen*/
      ctx2[4] ? `Frozen on: ${/*basename*/
      ctx2[3]}` : "Unfrozen")) {
        attr(span, "aria-label", span_aria_label_value);
      }
      if (dirty & /*DIRECTIONS*/
      0) {
        each_value_1 = DIRECTIONS;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_16(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_16(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*dir, DIRECTIONS*/
      4) {
        select_option(
          select,
          /*dir*/
          ctx2[2]
        );
      }
      if (dirty & /*openOrSwitch, lines, hoverPreview, view, isInVault, dropDendron, settings*/
      98) {
        each_value = /*lines*/
        ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(select);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  var _a;
  ;
  ;
  ;
  let { plugin } = $$props;
  let { view } = $$props;
  const { settings, app: app2, closedG } = plugin;
  const { createIndexIndent } = settings;
  let dir = "down";
  let frozen = false;
  let { basename } = (_a = getCurrFile()) !== null && _a !== void 0 ? _a : {};
  plugin.registerEvent(app2.workspace.on("active-leaf-change", () => {
    var _a2;
    if (frozen)
      return;
    $$invalidate(3, basename = (_a2 = getCurrFile()) === null || _a2 === void 0 ? void 0 : _a2.basename);
  }));
  let lines;
  const click_handler = () => {
    var _a2;
    $$invalidate(4, frozen = !frozen);
    if (!frozen)
      $$invalidate(3, basename = (_a2 = getCurrFile()) == null ? void 0 : _a2.basename);
  };
  const click_handler_1 = async () => {
    await refreshIndex(plugin);
    await view.draw();
  };
  function select_change_handler() {
    dir = select_value(this);
    $$invalidate(2, dir);
  }
  const click_handler_2 = async (line, e) => await openOrSwitch(line[1], e);
  const mouseover_handler = (line, e) => hoverPreview(e, view, line[1]);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("view" in $$props2)
      $$invalidate(1, view = $$props2.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dir, basename*/
    12) {
      $: {
        const dirG = getSubInDirs(closedG, dir);
        const allPaths = dfsAllPaths(dirG, basename);
        const index2 = createIndex(allPaths, false, createIndexIndent);
        (0, import_loglevel20.info)({ allPaths, index: index2 });
        $$invalidate(5, lines = indexToLinePairs(index2));
      }
    }
  };
  return [
    plugin,
    view,
    dir,
    basename,
    frozen,
    lines,
    settings,
    click_handler,
    click_handler_1,
    select_change_handler,
    click_handler_2,
    mouseover_handler
  ];
}
var SideTree = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, { plugin: 0, view: 1 }, add_css14);
  }
};
var SideTree_default = SideTree;

// src/Views/TreeView.ts
var TreeView = class extends import_obsidian42.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = addFeatherIcon("corner-right-down");
    this.plugin = plugin;
  }
  async onload() {
    super.onload();
    app.workspace.onLayoutReady(async () => {
      await this.draw();
    });
  }
  getViewType() {
    return TREE_VIEW;
  }
  getDisplayText() {
    return "Breadcrumbs Down";
  }
  async onOpen() {
  }
  onClose() {
    var _a;
    (_a = this.view) == null ? void 0 : _a.$destroy();
    return Promise.resolve();
  }
  async draw() {
    this.contentEl.empty();
    this.view = new SideTree_default({
      target: this.contentEl,
      props: { plugin: this.plugin, view: this }
    });
  }
};

// node_modules/d3-array/src/ascending.js
function ascending_default(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x4) => f(d) - x4;
    compare = ascendingComparator(f);
  }
  function left(a2, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a2[mid], x4) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a2, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a2[mid], x4) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x4, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    const i = left(a2, x4, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x4) > -delta(a2[i], x4) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x4) => ascending_default(f(d), x4);
}

// node_modules/d3-array/src/number.js
function number_default(x4) {
  return x4 === null ? NaN : +x4;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks_default(start2, stop, count2) {
  var reverse, i = -1, n2, ticks, step;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse = stop < start2)
    n2 = start2, start2 = stop, stop = n2;
  if ((step = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
    if (r0 * step < start2)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks = new Array(n2 = r1 - r0 + 1);
    while (++i < n2)
      ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
    if (r0 / step < start2)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks = new Array(n2 = r1 - r0 + 1);
    while (++i < n2)
      ticks[i] = (r0 + i) / step;
  }
  if (reverse)
    ticks.reverse();
  return ticks;
}
function tickIncrement(start2, stop, count2) {
  var step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error6 = step / Math.pow(10, power);
  return power >= 0 ? (error6 >= e10 ? 10 : error6 >= e5 ? 5 : error6 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error6 >= e10 ? 10 : error6 >= e5 ? 5 : error6 >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error6 = step0 / step1;
  if (error6 >= e10)
    step1 *= 10;
  else if (error6 >= e5)
    step1 *= 5;
  else if (error6 >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max4;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  }
  return max4;
}

// node_modules/d3-array/src/range.js
function range_default(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step;
  var i = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range = new Array(n2);
  while (++i < n2) {
    range[i] = start2 + i * step;
  }
  return range;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop2 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n2 = arguments.length, _ = {}, t; i < n2; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n2 = T.length;
    if (arguments.length < 2) {
      while (++i < n2)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n2) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _ = this._;
    for (var t in _)
      copy3[t] = _[t].slice();
    return new Dispatch(copy3);
  },
  call: function(type2, that) {
    if ((n2 = arguments.length - 2) > 0)
      for (var args = new Array(n2), i = 0, n2, t; i < n2; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n2 = t.length; i < n2; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n2 = t.length; i < n2; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i = 0, n2 = type2.length, c3; i < n2; ++i) {
    if ((c3 = type2[i]).name === name) {
      return c3.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n2 = type2.length; i < n2; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop2, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i = 0; i < n2; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array_default(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    var group = select.apply(this, arguments);
    return group == null ? [] : array_default(group);
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match2) {
  return function() {
    return find.call(this.children, match2);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match2) {
  return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children2() {
  return this.children;
}
function childrenFilter(match2) {
  return function() {
    return filter.call(this.children, match2);
  };
}
function selectChildren_default(match2) {
  return this.selectAll(match2 == null ? children2 : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match2) {
  if (typeof match2 !== "function")
    match2 = matcher_default(match2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n2; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update2) {
  return new Array(update2.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update2, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m2 = groups.length, update2 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = array_default(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null)
    update2 = onupdate(update2);
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(selection2) {
  if (!(selection2 instanceof Selection))
    throw new Error("invalid merge");
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a2, b) {
    return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, sortgroup = sortgroups[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length; i < n2; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length, node; i < n2; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n2 = names.length;
  while (++i < n2)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n2 = names.length;
  while (++i < n2)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n2 = names.length;
    while (++i < n2)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone3 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
}
function selection_cloneDeep() {
  var clone3 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m2 = on.length, o; j < m2; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m2 = on.length; j < m2; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n2 = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m2 = on.length, o; j < m2; ++j) {
        for (i = 0, o = on[j]; i < n2; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n2; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length, node; i < n2; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point3 = svg.createSVGPoint();
      point3.x = event.clientX, point3.y = event.clientY;
      point3 = point3.matrixTransform(node.getScreenCTM().inverse());
      return [point3.x, point3.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-drag/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, true);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, true);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, true);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default2 = (x4) => () => x4;

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x4,
  y: y4,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x4, enumerable: true, configurable: true },
    y: { value: y4, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter2.call(this, event, d))
      return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture)
      return;
    select_default2(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter2.call(this, event, d))
      return;
    var touches = event.changedTouches, c3 = container.call(this, event, d), n2 = touches.length, i, gesture;
    for (i = 0; i < n2; ++i) {
      if (gesture = beforestart(this, c3, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i, gesture;
    for (i = 0; i < n2; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n2; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer_default(touch || event, container2), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null)
      return;
    dx = s2.x - p[0] || 0;
    dy = s2.y - p[1] || 0;
    return function gesture(type2, event2, touch2) {
      var p0 = p, n2;
      switch (type2) {
        case "start":
          gestures[identifier] = gesture, n2 = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer_default(touch2 || event2, container2), n2 = active;
          break;
      }
      dispatch2.call(
        type2,
        that,
        new DragEvent(type2, {
          sourceEvent: event2,
          subject: s2,
          target: drag,
          identifier,
          active: n2,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default2(!!_), drag) : filter2;
  };
  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant_default2(_), drag) : container;
  };
  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant_default2(_), drag) : subject;
  };
  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default2(!!_), drag) : touchable;
  };
  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l2, a2) {
  if (a2 <= 0)
    h = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l2, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s2 = max4 - min3, l2 = (max4 + min3) / 2;
  if (s2) {
    if (r === max4)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max4)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l2 < 0.5 ? max4 + min3 : 2 - max4 - min3;
    h *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l2, o.opacity);
}
function hsl(h, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l2, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l2, k = (E * (g - l2) - C * bl) / D, s2 = Math.sqrt(k * k + bl * bl) / (E * l2 * (1 - l2)), h = s2 ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l2, o.opacity);
}
function cubehelix(h, s2, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l2, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l2 + a2 * (A * cosh2 + B * sinh2)),
      255 * (l2 + a2 * (C * cosh2 + D * sinh2)),
      255 * (l2 + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n2 = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n2 - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n2 = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values[(i + n2 - 1) % n2], v1 = values[i % n2], v2 = values[(i + 1) % n2], v3 = values[(i + 2) % n2];
    return basis((t - i / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default3 = (x4) => () => x4;

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y4) {
  return a2 = Math.pow(a2, y4), b = Math.pow(b, y4) - a2, y4 = 1 / y4, function(t) {
    return Math.pow(a2 + t * b, y4);
  };
}
function hue(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default3(isNaN(a2) ? b : a2);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y4) : constant_default3(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant_default3(isNaN(a2) ? b : a2);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color2 = gamma(y4);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r = new Array(n2), g = new Array(n2), b = new Array(n2), i, color2;
    for (i = 0; i < n2; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b)
    b = [];
  var n2 = a2 ? Math.min(b.length, a2.length) : 0, c3 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n2; ++i)
      c3[i] = a2[i] * (1 - t) + b[i] * t;
    return c3;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x4 = new Array(na), c3 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x4[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i)
    c3[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c3[i] = x4[i](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default2(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  var i = {}, c3 = {}, k;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a2) {
      i[k] = value_default(a2[k], b[k]);
    } else {
      c3[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c3[k] = i[k](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default2(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  var t = typeof b, c3;
  return b == null || t === "boolean" ? constant_default3(b) : (t === "number" ? number_default2 : t === "string" ? (c3 = color(b)) ? (b = c3, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default2)(a2, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b, c3, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b))
    a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c3 + b * d)
    c3 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d * d))
    c3 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c3)
    a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180)
        b += 360;
      else if (b - a2 > 180)
        a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default2(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default2(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse2(a2), b = parse2(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n2 = q.length, o;
      while (++i < n2)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x4) {
  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
}
function sinh(x4) {
  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
}
function tanh(x4) {
  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start2, end) {
      var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s2(t);
        start2.l = l2(Math.pow(t, y4));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n2) {
  var samples = new Array(n2);
  for (var i = 0; i < n2; ++i)
    samples[i] = interpolator(i / (n2 - 1));
  return samples;
}

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now2() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now2() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now2();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now3 = clock.now(), delay = now3 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now3;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n2, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick2, self2.delay, self2.time);
        tick2(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n2 = self2.tween.length);
    for (i = 0, j = -1; i < n2; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick2(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n2 = tween.length;
    while (++i < n2) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n2 = tween1.length; i < n2; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n2 = tween1.length; i < n2; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n2)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n2 = tween.length, t; i < n2; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a2, b) {
  var c3;
  return (typeof b === "number" ? number_default2 : b instanceof color ? rgb_default : (c3 = color(b)) ? (b = c3, rgb_default) : string_default)(a2, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match2) {
  if (typeof match2 !== "function")
    match2 = matcher_default(match2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n2; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i = 0; i < n2; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        for (var children3 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l2 = children3.length; k < l2; ++k) {
          if (child = children3[k]) {
            schedule_default(child, name, id2, k, children3, inherit2);
          }
        }
        subgroups.push(children3);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now2(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max: max2, min } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x4, e) {
    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e) {
    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x4, y4) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x4, y4) {
    this._ += "L" + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  quadraticCurveTo: function(x1, y1, x4, y4) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  bezierCurveTo: function(x1, y1, x22, y22, x4, y4) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x4) + "," + (this._y1 = +y4);
  },
  arcTo: function(x1, y1, x22, y22, r) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x4 + dx, y0 = y4 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x4 - dx) + "," + (y4 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x4 + r * Math.cos(a1)) + "," + (this._y1 = y4 + r * Math.sin(a1));
    }
  },
  rect: function(x4, y4, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y4) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/d3-force/src/center.js
function center_default(x4, y4) {
  var nodes, strength = 1;
  if (x4 == null)
    x4 = 0;
  if (y4 == null)
    y4 = 0;
  function force() {
    var i, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n2; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x4) * strength, sy = (sy / n2 - y4) * strength, i = 0; i < n2; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x4 = +_, force) : x4;
  };
  force.y = function(_) {
    return arguments.length ? (y4 = +_, force) : y4;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x4 = +this._x.call(null, d), y4 = +this._y.call(null, d);
  return add(this.cover(x4, y4), x4, y4, d);
}
function add(tree, x4, y4, d) {
  if (isNaN(x4) || isNaN(y4))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x4 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x4 === xp && y4 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x4 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n2 = data.length, x4, y4, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i = 0; i < n2; ++i) {
    if (isNaN(x4 = +this._x.call(null, d = data[i])) || isNaN(y4 = +this._y.call(null, d)))
      continue;
    xz[i] = x4;
    yz[i] = y4;
    if (x4 < x0)
      x0 = x4;
    if (x4 > x1)
      x1 = x4;
    if (y4 < y0)
      y0 = y4;
    if (y4 > y1)
      y1 = y4;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i = 0; i < n2; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x4, y4) {
  if (isNaN(x4 = +x4) || isNaN(y4 = +y4))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x4)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
  } else {
    var z = x1 - x0 || 1, node = this._root, parent, i;
    while (x0 > x4 || x4 >= x1 || y0 > y4 || y4 >= y1) {
      i = (y4 < y0) << 1 | x4 < x0;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x1 = x0 + z, y1 = y0 + z;
          break;
        case 1:
          x0 = x1 - z, y1 = y0 + z;
          break;
        case 2:
          x1 = x0 + z, y0 = y1 - z;
          break;
        case 3:
          x0 = x1 - z, y0 = y1 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x4, y4, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x0, y0, x32, y32));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x4 - radius, y0 = y4 - radius;
    x32 = x4 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x1, ym, xm, y22),
        new quad_default(node[1], xm, y1, x22, ym),
        new quad_default(node[0], x1, y1, xm, ym)
      );
      if (i = (y4 >= ym) << 1 | x4 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x4 - +this._x.call(null, node.data), dy = y4 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x4 - d, y0 = y4 - d;
        x32 = x4 + d, y32 = y4 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d) {
  if (isNaN(x4 = +this._x.call(null, d)) || isNaN(y4 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x4, y4, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x4 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y4 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n2 = data.length; i < n2; ++i)
    this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x4, y4) {
  var tree = new Quadtree(x4 == null ? defaultX : x4, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x4, y4, x0, y0, x1, y1) {
  this._x = x4;
  this._y = y4;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy3;
  if (!node.length)
    return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default2;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default5(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x(d) {
  return d.x + d.vx;
}
function y(d) {
  return d.y + d.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function")
    radius = constant_default5(radius == null ? 1 : +radius);
  function force() {
    var i, n2 = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n2; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }
    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x4 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l2 = x4 * x4 + y4 * y4;
          if (l2 < r * r) {
            if (x4 === 0)
              x4 = jiggle_default(random), l2 += x4 * x4;
            if (y4 === 0)
              y4 = jiggle_default(random), l2 += y4 * y4;
            l2 = (r - (l2 = Math.sqrt(l2))) / l2 * strength;
            node.vx += (x4 *= l2) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y4 *= l2) * r;
            data.vx -= x4 * (r = 1 - r);
            data.vy -= y4 * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n2 = nodes.length, node;
    radii = new Array(n2);
    for (i = 0; i < n2; ++i)
      node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant_default5(+_), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id2 = index, strength = defaultStrength, strengths, distance = constant_default5(30), distances, nodes, count2, bias, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n2 = links.length; k < iterations; ++k) {
      for (var i = 0, link2, source, target, x4, y4, l2, b; i < n2; ++i) {
        link2 = links[i], source = link2.source, target = link2.target;
        x4 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y4 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l2 = Math.sqrt(x4 * x4 + y4 * y4);
        l2 = (l2 - distances[i]) / l2 * alpha * strengths[i];
        x4 *= l2, y4 *= l2;
        target.vx -= x4 * (b = bias[i]);
        target.vy -= y4 * b;
        source.vx += x4 * (b = 1 - b);
        source.vy += y4 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n2 = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link2;
    for (i = 0, count2 = new Array(n2); i < m2; ++i) {
      link2 = links[i], link2.index = i;
      if (typeof link2.source !== "object")
        link2.source = find2(nodeById, link2.source);
      if (typeof link2.target !== "object")
        link2.target = find2(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link2 = links[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n2 = links.length; i < n2; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n2 = links.length; i < n2; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id2 = _, force) : id2;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default5(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default5(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a * s2 + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x2(d) {
  return d.x;
}
function y2(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick2();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick2(iterations) {
    var i, n2 = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n2; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function(x4, y4, radius) {
      var i = 0, n2 = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n2; ++i) {
        node = nodes[i];
        dx = x4 - node.x;
        dy = y4 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default5(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n2; ++i)
      node = nodes[i], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i = 0; i < n2; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c3, weight = 0, x4, y4, i;
    if (quad.length) {
      for (x4 = y4 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c3 = Math.abs(q.value))) {
          strength2 += q.value, weight += c3, x4 += c3 * q.x, y4 += c3 * q.y;
        }
      }
      quad.x = x4 / weight;
      quad.y = y4 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _, x22) {
    if (!quad.value)
      return true;
    var x4 = quad.x - node.x, y4 = quad.y - node.y, w = x22 - x1, l2 = x4 * x4 + y4 * y4;
    if (w * w / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x4 === 0)
          x4 = jiggle_default(random), l2 += x4 * x4;
        if (y4 === 0)
          y4 = jiggle_default(random), l2 += y4 * y4;
        if (l2 < distanceMin2)
          l2 = Math.sqrt(distanceMin2 * l2);
        node.vx += x4 * quad.value * alpha / l2;
        node.vy += y4 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x4 === 0)
        x4 = jiggle_default(random), l2 += x4 * x4;
      if (y4 === 0)
        y4 = jiggle_default(random), l2 += y4 * y4;
      if (l2 < distanceMin2)
        l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l2;
        node.vx += x4 * w;
        node.vy += y4 * w;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default5(+_), initialize(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p) {
  if ((i = (x4 = p ? x4.toExponential(p - 1) : x4.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x4.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x4.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p) {
  var d = formatDecimalParts(x4, p);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p) => (x4 * 100).toFixed(p),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p) => x4.toExponential(p),
  "f": (x4, p) => x4.toFixed(p),
  "g": (x4, p) => x4.toPrecision(p),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p) => formatRounded_default(x4 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x4) {
  return x4;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n2, c3;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n2 = value.length;
          while (++i < n2) {
            if (c3 = value.charCodeAt(i), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale2({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale2(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function meanX(children3) {
  return children3.reduce(meanXReduce, 0) / children3.length;
}
function meanXReduce(x4, c3) {
  return x4 + c3.x;
}
function maxY(children3) {
  return 1 + children3.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c3) {
  return Math.max(y4, c3.y);
}
function leafLeft(node) {
  var children3;
  while (children3 = node.children)
    node = children3[0];
  return node;
}
function leafRight(node) {
  var children3;
  while (children3 = node.children)
    node = children3[children3.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x4 = 0;
    root2.eachAfter(function(node) {
      var children3 = node.children;
      if (children3) {
        node.x = meanX(children3);
        node.y = maxY(children3);
      } else {
        node.x = previousNode ? x4 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root2), right = leafRight(root2), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x4) {
    return arguments.length ? (separation = x4, cluster) : separation;
  };
  cluster.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum = 0, children3 = node.children, i = children3 && children3.length;
  if (!i)
    sum = 1;
  else
    while (--i >= 0)
      sum += children3[i].value;
  node.value = sum;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children3, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children3 = node.children) {
      for (i = children3.length - 1; i >= 0; --i) {
        nodes.push(children3[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children3, i, n2, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children3 = node.children) {
      for (i = 0, n2 = children3.length; i < n2; ++i) {
        nodes.push(children3[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0, children3 = node.children, i = children3 && children3.length;
    while (--i >= 0)
      sum += children3[i].value;
    node.value = sum;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b) {
  if (a2 === b)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b.ancestors(), c3 = null;
  a2 = aNodes.pop();
  b = bNodes.pop();
  while (a2 === b) {
    c3 = a2;
    a2 = aNodes.pop();
    b = bNodes.pop();
  }
  return c3;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children3, i, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children3 = node.children) {
        for (i = 0, n2 = children3.length; i < n2; ++i) {
          next.push(children3[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children3) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children3 === void 0)
      children3 = mapChildren;
  } else if (children3 === void 0) {
    children3 = objectChildren;
  }
  var root2 = new Node(data), node, nodes = [root2], child, childs, i, n2;
  while (node = nodes.pop()) {
    if ((childs = children3(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n2 - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default2,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/accessors.js
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default6(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n2) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding = 0, round = false;
  function partition(root2) {
    var n2 = root2.height + 1;
    root2.x0 = root2.y0 = padding;
    root2.x1 = dx;
    root2.y1 = dy / n2;
    root2.eachBefore(positionNode(dy, n2));
    if (round)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(dy2, n2) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n2, node.x1, dy2 * (node.depth + 2) / n2);
      }
      var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition.round = function(x4) {
    return arguments.length ? (round = !!x4, partition) : round;
  };
  partition.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], partition) : [dx, dy];
  };
  partition.padding = function(x4) {
    return arguments.length ? (padding = +x4, partition) : padding;
  };
  return partition;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId;
  function stratify2(data) {
    var nodes = Array.from(data), n2 = nodes.length, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    for (i = 0; i < n2; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = id2(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n2; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n2 > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x4) {
    return arguments.length ? (id2 = required(x4), stratify2) : id2;
  };
  stratify2.parentId = function(x4) {
    return arguments.length ? (parentId = required(x4), stratify2) : parentId;
  };
  return stratify2;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children3 = v.children;
  return children3 ? children3[0] : v.t;
}
function nextRight(v) {
  var children3 = v.children;
  return children3 ? children3[children3.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children3 = v.children, i = children3.length, w;
  while (--i >= 0) {
    w = children3[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children3, i, n2;
  while (node = nodes.pop()) {
    if (children3 = node._.children) {
      node.children = new Array(n2 = children3.length);
      for (i = n2 - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children3[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s2 = left === right ? 1 : separation(left, right) / 2, tx = s2 - left.x, kx = dx / (right.x + s2 + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children3 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children3) {
      executeShifts(v);
      var midpoint = (children3[0].z + children3[children3.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x4) {
    return arguments.length ? (separation = x4, tree) : separation;
  };
  tree.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n2) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else
      slice_default(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function(x4) {
    return custom((x4 = +x4) > 1 ? x4 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x4) {
    return arguments.length ? (round = !!x4, treemap) : round;
  };
  treemap.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x4) {
    return arguments.length ? (tile = required(x4), treemap) : tile;
  };
  treemap.padding = function(x4) {
    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x4) {
    return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x4) {
    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x4) {
    return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x4) {
    return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x4) {
    return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x4) {
    return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default6(+x4), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, i, n2 = nodes.length, sum, sums = new Array(n2 + 1);
  for (sums[0] = sum = i = 0; i < n2; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }
  partition(0, n2, parent.value, x0, y0, x1, y1);
  function partition(i2, j, value, x02, y02, x12, y12) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x02, node.y0 = y02;
      node.x1 = x12, node.y1 = y12;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget)
        k = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
    if (x12 - x02 > y12 - y02) {
      var xk = value ? (x02 * valueRight + x12 * valueLeft) / value : x12;
      partition(i2, k, valueLeft, x02, y02, xk, y12);
      partition(k, j, valueRight, xk, y02, x12, y12);
    } else {
      var yk = value ? (y02 * valueRight + y12 * valueLeft) / value : y12;
      partition(i2, k, valueLeft, x02, y02, x12, yk);
      partition(k, j, valueRight, x02, yk, x12, y12);
    }
  }
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = /* @__PURE__ */ new Map(), domain = [], range = [], unknown = implicit;
  function scale(d) {
    var key = d + "", i = index2.get(key);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index2.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = value + "";
      if (index2.has(key))
        continue;
      index2.set(key, domain.push(value));
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n2 = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range_default(n2).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-scale/src/number.js
function number(x4) {
  return +x4;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x4) {
  return x4;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x4) {
    return (x4 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x4) {
    return Math.max(a2, Math.min(b, x4));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j) - 1;
    return r[i2](d[i2](x4));
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity2, piecewise, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range.length);
    if (clamp !== identity2)
      clamp = clamper(domain[0], domain[n2 - 1]);
    piecewise = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate)))(transform2(clamp(x4)));
  }
  scale.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform2), number_default2)))(y4)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks_default(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy2(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n2 = specifier.length / 6 | 0, colors = new Array(n2), i = 0;
  while (i < n2)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c2 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c2.h = 360 * t - 100;
  c2.s = 1.5 - 1.5 * ts;
  c2.l = 0.8 - 0.9 * ts;
  return c2 + "";
}

// node_modules/d3-shape/src/constant.js
function constant_default7(x4) {
  return function constant() {
    return x4;
  };
}

// node_modules/d3-shape/src/math.js
var abs2 = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max3 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon3 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi2 : Math.acos(x4);
}
function asin(x4) {
  return x4 >= 1 ? halfPi : x4 <= -1 ? -halfPi : Math.asin(x4);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x22, y22, x32, y32) {
  var x10 = x1 - x0, y10 = y1 - y0, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon3)
    return;
  t = (x322 * (y0 - y22) - y322 * (x0 - x22)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max3(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default7(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs2(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path_default();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon3))
      context.moveTo(0, 0);
    else if (da > tau2 - epsilon3) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon3) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon3 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs2(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon3) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon3)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon3)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon3) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi2 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min2(rc, (r0 - lc) / (kc - 1));
          rc1 = min2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon3))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon3) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc)
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon3) || !(da0 > epsilon3))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon3) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc)
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default7(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default7(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default7(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default7(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default7(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default2(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x3(p) {
  return p[0];
}
function y3(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x4, y4) {
  var defined = constant_default7(true), context = null, curve = linear_default, output = null;
  x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x3 : constant_default7(x4);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default7(y4);
  function line(data) {
    var i, n2 = (data = array_default2(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path_default());
    for (i = 0; i <= n2; ++i) {
      if (!(i < n2 && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x4(d, i, data), +y4(d, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default7(+_), line) : x4;
  };
  line.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default7(+_), line) : y4;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default7(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l2) {
  var c3 = l2.curve;
  l2.angle = l2.x, delete l2.x;
  l2.radius = l2.y, delete l2.y;
  l2.curve = function(_) {
    return arguments.length ? c3(curveRadial(_)) : c3()._curve;
  };
  return l2;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/link/index.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x4 = x3, y4 = y3, context = null;
  function link2() {
    var buffer, argv = slice.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv);
    if (!context)
      context = buffer = path_default();
    curve(context, +x4.apply(this, (argv[0] = s2, argv)), +y4.apply(this, argv), +x4.apply(this, (argv[0] = t, argv)), +y4.apply(this, argv));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default7(+_), link2) : x4;
  };
  link2.y = function(_) {
    return arguments.length ? (y4 = typeof _ === "function" ? _ : constant_default7(+_), link2) : y4;
  };
  link2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function linkHorizontal() {
  return link(curveHorizontal);
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j = x4.length - 1;
    if (j > 0) {
      var x0 = x4[0], y0 = y4[0], dx = x4[j] - x0, dy = y4[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default = function custom2(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom2(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-zoom/src/constant.js
var constant_default8 = (x4) => () => x4;

// node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x4, y4) {
  this.k = k;
  this.x = x4;
  this.y = y4;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x4, y4) {
    return x4 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x4, this.y + this.k * y4);
  },
  apply: function(point3) {
    return [point3[0] * this.k + this.x, point3[1] * this.k + this.y];
  },
  applyX: function(x4) {
    return x4 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x4) {
    return (x4 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x4) {
    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity3 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity3;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation3(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity3;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point3, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point3, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x4, y4, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x4 === "function" ? x4.apply(this, arguments) : x4,
        typeof y4 === "function" ? y4.apply(this, arguments) : y4
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x4, y4, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity3.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x4 === "function" ? -x4.apply(this, arguments) : -x4,
        typeof y4 === "function" ? -y4.apply(this, arguments) : -y4
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x4 = p0[0] - p1[0] * transform2.k, y4 = p0[1] - p1[1] * transform2.k;
    return x4 === transform2.x && y4 === transform2.y ? transform2 : new Transform(transform2.k, x4, y4);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point3, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point3 == null ? centroid(e) : typeof point3 === "function" ? point3.apply(that, args) : point3, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a2.invert(p).concat(w / a2.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l2 = i(t), k = w / l2[2];
          t = new Transform(k, p[0] - l2[0] * k, p[1] - l2[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new ZoomEvent(type2, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          type: type2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer_default(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default3(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var g = gesture(this, args, true).event(event), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer_default(event, currentTarget), currentTarget = event.currentTarget, x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation3(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer_default(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent_default3(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t1, p0, event);
    else
      select_default2(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n2 = touches.length, g = gesture(this, args, event.changedTouches.length === n2).event(event), started, i, t, p;
    nopropagation3(event);
    for (i = 0; i < n2; ++i) {
      t = touches[i], p = pointer_default(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t, p, l2;
    noevent_default3(event);
    for (i = 0; i < n2; ++i) {
      t = touches[i], p = pointer_default(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l2 = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l2), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t;
    nopropagation3(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n2; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select_default2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default8(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant_default8(!!_), zoom) : filter2;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default8(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default8([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}

// src/Visualisations/VisModal.ts
var import_obsidian43 = require("obsidian");

// src/Components/VisComp.svelte
var import_loglevel21 = __toESM(require_loglevel());

// src/Visualisations/ArcDiagram.ts
var arcDiagram = (graph, currFile, modal, width, height) => {
  const data = graphlibToD3(graph);
  const margin = { top: 20, right: 20, bottom: 20, left: 150 };
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width);
  const nodes = data.nodes.map(({ id: id2, name }) => ({
    id: id2,
    name,
    sourceLinks: [],
    targetLinks: []
  }));
  const nodeById = new Map(nodes.map((d) => [d.id, d]));
  const links = data.links.map(({ source, target }) => ({
    source: nodeById.get(source),
    target: nodeById.get(target)
  }));
  for (const link2 of links) {
    const { source, target } = link2;
    source.sourceLinks.push(link2);
    target.targetLinks.push(link2);
  }
  svg.append("style").text(`

path {
  stroke: #808080;
  opacity: 0.8;
}

text {
  stroke: var(--text-a);
  opacity: 0.8;
}


.hover g.primary text {
  fill: black;
}

.hover g.secondary text {
  fill: #333;
}

.hover .secondary {
    color: red;
}

.hover path.primary {
  stroke: #333;
  stroke-opacity: 1;
}

.hover rect {
    opacity: 1;
    cursor: pointer;
}

`);
  const y4 = point(nodes.map((d) => d.name).sort(ascending_default), [
    margin.top,
    height - margin.bottom
  ]);
  const label = svg.append("g").attr("font-family", "sans-serif").attr("font-size", 10).attr("text-anchor", "end").selectAll("g").data(nodes).join("g").attr("transform", (d) => `translate(${margin.left},${d.y = y4(d.name)})`).call(
    (g) => g.append("text").attr("x", -6).attr("dy", "0.35em").text((d) => d.name)
  ).call(
    (g) => g.append("circle").attr("r", 3)
    // .attr("fill", (d) => color(d.group))
  );
  const path2 = svg.insert("g", "*").attr("fill", "none").attr("stroke-opacity", 0.6).attr("stroke-width", 1.5).selectAll("path").data(links).join("path").attr("d", arc);
  const step = 104;
  const nodeClick = (event, dest) => {
    openOrSwitch(dest, event);
    modal.close();
  };
  const overlay = svg.append("g").attr("fill", "none").attr("pointer-events", "all").selectAll("rect").data(nodes).join("rect").attr("width", margin.left + 40).attr("height", step).attr("y", (d) => y4(d.name) - step / 2).on("mouseover", (d) => {
    svg.classed("hover", true);
    label.classed("primary", (n2) => n2 === d);
    label.classed(
      "secondary",
      (n2) => n2.sourceLinks.some((l2) => l2.target === d) || n2.targetLinks.some((l2) => l2.source === d)
    );
    path2.classed("primary", (l2) => l2.source === d || l2.target === d).filter(".primary").raise();
  }).on("mouseout", (d) => {
    svg.classed("hover", false);
    label.classed("primary", false);
    label.classed("secondary", false);
    path2.classed("primary", false).order();
  }).on("click", (event, d) => {
    nodeClick(event, d.name);
  });
  function arc(d) {
    const y1 = d.source.y;
    const y22 = d.target.y;
    const r = Math.abs(y22 - y1) / 2;
    return `M${margin.left},${y1}A${r},${r} 0,0,${y1 < y22 ? 1 : 0} ${margin.left},${y22}`;
  }
  function zoomed({ transform: transform2 }) {
    svg.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 8]).on("zoom", zoomed)
  );
};

// src/Visualisations/CirclePacking.ts
var circlePacking = (graph, currFile, modal, width, height) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hierarchy2 = stratify_default()(flatAdj);
  console.log({ hierarchy: hierarchy2 });
  const adjList = bfsAdjList(graph, currFile.basename);
  console.log({ adjList });
  const noDoubles = [...adjList];
  noDoubles.forEach((a2, i) => {
    if (noDoubles.some((b, j) => i !== j && a2.name === b.name)) {
      const index2 = noDoubles.findIndex((b, j) => i !== j && a2.name === b.name);
      noDoubles.splice(index2, 1);
    }
  });
  console.log({ noDoubles });
  const linkArr = noDoubles.map((d) => {
    return { source: d.name, target: d.parentId };
  });
  const links = linkArr.map((d) => Object.create(d));
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width);
  const nodeColour = getComputedStyle(document.body).getPropertyValue(
    "--text-accent"
  );
  const node = svg.append("g").selectAll("circle").data(noDoubles).join("circle").attr("r", (d) => Math.round(d.height / 10) + 10).attr("cx", width / 2).attr("cy", height / 2).style("fill", nodeColour).style("fill-opacity", 0.6).attr("stroke", nodeColour).style("stroke-width", 4);
  node.attr("aria-label", (d) => d.name);
  const nodeClick = (event, dest) => {
    const currFile2 = getCurrFile();
    openOrSwitch(dest, event);
    modal.close();
  };
  node.on("click", (event, d) => {
    nodeClick(event, d.name);
  });
  const link2 = svg.append("g").attr("stroke", "#868282").attr("stroke-opacity", 0.6).selectAll("line").data(links).join("line").attr("stroke-width", 0.8);
  const simulation = simulation_default().force(
    "center",
    center_default().x(width / 2).y(height / 2)
  ).force("charge", manyBody_default().strength(0.5)).force(
    "collide",
    collide_default().strength(0.025).radius(30).iterations(1)
  );
  simulation.nodes(noDoubles).on("tick", function(d) {
    node.attr("cx", (d2) => d2.x).attr("cy", (d2) => d2.y);
  });
  function zoomed({ transform: transform2 }) {
    node.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 8]).on("zoom", zoomed)
  );
  const drag = (simulation2) => {
    function dragstarted(event, d) {
      if (!event.active)
        simulation2.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    function dragended(event, d) {
      if (!event.active)
        simulation2.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
    return drag_default().on("start", dragstarted).on("drag", dragged).on("end", dragended);
  };
  node.call(drag(simulation));
};

// src/Visualisations/EdgeBundling.ts
var edgeBundling = (graph, currFile, modal, width, height) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hier = stratify_default()(flatAdj);
  console.log({ hier });
  const PADDING_BUBBLE = 15;
  const PADDING_LABEL = 30;
  const BUBBLE_SIZE_MIN = 4;
  const BUBBLE_SIZE_MAX = 20;
  var diameter = 560, radius = diameter / 2, innerRadius = radius - 170;
  var cluster = cluster_default().size([360, innerRadius]);
  var line = lineRadial_default().curve(bundle_default.beta(0.85)).radius(function(d) {
    return d[1];
  }).angle(function(d) {
    return d[0] / 180 * Math.PI;
  });
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width).append("g").attr("transform", "translate(" + radius + "," + radius + ")");
  var link2 = svg.append("g").selectAll(".link"), label = svg.append("g").selectAll(".label"), bubble = svg.append("g").selectAll(".bubble");
  var bubbleSizeScale = linear2().domain([0, 100]).range([BUBBLE_SIZE_MIN, BUBBLE_SIZE_MAX]);
  var root2 = packageHierarchy(hier).sum(function(d) {
    console.log(d);
    return d.height;
  });
  cluster(root2);
  const leaves = root2.leaves();
  const _link = link2.data(packageImports(leaves)).enter().append("path").each(function(d) {
    d.source = d[0], d.target = d[d.length - 1];
  }).attr("class", "link").attr("d", line).attr("fill", "none").attr("stroke", "black");
  const _label = label.data(leaves).enter().append("text").attr("class", "label").attr("dy", "0.31em").attr("transform", function(d) {
    return "rotate(" + (d.x - 90) + ")translate(" + (d.y + PADDING_LABEL) + ",0)" + (d.x < 180 ? "" : "rotate(180)");
  }).attr("text-anchor", function(d) {
    return d.x < 180 ? "start" : "end";
  }).text(function(d) {
    return d.data.key;
  });
  const _bubble = bubble.data(leaves).enter().append("circle").attr("class", "bubble").attr("transform", function(d) {
    return "rotate(" + (d.x - 90) + ")translate(" + (d.y + PADDING_BUBBLE) + ",0)";
  }).attr("r", (d) => bubbleSizeScale(d.value)).attr("stroke", "black").attr("fill", "#69a3b2").style("opacity", 0.2);
  function packageHierarchy(classes) {
    var map2 = {};
    function find3(name, data) {
      var node = map2[name], i;
      if (!node) {
        node = map2[name] = data || { name, children: [] };
        if (name.length) {
          node.parent = find3(name.substring(0, i = name.lastIndexOf(".")));
          node.parent.children.push(node);
          node.key = name.substring(i + 1);
        }
      }
      return node;
    }
    classes.forEach(function(d) {
      find3(d.name, d);
    });
    return hierarchy(map2[""]);
  }
  function packageImports(nodes) {
    var map2 = {}, imports = [];
    nodes.forEach(function(d) {
      map2[d.data.name] = d;
    });
    nodes.forEach(function(d) {
      if (d.data.imports)
        d.data.imports.forEach(function(i) {
          imports.push(map2[d.data.name].path(map2[i]));
        });
    });
    return imports;
  }
};

// src/Visualisations/ForceDirectedG.ts
var forceDirectedG = (graph, currFile, modal, width, height) => {
  const { settings } = modal.plugin;
  let nodeToGetTo = currFile.basename;
  console.log({ nodeToGetTo });
  console.time("Find all paths");
  console.timeEnd("Find all paths");
  const defaultNodeColour = getComputedStyle(document.body).getPropertyValue(
    "--text-accent"
  );
  let currNodeColour = defaultNodeColour;
  const colourChangeInput = select_default2(".d3-graph").append("input").attr("type", "color");
  colourChangeInput.on("change", function changeColor(el) {
    currNodeColour = el.target.value;
    node.transition().duration(300).style("fill", (d) => {
      if (d.index === currNodeIndex)
        return;
      return currNodeColour;
    });
  });
  const data = graphlibToD3(graph);
  const links = data.links.map((d) => Object.create(d));
  const currNode = data.nodes.find((node2) => node2.name === currFile.basename);
  let currNodeIndex;
  if (!currNode) {
    const id2 = data.nodes.length;
    data.nodes.push({ id: id2, name: currFile.basename });
    currNodeIndex = id2;
  } else {
    currNodeIndex = currNode.id;
  }
  const nodes = data.nodes.map((d) => Object.create(d));
  const simulation = simulation_default(nodes).force(
    "link",
    link_default(links).id((d) => d.id)
  ).force("charge", manyBody_default().strength(-8)).force("center", center_default(width / 2, height / 2).strength(0.5));
  const drag = (simulation2) => {
    function dragstarted(event, d) {
      if (!event.active)
        simulation2.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }
    function dragended(event, d) {
      if (!event.active)
        simulation2.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }
    return drag_default().on("start", dragstarted).on("drag", dragged).on("end", dragended);
  };
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width).attr("class", "forceDirectedG");
  const link2 = svg.append("g").attr("stroke", "#868282").attr("stroke-opacity", 0.6).selectAll("line").data(links).join("line").attr("stroke-width", 0.8).attr("marker-end", "url(#end)");
  var path2 = svg.append("svg:g").selectAll("path").data(links).enter().append("svg:path").attr("class", "link").attr("marker-end", "url(#end)");
  const arrowHead = svg.append("svg:defs").selectAll("marker").data(["end"]).enter().append("svg:marker").attr("id", String).attr("viewBox", "0 -5 10 10").attr("refX", 20).attr("refY", 0.1).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").attr("stroke-width", 10).append("svg:path").attr("d", "M0,-5L10,0L0,5");
  const nameFromIndex = (d) => data.nodes.find((node2) => node2.id === d.index).name;
  const indexFromName = (name) => data.nodes.find((node2) => node2.name === name).id;
  const node = svg.append("g").selectAll("circle").data(nodes).join("circle").attr("r", 5).attr("fill", (d) => {
    if (nameFromIndex(d) === currFile.basename) {
      return "#ffffff";
    } else {
      return currNodeColour;
    }
  }).call(drag(simulation));
  node.attr("aria-label", (d) => d.name);
  const nodeClick = (event, dest) => {
    openOrSwitch(dest, event);
    modal.close();
  };
  node.on("click", (event, d) => {
    nodeClick(event, d.name);
  });
  node.on("mousedown", (event, d) => {
    if (event.button === 2) {
      nodeToGetTo = d.name;
      node.style("fill", (n2) => {
        if (n2.name === nodeToGetTo) {
          return "#ff0000";
        } else
          return currNodeColour;
      });
    }
  });
  function linked(a2, b) {
    if (a2 === b)
      return true;
    const linkedArr = links.find(
      (link3) => link3.source.index === a2 && link3.target.index === b || link3.target.index === a2 && link3.source.index === b
    );
    return !!linkedArr;
  }
  node.on("mouseover", (event, d) => {
    node.transition().duration(150).style("opacity", (o) => {
      return linked(d.index, o.index) ? 1 : 0.2;
    });
    link2.transition().duration(150).style("opacity", function(o) {
      return o.source.index === d.index || o.target.index === d.index ? 1 : 0.2;
    });
    const hoveredNode = nameFromIndex(d);
  }).on("mouseout", unfocus);
  function focusNeighbours(d, event) {
  }
  function unfocus() {
    node.style("opacity", 1);
    link2.style("opacity", 1).style("stroke", "#868282");
  }
  simulation.on("tick", () => {
    link2.attr("x1", (d) => d.source.x).attr("y1", (d) => d.source.y).attr("x2", (d) => d.target.x).attr("y2", (d) => d.target.y);
    node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
  });
  function zoomed({ transform: transform2 }) {
    node.attr("transform", transform2);
    link2.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 10]).on("zoom", zoomed)
  );
  function saveGraph() {
    const clone3 = svg.clone(true);
    localStorage.setItem("FDG", JSON.stringify(clone3));
  }
};

// src/Visualisations/Icicle.ts
var icicle = (graph, currFile, modal, width, viewHeight) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hier = stratify_default()(flatAdj);
  console.log({ hier });
  const format2 = format(",d");
  const color2 = ordinal(
    quantize_default(rainbow_default, hier.children.length + 1)
  );
  const partition = (data) => {
    const root3 = hierarchy(data).sum((d) => d.value).sort((a2, b) => b.height - a2.height || b.value - a2.value);
    return partition_default().size([viewHeight, (root3.height + 1) * width / 3])(
      root3
    );
  };
  const root2 = partition(hier);
  let focus = root2;
  const svg = select_default2(".d3-graph").append("svg").attr("height", viewHeight).attr("width", width).style("font", "10px sans-serif");
  const cell = svg.selectAll("g").data(root2.descendants()).join("g").attr("transform", (d) => `translate(${d.y0},${d.x0})`);
  const rect = cell.append("rect").attr("width", (d) => d.y1 - d.y0 - 1).attr("height", (d) => rectHeight(d)).attr("fill-opacity", 0.6).attr("fill", (d) => {
    if (!d.depth)
      return "#ccc";
    while (d.depth > 1)
      d = d.parent;
    return color2(d.data.data.name);
  }).style("cursor", "pointer").on("click", clicked);
  const text2 = cell.append("text").style("user-select", "none").attr("pointer-events", "none").attr("x", 4).attr("y", 13);
  text2.append("tspan").text((d) => d.data.data.name);
  const tspan = text2.append("tspan").attr("fill-opacity", (d) => (labelVisible(d) ? 1 : 0) * 0.7).text((d) => ` ${format2(d.value)}`);
  cell.append("title").text(
    (d) => `${d.ancestors().map((d2) => d2.data.data.name)}`
  );
  function clicked(event, p) {
    console.log({ p });
    focus = focus === p ? p = p.parent : p;
    root2.each((d) => {
      d.target = {
        x0: (d.x0 - p.x0) / (p.x1 - p.x0) * viewHeight,
        x1: (d.x1 - p.x0) / (p.x1 - p.x0) * viewHeight,
        y0: d.y0 - p.y0,
        y1: d.y1 - p.y0
      };
      console.log(d.target.x0);
    });
    const t = cell.transition().duration(750).attr("transform", (d) => `translate(${d.target.y0},${d.target.x0})`);
    rect.transition(t).attr("height", (d) => rectHeight(d.target));
    text2.transition(t).attr("fill-opacity", (d) => +labelVisible(d.target));
    tspan.transition(t).attr("fill-opacity", (d) => (labelVisible(d) ? 1 : 0) * 0.7);
  }
  function rectHeight(d) {
    console.log({ d });
    return d.x1 - d.x0 - Math.min(1, (d.x1 - d.x0) / 2);
  }
  function labelVisible(d) {
    return d.y1 <= width && d.y0 >= 0 && d.x1 - d.x0 > 16;
  }
};

// src/Visualisations/RadialTree.ts
var radialTree = (graph, currFile, modal, width, height) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hierarchy2 = stratify_default()(flatAdj);
  console.log({ hierarchy: hierarchy2 });
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width);
  const root2 = hierarchy(hierarchy2, (d) => d.children).sum((d) => d.children ? 0 : 1).sort((a2, b) => a2.depth - b.depth);
  const outerRadius = width / 2;
  const innerRadius = outerRadius - 170;
  const cluster = cluster_default().size([360, innerRadius]).separation((a2, b) => 1);
  const color2 = ordinal().domain(graph.nodes()).range(category10_default);
  function maxLength(d) {
    return d.data.data.depth + (d.children ? max(d.children, maxLength) : 0);
  }
  function setRadius(d, y0, k) {
    d.radius = (y0 += d.data.data.depth) * k;
    if (d.children)
      d.children.forEach((d2) => setRadius(d2, y0, k));
  }
  function setColor(d) {
    var name = d.data.data.name;
    d.color = color2.domain().indexOf(name) >= 0 ? color2(name) : d.parent ? d.parent.color : null;
    if (d.children)
      d.children.forEach(setColor);
  }
  function linkVariable(d) {
    return linkStep(d.source.x, d.source.radius, d.target.x, d.target.radius);
  }
  function linkConstant(d) {
    return linkStep(d.source.x, d.source.y, d.target.x, d.target.y);
  }
  function linkExtensionVariable(d) {
    return linkStep(d.target.x, d.target.radius, d.target.x, innerRadius);
  }
  function linkExtensionConstant(d) {
    return linkStep(d.target.x, d.target.y, d.target.x, innerRadius);
  }
  function linkStep(startAngle, startRadius, endAngle, endRadius) {
    const c0 = Math.cos(startAngle = (startAngle - 90) / 180 * Math.PI);
    const s0 = Math.sin(startAngle);
    const c1 = Math.cos(endAngle = (endAngle - 90) / 180 * Math.PI);
    const s1 = Math.sin(endAngle);
    return "M" + startRadius * c0 + "," + startRadius * s0 + (endAngle === startAngle ? "" : "A" + startRadius + "," + startRadius + " 0 0 " + (endAngle > startAngle ? 1 : 0) + " " + startRadius * c1 + "," + startRadius * s1) + "L" + endRadius * c1 + "," + endRadius * s1;
  }
  const legend = (svg2) => {
    const g = svg2.selectAll("g").data(color2.domain()).join("g").attr(
      "transform",
      (d, i) => `translate(${-outerRadius},${-outerRadius + i * 20})`
    );
    g.append("rect").attr("width", 18).attr("height", 18).attr("fill", color2);
    g.append("text").attr("x", 24).attr("y", 9).attr("dy", "0.35em").text((d) => d);
  };
  cluster(root2);
  setRadius(root2, root2.data.data.depth = 0, innerRadius / maxLength(root2));
  setColor(root2);
  svg.append("g").call(legend);
  svg.append("style").text(`

.link--active {
stroke: #000 !important;
stroke-width: 1.5px;
}

.link-extension--active {
stroke-opacity: .6;
}

.label--active {
font-weight: bold;
}

`);
  const linkExtension = svg.append("g").attr("fill", "none").attr("stroke", "#000").attr("stroke-opacity", 0.25).selectAll("path").data(root2.links().filter((d) => !d.target.children)).join("path").each(function(d) {
    d.target.linkExtensionNode = this;
  }).attr("d", linkExtensionConstant);
  const link2 = svg.append("g").attr("fill", "none").attr("stroke", "#000").selectAll("path").data(root2.links()).join("path").each(function(d) {
    d.target.linkNode = this;
  }).attr("d", linkConstant).attr("stroke", (d) => d.target.color);
  const label = svg.append("g").selectAll("text").data(root2.leaves()).join("text").attr("dy", ".31em").attr(
    "transform",
    (d) => `rotate(${d.x - 90}) translate(${innerRadius + 4},0)${d.x < 180 ? "" : " rotate(180)"}`
  ).attr("text-anchor", (d) => d.x < 180 ? "start" : "end").text((d) => d.data.data.name).on("mouseover", mouseovered(true)).on("mouseout", mouseovered(false));
  function mouseovered(active) {
    return function(event, d) {
      select_default2(this).classed("label--active", active);
      select_default2(d.linkExtensionNode).classed("link-extension--active", active).raise();
      do
        select_default2(d.linkNode).classed("link--active", active).raise();
      while (d = d.parent);
    };
  }
  function zoomed({ transform: transform2 }) {
    linkExtension.attr("transform", transform2);
    link2.attr("transform", transform2);
    label.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 8]).on("zoom", zoomed)
  );
};

// src/Visualisations/Sunburst.ts
var sunburst = (graph, currFile, modal, width, height) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hierarchy2 = stratify_default()(flatAdj);
  console.log({ hierarchy: hierarchy2 });
  var radius = Math.min(width, height) / 2;
  var color2 = ordinal(category10_default);
  var g = select_default2("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
  var g = select_default2("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
  var g = select_default2("svg").attr("width", width).attr("height", height).append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
  var partition = partition_default().size([2 * Math.PI, radius]);
  var root2 = hierarchy(hierarchy2).sum(function(d) {
    return d.height;
  });
  partition(root2);
  var arc = arc_default().startAngle(function(d) {
    return d.x0;
  }).endAngle(function(d) {
    return d.x1;
  }).innerRadius(function(d) {
    return d.y0;
  }).outerRadius(function(d) {
    return d.y1;
  });
  g.selectAll("path").data(root2.descendants()).enter().append("path").attr("display", function(d) {
    return d.depth ? null : "none";
  }).attr("d", arc).style("stroke", "#fff").style("fill", function(d) {
    return color2((d.children ? d : d.parent).data.name);
  });
};

// src/Visualisations/TidyTree.ts
var tidyTree = (graph, currFile, modal, width, height) => {
  const tree = (data) => {
    const root3 = hierarchy(data);
    root3.dx = 10;
    root3.dy = width / (root3.height + 1);
    return tree_default().nodeSize([root3.dx, root3.dy])(root3);
  };
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hierarchy2 = stratify_default()(flatAdj);
  console.log({ hierarchy: hierarchy2 });
  const root2 = tree(hierarchy2);
  console.log(root2);
  let x0 = Infinity;
  let x1 = -x0;
  root2.each((d) => {
    if (d.x > x1)
      x1 = d.x;
    if (d.x < x0)
      x0 = d.x;
  });
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width);
  const g = svg.append("g").attr("font-family", "sans-serif").attr("font-size", 10).attr("transform", `translate(${root2.dy / 3},${root2.dx - x0})`);
  const link2 = g.append("g").attr("fill", "none").attr("stroke", "#555").attr("stroke-opacity", 0.4).attr("stroke-width", 1.5).selectAll("path").data(root2.links()).join("path").attr(
    "d",
    linkHorizontal().x((d) => d.y).y((d) => d.x)
  );
  const node = g.append("g").attr("stroke-linejoin", "round").attr("stroke-width", 10).selectAll("g").data(root2.descendants()).join("g").attr("transform", (d) => `translate(${d.y},${d.x})`);
  node.append("circle").attr("fill", (d) => d.children ? "#555" : "#999").attr("r", 10);
  node.attr("aria-label", (d) => {
    console.log(d);
    return d.data.data.name;
  });
  const nodeClick = (event, dest) => {
    openOrSwitch(dest, event);
    modal.close();
  };
  node.on("click", (event, d) => {
    console.log({ d });
    nodeClick(event, d.data.data.name);
  });
  node.append("text").attr("dy", "0.31em").attr("x", (d) => d.children ? -6 : 6).attr("text-anchor", (d) => d.children ? "end" : "start").text((d) => d.data.data.name).clone(true).lower().attr("stroke", "white");
  function zoomed({ transform: transform2 }) {
    svg.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 8]).on("zoom", zoomed)
  );
};

// src/Visualisations/TreeMap.ts
var treeMap = (graph, currFile, modal, width, height) => {
  const flatAdj = dfsFlatAdjList(graph, currFile.basename);
  console.log({ flatAdj });
  const hierarchy2 = stratify_default()(flatAdj);
  console.log({ hierarchy: hierarchy2 });
  const root2 = treemap_default().tile(binary_default).size([width, height]).padding(1).round(true)(
    hierarchy2.sum((d) => d.height).sort((a2, b) => b.height - a2.height)
  );
  const svg = select_default2(".d3-graph").append("svg").attr("height", height).attr("width", width).style("font", "10px sans-serif");
  const leaf = svg.selectAll("g").data(root2.leaves()).join("g").attr("transform", (d) => `translate(${d.x0},${d.y0})`);
  leaf.attr("aria-label", (d) => d.data.name);
  const color2 = ordinal(category10_default);
  leaf.append("rect").attr("fill", (d) => {
    while (d.depth > 1)
      d = d.parent;
    return color2(d.data.id);
  }).attr("fill-opacity", 0.6).attr("width", (d) => d.x1 - d.x0).attr("height", (d) => d.y1 - d.y0);
  leaf.append("clipPath").append("use");
  const nodeClick = (event, dest) => {
    openOrSwitch(dest, event);
    modal.close();
  };
  leaf.on("click", (event, d) => {
    console.log({ d });
    nodeClick(event, d.data.name);
  });
  function zoomed({ transform: transform2 }) {
    svg.attr("transform", transform2);
  }
  svg.call(
    zoom_default2().extent([
      [0, 0],
      [width, height]
    ]).scaleExtent([0.5, 8]).on("zoom", zoomed)
  );
};

// src/Components/VisComp.svelte
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i].text;
  child_ctx[24] = list[i].options;
  child_ctx[25] = list[i].val;
  child_ctx[26] = list;
  child_ctx[27] = i;
  return child_ctx;
}
function get_each_context_17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function create_each_block_17(ctx) {
  let option;
  let t_value = (
    /*op*/
    ctx[28] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*op*/
      ctx[28];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*selectors*/
      1 && t_value !== (t_value = /*op*/
      ctx2[28] + ""))
        set_data(t, t_value);
      if (dirty & /*selectors*/
      1 && option_value_value !== (option_value_value = /*op*/
      ctx2[28])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block10(ctx) {
  let span;
  let t0_value = (
    /*text*/
    ctx[23] + ""
  );
  let t0;
  let t1;
  let select;
  let t2;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*options*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_17(get_each_context_17(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[2].call(
      select,
      /*each_value*/
      ctx[26],
      /*each_index*/
      ctx[27]
    );
  }
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(":\n      ");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (
        /*val*/
        ctx[25] === void 0
      )
        add_render_callback(select_change_handler);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*val*/
        ctx[25],
        true
      );
      append(span, t2);
      if (!mounted) {
        dispose = listen(select, "change", select_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*selectors*/
      1 && t0_value !== (t0_value = /*text*/
      ctx[23] + ""))
        set_data(t0, t0_value);
      if (dirty & /*selectors*/
      1) {
        each_value_1 = /*options*/
        ctx[24];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_17(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_17(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*selectors*/
      1) {
        select_option(
          select,
          /*val*/
          ctx[25]
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment23(ctx) {
  let div0;
  let t;
  let div1;
  let each_value = (
    /*selectors*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  return {
    c() {
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div1 = element("div");
      attr(div1, "class", "d3-graph");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      insert(target, t, anchor);
      insert(target, div1, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*selectors*/
      1) {
        each_value = /*selectors*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let argArr;
  ;
  ;
  let { modal } = $$props;
  const { plugin } = modal;
  const { mainG, settings } = plugin;
  const { visGraph, visRelation, visClosed, visAll } = settings;
  const currFile = getCurrFile();
  const selectors = [
    {
      text: "Type",
      options: VISTYPES,
      val: visGraph
    },
    {
      text: "Relation",
      options: RELATIONS,
      val: visRelation
    },
    {
      text: "Close Implied",
      options: REAlCLOSED,
      val: visClosed
    },
    {
      text: "No Unlinked",
      options: ALLUNLINKED,
      val: visAll
    }
  ];
  const [width, height] = [Math.round(window.innerWidth / 1.3), Math.round(window.innerHeight / 1.3)];
  const [up, same, down] = [
    getSubInDirs(mainG, "up"),
    getSubInDirs(mainG, "same"),
    getSubInDirs(mainG, "down")
  ];
  const [closedParentNoSingle, closedSiblingNoSingle, closedChildNoSingle] = [
    closeImpliedLinks(up, down),
    closeImpliedLinks(same, same),
    closeImpliedLinks(down, up)
  ];
  const graphs = {
    Parent: {
      Real: {
        All: up,
        "No Unlinked": removeUnlinkedNodes(up)
      },
      Closed: {
        All: closedParentNoSingle,
        "No Unlinked": removeUnlinkedNodes(closedParentNoSingle)
      }
    },
    Sibling: {
      Real: {
        All: same,
        "No Unlinked": removeUnlinkedNodes(same)
      },
      Closed: {
        All: closedSiblingNoSingle,
        "No Unlinked": removeUnlinkedNodes(closedSiblingNoSingle)
      }
    },
    Child: {
      Real: {
        All: down,
        "No Unlinked": removeUnlinkedNodes(down)
      },
      Closed: {
        All: closedChildNoSingle,
        "No Unlinked": removeUnlinkedNodes(closedChildNoSingle)
      }
    }
  };
  const types = {
    "Force Directed Graph": forceDirectedG,
    "Tidy Tree": tidyTree,
    "Circle Packing": circlePacking,
    "Edge Bundling": edgeBundling,
    "Arc Diagram": arcDiagram,
    Sunburst: sunburst,
    "Tree Map": treeMap,
    Icicle: icicle,
    "Radial Tree": radialTree
  };
  function draw(type2) {
    if (!document.querySelector(".d3-graph")) {
      setTimeout(
        () => {
          var _a;
          (_a = document.querySelector(".d3-graph")) === null || _a === void 0 ? void 0 : _a.empty();
          try {
            types[type2](...argArr);
          } catch (error6) {
            (0, import_loglevel21.warn)(error6);
          }
        },
        10
      );
    } else {
      document.querySelector(".d3-graph").empty();
      try {
        types[type2](...argArr);
      } catch (error6) {
        (0, import_loglevel21.warn)(error6);
      }
    }
  }
  function select_change_handler(each_value, each_index) {
    each_value[each_index].val = select_value(this);
    $$invalidate(0, selectors);
  }
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(1, modal = $$props2.modal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selectors, modal*/
    3) {
      $:
        argArr = [
          graphs[selectors[1].val][selectors[2].val][selectors[3].val],
          app,
          currFile,
          modal,
          width,
          height
        ];
    }
    if ($$self.$$.dirty & /*selectors*/
    1) {
      $:
        draw(selectors[0].val);
    }
  };
  return [selectors, modal, select_change_handler];
}
var VisComp = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, { modal: 1 });
  }
};
var VisComp_default = VisComp;

// src/Visualisations/VisModal.ts
function graphlibToD3(g) {
  const d3Graph = { nodes: [], links: [] };
  const nodeIDs = {};
  g.nodes().forEach((node, i) => {
    d3Graph.nodes.push({ id: i, name: node });
    nodeIDs[node] = i;
  });
  g.forEachEdge((k, a2, s2, t) => {
    d3Graph.links.push({
      source: nodeIDs[s2],
      target: nodeIDs[t]
    });
  });
  return d3Graph;
}
function bfsAdjList(g, startNode) {
  const queue = [startNode];
  const adjList = [];
  let i = 0;
  while (queue.length && i < 1e3) {
    i++;
    const currNode = queue.shift();
    const neighbours = {
      succs: getOutNeighbours(g, currNode),
      pres: getInNeighbours(g, currNode)
    };
    console.log({ currNode, neighbours });
    const next = {
      name: currNode,
      pres: void 0,
      succs: void 0,
      parentId: i,
      depth: i
    };
    if (neighbours.succs.length) {
      next.succs = neighbours.succs;
      queue.push(...neighbours.succs);
    }
    if (neighbours.pres.length) {
      next.pres = neighbours.pres;
    }
    adjList.push(next);
  }
  const maxDepth = adjList.sort((a2, b) => a2.depth - b.depth).last().depth;
  adjList.forEach((item) => item.height = maxDepth - item.depth);
  return adjList;
}
function dfsFlatAdjList(g, startNode) {
  const nodes = g.nodes();
  const nodeCount = nodes.length;
  const visits = {};
  nodes.forEach((node, i2) => {
    visits[node] = nodeCount * i2;
  });
  const queue = [startNode];
  const adjList = [];
  let depth = 1;
  let i = 0;
  while (queue.length && i < 1e3) {
    i++;
    const currNode = queue.shift();
    const next = getOutNeighbours(g, currNode);
    if (next.length) {
      queue.unshift(...next);
      next.forEach((succ) => {
        const parentId = nodeCount * nodes.indexOf(succ);
        if (!adjList.some(
          (adjItem) => adjItem.name === currNode && adjItem.parentId === parentId
        )) {
          adjList.push({
            id: visits[currNode],
            name: currNode,
            parentId,
            depth
          });
          visits[currNode]++;
        }
      });
      depth++;
    } else {
      adjList.push({
        id: visits[currNode],
        name: currNode,
        parentId: 999999999,
        depth
      });
      depth = 1;
      visits[currNode]++;
    }
  }
  adjList.push({
    id: 999999999,
    name: "CONTAINER",
    parentId: void 0,
    depth: 0
  });
  const maxDepth = adjList.sort((a2, b) => a2.depth - b.depth).last().depth;
  adjList.forEach((item) => item.height = maxDepth - item.depth);
  console.log({ visits });
  return adjList;
}
var stratify = stratify_default().id(function(d) {
  console.log({ d });
  return d.name;
}).parentId(function(d) {
  return d.parentId;
});
var VisModal8 = class extends import_obsidian43.Modal {
  constructor(plugin) {
    super(app);
    this.plugin = plugin;
    this.modal = this;
  }
  onOpen() {
    new import_obsidian43.Notice(
      "Alot of these features may not work, it is still very experimental."
    );
    const { contentEl } = this;
    contentEl.empty();
    new VisComp_default({
      target: contentEl,
      props: {
        modal: this
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/main.ts
var BCPlugin = class extends import_obsidian44.Plugin {
  constructor() {
    super(...arguments);
    this.visited = [];
    this.activeLeafChange = void 0;
    this.layoutChange = void 0;
    this.loadSettings = async () => this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    this.saveSettings = async () => await this.saveData(this.settings);
  }
  registerActiveLeafChangeEvent() {
    this.activeLeafChange = app.workspace.on(
      "file-open",
      async () => {
        if (this.settings.refreshOnNoteChange)
          await refreshIndex(this);
        else {
          const activeView = this.getActiveTYPEView(MATRIX_VIEW);
          if (activeView)
            await activeView.draw();
        }
      }
    );
    this.registerEvent(this.activeLeafChange);
  }
  registerLayoutChangeEvent() {
    this.layoutChange = app.workspace.on("layout-change", async () => {
      if (this.settings.showBCs)
        await drawTrail(this);
    });
    this.registerEvent(this.layoutChange);
  }
  async onload() {
    console.log("loading breadcrumbs plugin");
    await this.loadSettings();
    this.addSettingTab(new BCSettingTab(this));
    this.db = new Debugger(this);
    const { settings } = this;
    const {
      fieldSuggestor,
      enableRelationSuggestor,
      openMatrixOnLoad,
      openDuckOnLoad,
      openDownOnLoad,
      showBCs,
      userHiers
    } = settings;
    if (fieldSuggestor)
      this.registerEditorSuggest(new FieldSuggestor(this));
    if (enableRelationSuggestor)
      this.registerEditorSuggest(new RelationSuggestor(this));
    if (settings.limitTrailCheckboxes.length === 0)
      settings.limitTrailCheckboxes = getFields(settings.userHiers);
    if (typeof settings.showAll === "boolean")
      settings.showAll = settings.showAll ? "All" : "Shortest";
    this.VIEWS = [
      {
        plain: "Matrix",
        type: MATRIX_VIEW,
        constructor: MatrixView,
        openOnLoad: openMatrixOnLoad
      },
      {
        plain: "Duck",
        type: DUCK_VIEW,
        constructor: DucksView,
        openOnLoad: openDuckOnLoad
      },
      {
        plain: "Down",
        type: TREE_VIEW,
        constructor: TreeView,
        openOnLoad: openDownOnLoad
      }
    ];
    for (const { constructor, type: type2 } of this.VIEWS) {
      this.registerView(
        type2,
        (leaf) => (
          //@ts-ignore
          new constructor(leaf, this)
        )
      );
    }
    (0, import_obsidian44.addIcon)(DUCK_ICON, DUCK_ICON_SVG);
    (0, import_obsidian44.addIcon)(TRAIL_ICON, TRAIL_ICON_SVG);
    this.addRibbonIcon(
      addFeatherIcon("tv"),
      "Breadcrumbs Visualisation",
      () => new VisModal8(this).open()
    );
    await waitForCache(this);
    this.mainG = await buildMainG(this);
    this.closedG = buildClosedG(this);
    app.workspace.onLayoutReady(async () => {
      var _a;
      const noFiles = app.vault.getMarkdownFiles().length;
      if (((_a = this.mainG) == null ? void 0 : _a.nodes().length) < noFiles) {
        await wait(3e3);
        this.mainG = await buildMainG(this);
        this.closedG = buildClosedG(this);
      }
      for (const { openOnLoad, type: type2, constructor } of this.VIEWS)
        if (openOnLoad)
          await openView(type2, constructor);
      if (showBCs)
        await drawTrail(this);
      this.registerActiveLeafChangeEvent();
      this.registerLayoutChangeEvent();
      const saveCommandDefinition = app.commands.commands["editor:save-file"];
      const save = saveCommandDefinition == null ? void 0 : saveCommandDefinition.callback;
      if (typeof save === "function") {
        saveCommandDefinition.callback = async () => {
          await save();
          if (this.settings.refreshOnNoteSave) {
            await refreshIndex(this);
            const activeView = this.getActiveTYPEView(MATRIX_VIEW);
            if (activeView)
              await activeView.draw();
          }
        };
      }
      app.workspace.iterateAllLeaves((leaf) => {
        if (leaf instanceof import_obsidian44.MarkdownView)
          leaf.view.previewMode.rerender(true);
      });
    });
    for (const { type: type2, plain, constructor } of this.VIEWS) {
      this.addCommand({
        id: `show-${type2}-view`,
        name: `Open ${plain} View`,
        //@ts-ignore
        checkCallback: async (checking) => {
          if (checking)
            return app.workspace.getLeavesOfType(type2).length === 0;
          await openView(type2, constructor);
        }
      });
    }
    this.addCommand({
      id: "open-vis-modal",
      name: "Open Visualisation Modal",
      callback: () => new VisModal8(this).open()
    });
    this.addCommand({
      id: "manipulate-hierarchy-notes",
      name: "Adjust Hierarchy Notes",
      callback: () => new HierarchyNoteSelectorModal(this).open()
    });
    this.addCommand({
      id: "Refresh-Breadcrumbs-Index",
      name: "Refresh Breadcrumbs Index",
      callback: async () => await refreshIndex(this)
    });
    this.addCommand({
      id: "Toggle-trail-in-Edit&LP",
      name: "Toggle: Show Trail/Grid in Edit & LP mode",
      callback: async () => {
        settings.showBCsInEditLPMode = !settings.showBCsInEditLPMode;
        await this.saveSettings();
        await drawTrail(this);
      }
    });
    this.addCommand({
      id: "Write-Breadcrumbs-to-Current-File",
      name: "Write Breadcrumbs to Current File",
      callback: async () => await writeBCToFile(this)
    });
    this.addCommand({
      id: "Write-Breadcrumbs-to-All-Files",
      name: "Write Breadcrumbs to **ALL** Files",
      callback: async () => await writeBCsToAllFiles(this)
    });
    this.addCommand({
      id: "local-index",
      name: "Copy a Local Index to the clipboard",
      callback: async () => await copyLocalIndex(this)
    });
    this.addCommand({
      id: "global-index",
      name: "Copy a Global Index to the clipboard",
      callback: async () => await copyGlobalIndex(this)
    });
    ["up", "down", "next", "prev"].forEach((dir) => {
      this.addCommand({
        id: `jump-to-first-${dir}`,
        name: `Jump to first '${dir}'`,
        callback: async () => await jumpToFirstDir(this, dir)
      });
    });
    getFields(userHiers).forEach((field) => {
      this.addCommand({
        id: `new-file-with-curr-as-${field}`,
        name: `Create a new '${field}' from the current note`,
        callback: async () => await thread(this, field)
      });
    });
    this.registerMarkdownCodeBlockProcessor(
      "breadcrumbs",
      getCodeblockCB(this)
    );
    const jugglPlugin = getPlugin(app);
    if (jugglPlugin) {
      this.bcStore = new BCStore(this.mainG, app.metadataCache);
      jugglPlugin.registerStore(this.bcStore);
    }
    this.api = new BCAPI(this);
    (window[API_NAME] = this.api) && this.register(() => delete window[API_NAME]);
  }
  getActiveTYPEView(type2) {
    const { constructor } = this.VIEWS.find((view) => view.type === type2);
    const leaves = app.workspace.getLeavesOfType(type2);
    if (leaves && leaves.length >= 1) {
      const { view } = leaves[0];
      if (view instanceof constructor)
        return view;
    }
    return null;
  }
  onunload() {
    console.log("unloading");
    this.VIEWS.forEach(async (view) => {
      app.workspace.getLeavesOfType(view.type).forEach((leaf) => {
        leaf.detach();
      });
    });
    this.visited.forEach((visit) => visit[1].remove());
    if (this.bcStore) {
      const jugglPlugin = getPlugin(app);
      if (jugglPlugin) {
        jugglPlugin.removeStore(this.bcStore);
      }
    }
  }
};
/*! Bundled license information:

feather-icons/dist/feather.js:
  (*!
    Copyright (c) 2016 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
