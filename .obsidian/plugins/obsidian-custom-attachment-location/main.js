/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettings.cjs
var require_PluginSettings = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettings.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var PluginSettings_exports = {};
    __export2(PluginSettings_exports, {
      clonePluginSettings: () => clonePluginSettings,
      loadPluginSettings: () => loadPluginSettings2
    });
    module2.exports = __toCommonJS2(PluginSettings_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function loadPluginSettings2(defaultPluginSettingsFactory, data) {
      const defaultPluginSettings = defaultPluginSettingsFactory();
      if (data && typeof data === "object") {
        const record = data;
        for (const [key, value] of Object.entries(record)) {
          if (key in defaultPluginSettings) {
            defaultPluginSettings[key] = value;
          }
        }
      }
      return defaultPluginSettings;
    }
    function clonePluginSettings(defaultPluginSettingsFactory, settings) {
      return loadPluginSettings2(defaultPluginSettingsFactory, settings);
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Error.cjs
var require_Error = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Error.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Error_exports = {};
    __export2(Error_exports, {
      emitAsyncErrorEvent: () => emitAsyncErrorEvent,
      errorToString: () => errorToString,
      printError: () => printError,
      registerAsyncErrorEventHandler: () => registerAsyncErrorEventHandler
    });
    module2.exports = __toCommonJS2(Error_exports);
    var import_node_events = require("node:events");
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var ASYNC_ERROR_EVENT = "asyncError";
    var asyncErrorEventEmitter = new import_node_events.EventEmitter();
    asyncErrorEventEmitter.on(ASYNC_ERROR_EVENT, handleAsyncError);
    function handleAsyncError(asyncError) {
      printError(new Error("An unhandled error occurred executing async operation", { cause: asyncError }));
    }
    function emitAsyncErrorEvent(asyncError) {
      asyncErrorEventEmitter.emit(ASYNC_ERROR_EVENT, asyncError);
    }
    function registerAsyncErrorEventHandler(handler) {
      asyncErrorEventEmitter.on(ASYNC_ERROR_EVENT, handler);
      return () => asyncErrorEventEmitter.off(ASYNC_ERROR_EVENT, handler);
    }
    function printError(error) {
      const entries = parseErrorEntries(error);
      for (const entry of entries) {
        if (entry.shouldClearAnsiSequence) {
          console.error(`\x1B[0m${entry.message}\x1B[0m`);
        } else {
          console.error(entry.message);
        }
      }
    }
    function errorToString(error) {
      return parseErrorEntries(error).map((entry) => "  ".repeat(entry.level) + entry.message).join("\n");
    }
    function parseErrorEntries(error, level = 0, entries = []) {
      if (error === void 0) {
        return entries;
      }
      if (!(error instanceof Error)) {
        let str = "";
        if (error === null) {
          str = "(null)";
        } else if (typeof error === "string") {
          str = error;
        } else {
          str = JSON.stringify(error);
        }
        entries.push({ level, message: str });
        return entries;
      }
      const title = `${error.name}: ${error.message}`;
      entries.push({ level, message: title, shouldClearAnsiSequence: true });
      if (error.stack) {
        const restStack = error.stack.startsWith(title) ? error.stack.substring(title.length + 1) : error.stack;
        entries.push({ level, message: `Error stack:
${restStack}` });
      }
      if (error.cause !== void 0) {
        entries.push({ level, message: "Caused by:" });
        parseErrorEntries(error.cause, level + 1, entries);
      }
      return entries;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginBase.cjs
var require_PluginBase = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginBase.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var PluginBase_exports = {};
    __export2(PluginBase_exports, {
      PluginBase: () => PluginBase2
    });
    module2.exports = __toCommonJS2(PluginBase_exports);
    var import_obsidian6 = require("obsidian");
    var import_Error = require_Error();
    var import_PluginSettings2 = require_PluginSettings();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var PluginBase2 = class extends import_obsidian6.Plugin {
      _settings;
      notice;
      _abortSignal;
      /**
       * Gets the AbortSignal used for aborting asynchronous operations.
       *
       * @returns The abort signal.
       */
      get abortSignal() {
        return this._abortSignal;
      }
      /**
       * Gets a copy of the current plugin settings.
       *
       * @returns A copy of the plugin settings.
       */
      get settingsCopy() {
        return (0, import_PluginSettings2.clonePluginSettings)(this.createDefaultPluginSettings, this.settings);
      }
      /**
       * Gets the plugin settings.
       *
       * @returns The plugin settings.
       */
      get settings() {
        return this._settings;
      }
      /**
       * Called when the plugin is loaded. Handles loading settings, adding a settings tab, registering error handlers,
       * and initializing the plugin.
       *
       * @returns A promise that resolves when the plugin is fully loaded.
       */
      async onload() {
        await this.loadSettings();
        const pluginSettingsTab = this.createPluginSettingsTab();
        if (pluginSettingsTab) {
          this.addSettingTab(pluginSettingsTab);
        }
        this.register((0, import_Error.registerAsyncErrorEventHandler)(() => {
          this.showNotice("An unhandled error occurred. Please check the console for more information.");
        }));
        const abortController = new AbortController();
        this._abortSignal = abortController.signal;
        this.register(() => abortController.abort());
        await this.onloadComplete();
        this.app.workspace.onLayoutReady(() => this.onLayoutReady());
      }
      /**
       * Called when the layout is ready. This method can be overridden by subclasses to perform actions once
       * the layout is ready.
       */
      onLayoutReady() {
      }
      /**
       * Loads the plugin settings from the saved data.
       *
       * @returns A promise that resolves when the settings are loaded.
       */
      async loadSettings() {
        const data = await this.loadData();
        this._settings = await this.parseSettings(data);
      }
      /**
       * Parses the provided settings data and returns the parsed `PluginSettings`.
       *
       * @param data - The raw data to be parsed into `PluginSettings`.
       * @returns A promise that resolves to `PluginSettings` or the settings directly.
       */
      parseSettings(data) {
        return (0, import_PluginSettings2.loadPluginSettings)(this.createDefaultPluginSettings, data);
      }
      /**
       * Saves the new plugin settings.
       *
       * @param newSettings - The new settings to save.
       * @returns A promise that resolves when the settings are saved.
       */
      async saveSettings(newSettings) {
        this._settings = (0, import_PluginSettings2.clonePluginSettings)(this.createDefaultPluginSettings, newSettings);
        await this.saveData(this.settings);
      }
      /**
       * Displays a notice message to the user.
       *
       * @param message - The message to display.
       */
      showNotice(message) {
        if (this.notice) {
          this.notice.hide();
        }
        this.notice = new import_obsidian6.Notice(`${this.manifest.name}
${message}`);
      }
    };
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettingsTabBase.cjs
var require_PluginSettingsTabBase = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettingsTabBase.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var PluginSettingsTabBase_exports = {};
    __export2(PluginSettingsTabBase_exports, {
      PluginSettingsTabBase: () => PluginSettingsTabBase2
    });
    module2.exports = __toCommonJS2(PluginSettingsTabBase_exports);
    var import_obsidian6 = require("obsidian");
    var import_PluginBase2 = require_PluginBase();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var PluginSettingsTabBase2 = class extends import_obsidian6.PluginSettingTab {
      constructor(plugin) {
        super(plugin.app, plugin);
        this.plugin = plugin;
      }
    };
  }
});

// node_modules/obsidian-dev-utils/dist/lib/DocumentFragment.cjs
var require_DocumentFragment = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/DocumentFragment.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var DocumentFragment_exports = {};
    __export2(DocumentFragment_exports, {
      appendCodeBlock: () => appendCodeBlock2
    });
    module2.exports = __toCommonJS2(DocumentFragment_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function appendCodeBlock2(fragment, code) {
      fragment.appendChild(createSpan({ cls: "markdown-rendered code" }, (span) => {
        span.style.fontWeight = "bold";
        span.appendChild(createEl("code", { text: code }));
      }));
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/UIComponent.cjs
var require_UIComponent = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/UIComponent.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var UIComponent_exports = {};
    __export2(UIComponent_exports, {
      bindUiComponent: () => bindUiComponent2
    });
    module2.exports = __toCommonJS2(UIComponent_exports);
    var import_obsidian6 = require("obsidian");
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function bindUiComponent2(plugin, uiComponent, property, options) {
      const DEFAULT_OPTIONS = {
        autoSave: true,
        settingToUIValueConverter: (value) => value,
        uiToSettingValueConverter: (value) => value
      };
      const optionsExt = Object.assign({}, options, DEFAULT_OPTIONS);
      const pluginExt = plugin;
      const uiComponentExt = uiComponent;
      const pluginSettings = optionsExt.pluginSettings ?? pluginExt.settingsCopy;
      uiComponentExt.setValue(optionsExt.settingToUIValueConverter(pluginSettings[property])).onChange(async (uiValue) => {
        if (optionsExt.uiValueValidator) {
          const errorMessage = optionsExt.uiValueValidator(uiValue);
          const validatorElement = getValidatorElement(uiComponent);
          if (validatorElement) {
            validatorElement.setCustomValidity(errorMessage ?? "");
            validatorElement.reportValidity();
          }
          if (errorMessage) {
            return;
          }
        }
        pluginSettings[property] = optionsExt.uiToSettingValueConverter(uiValue);
        if (optionsExt.autoSave) {
          await pluginExt.saveSettings(pluginSettings);
        }
      });
      return uiComponent;
    }
    function getValidatorElement(uiComponent) {
      if (uiComponent instanceof import_obsidian6.DropdownComponent) {
        return uiComponent.selectEl;
      }
      if (uiComponent instanceof import_obsidian6.SliderComponent) {
        return uiComponent.sliderEl;
      }
      if (uiComponent instanceof import_obsidian6.TextAreaComponent) {
        return uiComponent.inputEl;
      }
      if (uiComponent instanceof import_obsidian6.TextComponent) {
        return uiComponent.inputEl;
      }
      return null;
    }
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports2, module2) {
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = __process13.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join6() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative2(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname4(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename5(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname5(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/obsidian-dev-utils/dist/lib/RegExp.cjs
var require_RegExp = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/RegExp.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var RegExp_exports = {};
    __export2(RegExp_exports, {
      escapeRegExp: () => escapeRegExp2
    });
    module2.exports = __toCommonJS2(RegExp_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function escapeRegExp2(str) {
      return str.replaceAll(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/ValueProvider.cjs
var require_ValueProvider = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/ValueProvider.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var ValueProvider_exports = {};
    __export2(ValueProvider_exports, {
      resolveValue: () => resolveValue
    });
    module2.exports = __toCommonJS2(ValueProvider_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function isFunction(value) {
      return typeof value === "function";
    }
    async function resolveValue(provider, ...args) {
      if (isFunction(provider)) {
        return await provider(...args);
      } else {
        return provider;
      }
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/String.cjs
var require_String = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/String.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var String_exports = {};
    __export2(String_exports, {
      ensureEndsWith: () => ensureEndsWith,
      ensureStartsWith: () => ensureStartsWith,
      escape: () => escape,
      makeValidVariableName: () => makeValidVariableName,
      normalize: () => normalize,
      replace: () => replace,
      replaceAllAsync: () => replaceAllAsync,
      trimEnd: () => trimEnd,
      trimStart: () => trimStart,
      unescape: () => unescape
    });
    module2.exports = __toCommonJS2(String_exports);
    var import_RegExp2 = require_RegExp();
    var import_ValueProvider = require_ValueProvider();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var ESCAPE_MAP = {
      "\\": "\\\\",
      '"': '\\"',
      "'": "\\'",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\b": "\\b",
      "\f": "\\f"
    };
    var UNESCAPE_MAP = {};
    for (const [key, value] of Object.entries(ESCAPE_MAP)) {
      UNESCAPE_MAP[value] = key;
    }
    function trimStart(str, prefix, validate) {
      if (str.startsWith(prefix)) {
        return str.slice(prefix.length);
      }
      if (validate) {
        throw new Error(`String ${str} does not start with prefix ${prefix}`);
      }
      return str;
    }
    function trimEnd(str, suffix, validate) {
      if (str.endsWith(suffix)) {
        return str.slice(0, -suffix.length);
      }
      if (validate) {
        throw new Error(`String ${str} does not end with suffix ${suffix}`);
      }
      return str;
    }
    function normalize(str) {
      return str.replace(/\u00A0/g, " ").normalize("NFC");
    }
    async function replaceAllAsync(str, searchValue, replacer) {
      const replacementPromises = [];
      str.replaceAll(searchValue, (substring, ...args) => {
        replacementPromises.push((0, import_ValueProvider.resolveValue)(replacer, substring, ...args));
        return substring;
      });
      const replacements = await Promise.all(replacementPromises);
      return str.replaceAll(searchValue, () => replacements.shift());
    }
    function makeValidVariableName(str) {
      return str.replace(/[^a-zA-Z0-9_]/g, "_");
    }
    function ensureStartsWith(str, prefix) {
      return str.startsWith(prefix) ? str : prefix + str;
    }
    function ensureEndsWith(str, suffix) {
      return str.endsWith(suffix) ? str : str + suffix;
    }
    function escape(str) {
      return replace(str, ESCAPE_MAP);
    }
    function unescape(str) {
      return replace(str, UNESCAPE_MAP);
    }
    function replace(str, replacementsMap) {
      const regExp = new RegExp(Object.keys(replacementsMap).map((source) => (0, import_RegExp2.escapeRegExp)(source)).join("|"), "g");
      return str.replaceAll(regExp, (source) => replacementsMap[source]);
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Path.cjs
var require_Path = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Path.cjs"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Path_exports = {};
    __export2(Path_exports, {
      basename: () => basename5,
      delimiter: () => delimiter,
      dirname: () => dirname4,
      extname: () => extname5,
      format: () => format,
      getDirname: () => getDirname,
      getFilename: () => getFilename,
      isAbsolute: () => isAbsolute,
      join: () => join6,
      normalize: () => normalize,
      normalizeIfRelative: () => normalizeIfRelative,
      parse: () => parse,
      posix: () => posix,
      relative: () => relative2,
      resolve: () => resolve,
      sep: () => sep,
      toPosixBuffer: () => toPosixBuffer,
      toPosixPath: () => toPosixPath
    });
    module2.exports = __toCommonJS2(Path_exports);
    var import_path_browserify = __toESM2(require_path_browserify(), 1);
    var import_node_url = require("node:url");
    var import_String = require_String();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var posix = import_path_browserify.default.posix;
    var delimiter = posix.delimiter;
    var sep = import_path_browserify.default.posix.sep;
    var basename5 = posix.basename;
    var dirname4 = posix.dirname;
    var extname5 = posix.extname;
    var format = posix.format;
    var isAbsolute = posix.isAbsolute;
    var join6 = posix.join;
    var normalize = posix.normalize;
    var parse = posix.parse;
    var relative2 = posix.relative;
    function resolve(...pathSegments) {
      let path2 = posix.resolve(...pathSegments);
      path2 = toPosixPath(path2);
      const match = path2.match(/.:[^:]*$/);
      return match?.[0] ?? path2;
    }
    function toPosixPath(path2) {
      return path2.replace(/\\/g, "/");
    }
    function toPosixBuffer(buffer) {
      return Buffer.from(toPosixPath(buffer.toString()));
    }
    function getFilename(importMetaUrl) {
      return toPosixPath((0, import_node_url.fileURLToPath)(importMetaUrl));
    }
    function getDirname(importMetaUrl) {
      return dirname4(getFilename(importMetaUrl));
    }
    function normalizeIfRelative(path2) {
      if (path2[0] === "/" || path2.includes(":")) {
        return path2;
      }
      return (0, import_String.ensureStartsWith)(path2, "./");
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Async.cjs
var require_Async = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Async.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Async_exports = {};
    __export2(Async_exports, {
      asyncFilter: () => asyncFilter,
      asyncFlatMap: () => asyncFlatMap,
      asyncMap: () => asyncMap,
      convertAsyncToSync: () => convertAsyncToSync2,
      convertSyncToAsync: () => convertSyncToAsync,
      invokeAsyncSafely: () => invokeAsyncSafely3,
      retryWithTimeout: () => retryWithTimeout,
      runWithTimeout: () => runWithTimeout,
      sleep: () => sleep,
      timeout: () => timeout,
      toArray: () => toArray
    });
    module2.exports = __toCommonJS2(Async_exports);
    var import_Error = require_Error();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    async function retryWithTimeout(asyncFn, retryOptions = {}) {
      const DEFAULT_RETRY_OPTIONS = {
        timeoutInMilliseconds: 5e3,
        retryDelayInMilliseconds: 100
      };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      await runWithTimeout(overriddenOptions.timeoutInMilliseconds, async () => {
        let attempt = 0;
        while (true) {
          attempt++;
          if (await asyncFn()) {
            if (attempt > 1) {
              console.debug(`Retry completed successfully after ${attempt} attempts`);
            }
            return;
          }
          console.debug(`Retry attempt ${attempt} completed unsuccessfully. Trying again in ${overriddenOptions.retryDelayInMilliseconds} milliseconds`);
          console.debug(asyncFn);
          await sleep(overriddenOptions.retryDelayInMilliseconds);
        }
      });
    }
    async function sleep(milliseconds) {
      await new Promise((resolve) => setTimeout(resolve, milliseconds));
    }
    async function runWithTimeout(timeoutInMilliseconds, asyncFn) {
      return await Promise.race([asyncFn(), timeout(timeoutInMilliseconds)]);
    }
    async function timeout(timeoutInMilliseconds) {
      await sleep(timeoutInMilliseconds);
      throw new Error(`Timed out in ${timeoutInMilliseconds} milliseconds`);
    }
    function invokeAsyncSafely3(promise) {
      promise.catch(import_Error.emitAsyncErrorEvent);
    }
    function convertAsyncToSync2(asyncFunc) {
      return (...args) => invokeAsyncSafely3(asyncFunc(...args));
    }
    function convertSyncToAsync(syncFn) {
      return async (...args) => {
        try {
          return syncFn(...args);
        } catch (error) {
          return await Promise.reject(error);
        }
      };
    }
    async function asyncMap(arr, callback) {
      return await Promise.all(arr.map(callback));
    }
    async function asyncFilter(arr, predicate) {
      const predicateResults = await asyncMap(arr, predicate);
      return arr.filter((_, index) => predicateResults[index]);
    }
    async function asyncFlatMap(arr, callback) {
      return (await asyncMap(arr, callback)).flat();
    }
    async function toArray(iter) {
      const arr = [];
      for await (const item of iter) {
        arr.push(item);
      }
      return arr;
    }
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports2, module2) {
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    (function(global, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports2, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Modal/Prompt.cjs
var require_Prompt = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Modal/Prompt.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Prompt_exports = {};
    __export2(Prompt_exports, {
      prompt: () => prompt2
    });
    module2.exports = __toCommonJS2(Prompt_exports);
    var import_obsidian6 = require("obsidian");
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    async function prompt2(options) {
      const {
        app,
        title,
        defaultValue,
        valueValidator
      } = options;
      return new Promise((resolve) => {
        class PromptModal extends import_obsidian6.Modal {
          value = "";
          isCancelled = true;
          constructor() {
            super(app);
          }
          onOpen() {
            this.value = defaultValue ?? "";
            this.titleEl.setText(title ?? "");
            const textComponent = new import_obsidian6.TextComponent(this.contentEl);
            textComponent.setValue(this.value);
            textComponent.setPlaceholder(this.value);
            textComponent.inputEl.style.width = "100%";
            textComponent.onChange((value) => this.value = value);
            textComponent.inputEl.addEventListener("keydown", (event) => {
              if (event.key === "Enter") {
                this.handleOk(event, textComponent);
              } else if (event.key === "Escape") {
                this.close();
              }
            });
            if (valueValidator) {
              textComponent.inputEl.addEventListener("input", () => {
                const errorMessage = valueValidator(textComponent.inputEl.value);
                textComponent.inputEl.setCustomValidity(errorMessage ?? "");
                textComponent.inputEl.reportValidity();
              });
            }
            const okButton = new import_obsidian6.ButtonComponent(this.contentEl);
            okButton.setButtonText("OK");
            okButton.setClass("mod-cta");
            okButton.onClick((event) => this.handleOk(event, textComponent));
            okButton.buttonEl.style.marginTop = "20px";
            okButton.buttonEl.style.marginRight = "10px";
            const cancelButton = new import_obsidian6.ButtonComponent(this.contentEl);
            cancelButton.setButtonText("Cancel");
            cancelButton.onClick(this.close.bind(this));
          }
          onClose() {
            resolve(this.isCancelled ? null : this.value);
          }
          handleOk(event, textComponent) {
            event.preventDefault();
            if (!textComponent.inputEl.checkValidity()) {
              return;
            }
            this.isCancelled = false;
            this.close();
          }
        }
        const modal = new PromptModal();
        modal.open();
      });
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Object.cjs
var require_Object = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Object.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Object_exports = {};
    __export2(Object_exports, {
      deepEqual: () => deepEqual,
      getPrototypeOf: () => getPrototypeOf,
      nameof: () => nameof
    });
    module2.exports = __toCommonJS2(Object_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" || typeof b !== "object" || a === null || b === null || a === void 0 || b === void 0) {
        return false;
      }
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) {
        return false;
      }
      const aRecord = a;
      const bRecord = b;
      for (const key of keysA) {
        if (!keysB.includes(key) || !deepEqual(aRecord[key], bRecord[key])) {
          return false;
        }
      }
      return true;
    }
    function nameof(name) {
      return name;
    }
    function getPrototypeOf(instance) {
      return Object.getPrototypeOf(instance);
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/TAbstractFile.cjs
var require_TAbstractFile = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/TAbstractFile.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var TAbstractFile_exports = {};
    __export2(TAbstractFile_exports, {
      CANVAS_FILE_EXTENSION: () => CANVAS_FILE_EXTENSION,
      MARKDOWN_FILE_EXTENSION: () => MARKDOWN_FILE_EXTENSION,
      checkExtension: () => checkExtension,
      getAbstractFile: () => getAbstractFile,
      getAbstractFileOrNull: () => getAbstractFileOrNull,
      getPath: () => getPath,
      isCanvasFile: () => isCanvasFile2,
      isFile: () => isFile,
      isFolder: () => isFolder,
      isMarkdownFile: () => isMarkdownFile2,
      isNote: () => isNote5,
      trimMarkdownExtension: () => trimMarkdownExtension
    });
    module2.exports = __toCommonJS2(TAbstractFile_exports);
    var import_obsidian6 = require("obsidian");
    var import_String = require_String();
    var import_Path8 = require_Path();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var MARKDOWN_FILE_EXTENSION = "md";
    var CANVAS_FILE_EXTENSION = "canvas";
    function getAbstractFile(app, pathOrFile) {
      const file = getAbstractFileOrNull(app, pathOrFile);
      if (!file) {
        throw new Error(`Abstract file not found: ${pathOrFile}`);
      }
      return file;
    }
    function getAbstractFileOrNull(app, pathOrFile) {
      return pathOrFile instanceof import_obsidian6.TAbstractFile ? pathOrFile : app.vault.getAbstractFileByPath(pathOrFile);
    }
    function isNote5(file) {
      return isMarkdownFile2(file) || isCanvasFile2(file);
    }
    function isMarkdownFile2(pathOrFile) {
      return checkExtension(pathOrFile, MARKDOWN_FILE_EXTENSION);
    }
    function isCanvasFile2(pathOrFile) {
      return checkExtension(pathOrFile, CANVAS_FILE_EXTENSION);
    }
    function checkExtension(pathOrFile, extension) {
      if (pathOrFile === null) {
        return false;
      }
      return (0, import_Path8.extname)(getPath(pathOrFile)).toLowerCase().slice(1) === extension.toLowerCase();
    }
    function trimMarkdownExtension(file) {
      if (!isMarkdownFile2(file)) {
        return file.path;
      }
      return (0, import_String.trimEnd)(file.path, "." + MARKDOWN_FILE_EXTENSION);
    }
    function isFile(file) {
      return file instanceof import_obsidian6.TFile;
    }
    function isFolder(file) {
      return file instanceof import_obsidian6.TFolder;
    }
    function getPath(pathOrFile) {
      return pathOrFile instanceof import_obsidian6.TAbstractFile ? pathOrFile.path : pathOrFile;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/TFile.cjs
var require_TFile = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/TFile.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var TFile_exports = {};
    __export2(TFile_exports, {
      getFile: () => getFile,
      getFileOrNull: () => getFileOrNull
    });
    module2.exports = __toCommonJS2(TFile_exports);
    var import_obsidian6 = require("obsidian");
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function getFile(app, pathOrFile) {
      const file = getFileOrNull(app, pathOrFile);
      if (!file) {
        throw new Error(`File not found: ${pathOrFile}`);
      }
      return file;
    }
    function getFileOrNull(app, pathOrFile) {
      return pathOrFile instanceof import_obsidian6.TFile ? pathOrFile : app.vault.getFileByPath(pathOrFile);
    }
  }
});

// node_modules/obsidian-typings/dist/implementations.cjs
var require_implementations = __commonJS({
  "node_modules/obsidian-typings/dist/implementations.cjs"(exports2, module2) {
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var implementations_exports = {};
    __export2(implementations_exports, {
      CustomArrayDictImpl: () => CustomArrayDictImpl,
      InternalPluginName: () => InternalPluginName,
      createTFileInstance: () => createTFileInstance2,
      createTFolderInstance: () => createTFolderInstance,
      parentFolderPath: () => parentFolderPath
    });
    module2.exports = __toCommonJS2(implementations_exports);
    function parentFolderPath(path) {
      return path.replace(/\/?[^\/]*$/, "") || "/";
    }
    var import_obsidian6 = require("obsidian");
    function createTFolderInstance(vault, path) {
      let folder = vault.getFolderByPath(path);
      if (folder) {
        return folder;
      }
      folder = new import_obsidian6.TFolder(vault, path);
      folder.parent = createTFolderInstance(vault, parentFolderPath(path));
      folder.deleted = true;
      return folder;
    }
    var import_obsidian22 = require("obsidian");
    function createTFileInstance2(vault, path) {
      let file = vault.getFileByPath(path);
      if (file) {
        return file;
      }
      file = new import_obsidian22.TFile(vault, path);
      file.parent = createTFolderInstance(vault, parentFolderPath(path));
      file.deleted = true;
      return file;
    }
    var CustomArrayDictImpl = class {
      data = {};
      add(key, value) {
        if (!this.data.hasOwnProperty(key)) {
          this.data[key] = [];
        }
        const values = this.data[key];
        if (!values.includes(value)) {
          values.push(value);
        }
      }
      remove(key, value) {
        const values = this.data[key];
        if (!values) {
          return;
        }
        values.remove(value);
        if (values.length === 0) {
          delete this.data[key];
        }
      }
      removeKey(key) {
        delete this.data[key];
      }
      get(key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
      }
      keys() {
        return Object.keys(this.data);
      }
      clear(key) {
        delete this.data[key];
      }
      clearAll() {
        this.data = {};
      }
      contains(key, value) {
        const values = this.data[key];
        return values && values.contains(value) || false;
      }
      count() {
        let ans = 0;
        for (const key in this.data) {
          if (this.data.hasOwnProperty(key)) {
            ans += this.data[key].length;
          }
        }
        return ans;
      }
    };
    var InternalPluginName = {
      AudioRecorder: "audio-recorder",
      Backlink: "backlink",
      Bookmarks: "bookmarks",
      Canvas: "canvas",
      CommandPalette: "command-palette",
      DailyNotes: "daily-notes",
      EditorStatus: "editor-status",
      FileExplorer: "file-explorer",
      FileRecovery: "file-recovery",
      GlobalSearch: "global-search",
      Graph: "graph",
      MarkdownImporter: "markdown-importer",
      NoteComposer: "note-composer",
      OutgoingLink: "outgoing-link",
      Outline: "outline",
      PagePreview: "page-preview",
      Properties: "properties",
      Publish: "publish",
      RandomNote: "random-note",
      SlashCommand: "slash-command",
      Slides: "slides",
      Starred: "starred",
      Switcher: "switcher",
      Sync: "sync",
      TagPane: "tag-pane",
      Templates: "templates",
      WordCount: "word-count",
      Workspaces: "workspaces",
      ZkPrefixer: "zk-prefixer"
    };
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/MetadataCache.cjs
var require_MetadataCache = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/MetadataCache.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var MetadataCache_exports = {};
    __export2(MetadataCache_exports, {
      getAllLinks: () => getAllLinks3,
      getBacklinksForFileSafe: () => getBacklinksForFileSafe3,
      getCacheSafe: () => getCacheSafe3,
      getFrontMatterSafe: () => getFrontMatterSafe,
      registerFile: () => registerFile,
      tempRegisterFileAndRun: () => tempRegisterFileAndRun
    });
    module2.exports = __toCommonJS2(MetadataCache_exports);
    var import_obsidian6 = require("obsidian");
    var import_Async4 = require_Async();
    var import_TAbstractFile5 = require_TAbstractFile();
    var import_TFile = require_TFile();
    var import_implementations2 = require_implementations();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    async function getCacheSafe3(app, fileOrPath, retryOptions = {}) {
      const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      let cache = null;
      await (0, import_Async4.retryWithTimeout)(async () => {
        const file = (0, import_TFile.getFileOrNull)(app, fileOrPath);
        if (!file || file.deleted) {
          cache = null;
          return true;
        }
        await saveNote(app, file);
        const fileInfo = app.metadataCache.getFileInfo(file.path);
        const stat = await app.vault.adapter.stat(file.path);
        if (!fileInfo) {
          console.debug(`File cache info for ${file.path} is missing`);
          return false;
        } else if (!stat) {
          console.debug(`File stat for ${file.path} is missing`);
          return false;
        } else if (fileInfo.mtime < stat.mtime) {
          console.debug(`File cache info for ${file.path} is from ${new Date(fileInfo.mtime).toString()} which is older than the file modification timestamp ${new Date(stat.mtime).toString()}`);
          return false;
        } else {
          cache = app.metadataCache.getFileCache(file);
          if (!cache) {
            console.debug(`File cache for ${file.path} is missing`);
            return false;
          } else {
            return true;
          }
        }
      }, overriddenOptions);
      return cache;
    }
    function getAllLinks3(cache) {
      let links = [];
      if (cache.links) {
        links.push(...cache.links);
      }
      if (cache.embeds) {
        links.push(...cache.embeds);
      }
      links.sort((a, b) => a.position.start.offset - b.position.start.offset);
      links = links.filter((link, index) => {
        if (index === 0) {
          return true;
        }
        return link.position.start.offset !== links[index - 1].position.start.offset;
      });
      return links;
    }
    async function getBacklinksForFileSafe3(app, pathOrFile, retryOptions = {}) {
      const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      let backlinks = null;
      await (0, import_Async4.retryWithTimeout)(async () => {
        const file = (0, import_TFile.getFile)(app, pathOrFile);
        backlinks = tempRegisterFileAndRun(app, file, () => app.metadataCache.getBacklinksForFile(file));
        for (const notePath of backlinks.keys()) {
          const note = app.vault.getFileByPath(notePath);
          if (!note) {
            return false;
          }
          await saveNote(app, note);
          const content = await app.vault.read(note);
          const links = backlinks.get(notePath);
          for (const link of links) {
            const actualLink = content.slice(link.position.start.offset, link.position.end.offset);
            if (actualLink !== link.original) {
              return false;
            }
          }
        }
        return true;
      }, overriddenOptions);
      return backlinks;
    }
    async function saveNote(app, pathOrFile) {
      if (!(0, import_TAbstractFile5.isMarkdownFile)(pathOrFile)) {
        return;
      }
      const path = (0, import_TAbstractFile5.getPath)(pathOrFile);
      for (const leaf of app.workspace.getLeavesOfType("markdown")) {
        const view = leaf.view;
        if (view.file?.path === path) {
          await view.save();
        }
      }
    }
    async function getFrontMatterSafe(app, pathOrFile) {
      const cache = await getCacheSafe3(app, pathOrFile);
      return cache?.frontmatter ?? {};
    }
    function tempRegisterFileAndRun(app, file, fn) {
      const unregister = registerFile(app, file);
      try {
        return fn();
      } finally {
        unregister();
      }
    }
    function registerFile(app, file) {
      if (!file.deleted) {
        return () => {
        };
      }
      const deletedPaths = [];
      let deletedFile = file;
      while (deletedFile.deleted) {
        deletedPaths.push(deletedFile.path);
        app.vault.fileMap[deletedFile.path] = deletedFile;
        deletedFile = deletedFile.parent ?? (0, import_implementations2.createTFolderInstance)(app.vault, (0, import_implementations2.parentFolderPath)(deletedFile.path));
      }
      if (file instanceof import_obsidian6.TFile) {
        app.metadataCache.uniqueFileLookup.add(file.name.toLowerCase(), file);
      }
      return () => {
        for (const path of deletedPaths) {
          delete app.vault.fileMap[path];
        }
        if (file instanceof import_obsidian6.TFile) {
          app.metadataCache.uniqueFileLookup.remove(file.name.toLowerCase(), file);
        }
      };
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/JSON.cjs
var require_JSON = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/JSON.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var JSON_exports = {};
    __export2(JSON_exports, {
      editJson: () => editJson,
      readJson: () => readJson,
      toJson: () => toJson3,
      writeJson: () => writeJson
    });
    module2.exports = __toCommonJS2(JSON_exports);
    var import_promises = require("node:fs/promises");
    var import_node_fs = require("node:fs");
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    async function readJson(path) {
      return JSON.parse(await (0, import_promises.readFile)(path, "utf-8"));
    }
    async function writeJson(path, data) {
      await (0, import_promises.writeFile)(path, toJson3(data) + "\n");
    }
    async function editJson(path, editFn, options = {}) {
      const {
        skipIfMissing
      } = options;
      if (skipIfMissing && !(0, import_node_fs.existsSync)(path)) {
        return;
      }
      const data = await readJson(path);
      await editFn(data);
      await writeJson(path, data);
    }
    function toJson3(value, options = {}) {
      const {
        shouldHandleFunctions = false,
        space = 2
      } = options;
      if (!shouldHandleFunctions) {
        return JSON.stringify(value, null, space);
      }
      const functionTexts = [];
      const replacer = (_, value2) => {
        if (typeof value2 === "function") {
          const index = functionTexts.length;
          functionTexts.push(value2.toString());
          return `__FUNCTION_${index}`;
        }
        return value2;
      };
      let json = JSON.stringify(value, replacer, space);
      json = json.replaceAll(/"__FUNCTION_(\d+)"/g, (_, indexStr) => functionTexts[parseInt(indexStr)]);
      return json;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/TFolder.cjs
var require_TFolder = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/TFolder.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var TFolder_exports = {};
    __export2(TFolder_exports, {
      getFolder: () => getFolder,
      getFolderOrNull: () => getFolderOrNull,
      getMarkdownFiles: () => getMarkdownFiles
    });
    module2.exports = __toCommonJS2(TFolder_exports);
    var import_obsidian6 = require("obsidian");
    var import_TAbstractFile5 = require_TAbstractFile();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function getFolder(app, pathOrFolder) {
      const folder = getFolderOrNull(app, pathOrFolder);
      if (!folder) {
        throw new Error(`Folder not found: ${pathOrFolder}`);
      }
      return folder;
    }
    function getFolderOrNull(app, pathOrFolder) {
      if (pathOrFolder === null) {
        return null;
      }
      return pathOrFolder instanceof import_obsidian6.TFolder ? pathOrFolder : app.vault.getFolderByPath(pathOrFolder);
    }
    function getMarkdownFiles(app, pathOrFolder, isRecursive) {
      const folder = getFolder(app, pathOrFolder);
      let markdownFiles = [];
      if (!isRecursive) {
        markdownFiles = folder.children.filter((file) => (0, import_TAbstractFile5.isMarkdownFile)(file));
      } else {
        import_obsidian6.Vault.recurseChildren(folder, (abstractFile) => {
          if ((0, import_TAbstractFile5.isMarkdownFile)(abstractFile)) {
            markdownFiles.push(abstractFile);
          }
        });
      }
      markdownFiles = markdownFiles.sort((a, b) => a.path.localeCompare(b.path));
      return markdownFiles;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Vault.cjs
var require_Vault = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Vault.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Vault_exports = {};
    __export2(Vault_exports, {
      applyFileChanges: () => applyFileChanges3,
      createFolderSafe: () => createFolderSafe4,
      createTempFile: () => createTempFile,
      createTempFolder: () => createTempFolder,
      getMarkdownFilesSorted: () => getMarkdownFilesSorted,
      processWithRetry: () => processWithRetry3,
      removeEmptyFolderHierarchy: () => removeEmptyFolderHierarchy3,
      removeFolderSafe: () => removeFolderSafe3,
      safeList: () => safeList
    });
    module2.exports = __toCommonJS2(Vault_exports);
    var import_obsidian6 = require("obsidian");
    var import_Object = require_Object();
    var import_Async4 = require_Async();
    var import_MetadataCache3 = require_MetadataCache();
    var import_Error = require_Error();
    var import_JSON3 = require_JSON();
    var import_TFile = require_TFile();
    var import_TAbstractFile5 = require_TAbstractFile();
    var import_TFolder = require_TFolder();
    var import_ValueProvider = require_ValueProvider();
    var import_Path8 = require_Path();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function getMarkdownFilesSorted(app) {
      return app.vault.getMarkdownFiles().sort((a, b) => a.path.localeCompare(b.path));
    }
    async function processWithRetry3(app, pathOrFile, newContentProvider, retryOptions = {}) {
      const file = (0, import_TFile.getFile)(app, pathOrFile);
      const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      await (0, import_Async4.retryWithTimeout)(async () => {
        const oldContent = await app.vault.adapter.read(file.path);
        const newContent = await (0, import_ValueProvider.resolveValue)(newContentProvider, oldContent);
        if (newContent === null) {
          return false;
        }
        let success = true;
        await app.vault.process(file, (content) => {
          if (content !== oldContent) {
            console.warn(`Content of ${file.path} has changed since it was read. Retrying...`);
            success = false;
            return content;
          }
          return newContent;
        });
        return success;
      }, overriddenOptions);
    }
    async function applyFileChanges3(app, pathOrFile, changesProvider, retryOptions = {}) {
      const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      await processWithRetry3(app, pathOrFile, async (content) => {
        let changes = await (0, import_ValueProvider.resolveValue)(changesProvider);
        for (const change of changes) {
          const actualContent = content.slice(change.startIndex, change.endIndex);
          if (actualContent !== change.oldContent) {
            console.warn(`Content mismatch at ${change.startIndex}-${change.endIndex} in ${(0, import_TAbstractFile5.getPath)(pathOrFile)}:
Expected: ${change.oldContent}
Actual: ${actualContent}`);
            return null;
          }
        }
        changes.sort((a, b) => a.startIndex - b.startIndex);
        changes = changes.filter((change, index) => {
          if (index === 0) {
            return true;
          }
          return !(0, import_Object.deepEqual)(change, changes[index - 1]);
        });
        for (let i = 1; i < changes.length; i++) {
          const change = changes[i];
          const previousChange = changes[i - 1];
          if (previousChange.endIndex > change.startIndex) {
            console.warn(`Overlapping changes:
${(0, import_JSON3.toJson)(previousChange)}
${(0, import_JSON3.toJson)(change)}`);
            return null;
          }
        }
        let newContent = "";
        let lastIndex = 0;
        for (const change of changes) {
          newContent += content.slice(lastIndex, change.startIndex);
          newContent += change.newContent;
          lastIndex = change.endIndex;
        }
        newContent += content.slice(lastIndex);
        return newContent;
      }, overriddenOptions);
    }
    async function removeFolderSafe3(app, folderPath, removedNotePath, shouldReportUsedAttachments) {
      const folder = app.vault.getFolderByPath(folderPath);
      if (!folder) {
        return false;
      }
      let canRemove = true;
      for (const child of folder.children) {
        if (child instanceof import_obsidian6.TFile) {
          const backlinks = await (0, import_MetadataCache3.getBacklinksForFileSafe)(app, child);
          if (removedNotePath) {
            backlinks.removeKey(removedNotePath);
          }
          if (backlinks.count() !== 0) {
            if (shouldReportUsedAttachments) {
              new import_obsidian6.Notice(`Attachment ${child.path} is still used by other notes. It will not be deleted.`);
            }
            canRemove = false;
          } else {
            try {
              await app.vault.delete(child);
            } catch (e) {
              if (await app.vault.adapter.exists(child.path)) {
                (0, import_Error.printError)(new Error(`Failed to delete ${child.path}`, { cause: e }));
                canRemove = false;
              }
            }
          }
        } else if (child instanceof import_obsidian6.TFolder) {
          canRemove &&= await removeFolderSafe3(app, child.path, removedNotePath, shouldReportUsedAttachments);
        }
      }
      if (canRemove) {
        try {
          await app.vault.delete(folder, true);
        } catch (e) {
          if (await app.vault.adapter.exists(folder.path)) {
            (0, import_Error.printError)(new Error(`Failed to delete ${folder.path}`, { cause: e }));
            canRemove = false;
          }
        }
      }
      return canRemove;
    }
    async function createFolderSafe4(app, path) {
      if (await app.vault.adapter.exists(path)) {
        return false;
      }
      try {
        await app.vault.adapter.mkdir(path);
        return true;
      } catch (e) {
        if (!await app.vault.adapter.exists(path)) {
          throw e;
        }
        return true;
      }
    }
    async function safeList(app, path) {
      const EMPTY = { files: [], folders: [] };
      if (!await app.vault.exists(path)) {
        return EMPTY;
      }
      try {
        return await app.vault.adapter.list(path);
      } catch (e) {
        if (await app.vault.adapter.exists(path)) {
          throw e;
        }
        return EMPTY;
      }
    }
    async function removeEmptyFolderHierarchy3(app, pathOrFolder) {
      let folder = (0, import_TFolder.getFolderOrNull)(app, pathOrFolder);
      while (folder) {
        if (folder.children.length > 0) {
          return;
        }
        const parent = folder.parent;
        await removeFolderSafe3(app, folder.path);
        folder = parent;
      }
    }
    async function createTempFile(app, path) {
      let file = app.vault.getFileByPath(path);
      if (file) {
        return async () => {
        };
      }
      const folderCleanup = await createTempFolder(app, (0, import_Path8.dirname)(path));
      try {
        await app.vault.create(path, "");
      } catch (e) {
        if (!await app.vault.exists(path)) {
          throw e;
        }
      }
      file = app.vault.getFileByPath(path);
      return async () => {
        if (!file.deleted) {
          await app.vault.delete(file, true);
        }
        await folderCleanup();
      };
    }
    async function createTempFolder(app, path) {
      let folder = app.vault.getFolderByPath(path);
      if (folder) {
        return async () => {
        };
      }
      const dirPath = (0, import_Path8.dirname)(path);
      await createTempFolder(app, dirPath);
      const folderCleanup = await createTempFolder(app, (0, import_Path8.dirname)(path));
      await createFolderSafe4(app, path);
      folder = app.vault.getFolderByPath(path);
      return async () => {
        if (!folder.deleted) {
          await app.vault.delete(folder, true);
        }
        await folderCleanup();
      };
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Blob.cjs
var require_Blob = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Blob.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Blob_exports = {};
    __export2(Blob_exports, {
      base64ToArrayBuffer: () => base64ToArrayBuffer,
      blobToArrayBuffer: () => blobToArrayBuffer2,
      blobToJpegArrayBuffer: () => blobToJpegArrayBuffer2,
      isImageFile: () => isImageFile2
    });
    module2.exports = __toCommonJS2(Blob_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    async function blobToArrayBuffer2(blob) {
      return await new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsArrayBuffer(blob);
      });
    }
    async function blobToJpegArrayBuffer2(blob, jpegQuality) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = (e) => {
          const image = new Image();
          image.onload = () => {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            const imageWidth = image.width;
            const imageHeight = image.height;
            let data = "";
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            context.fillStyle = "#fff";
            context.fillRect(0, 0, imageWidth, imageHeight);
            context.save();
            context.translate(imageWidth / 2, imageHeight / 2);
            context.drawImage(image, 0, 0, imageWidth, imageHeight, -imageWidth / 2, -imageHeight / 2, imageWidth, imageHeight);
            context.restore();
            data = canvas.toDataURL("image/jpeg", jpegQuality);
            const arrayBuffer = base64ToArrayBuffer(data);
            resolve(arrayBuffer);
          };
          image.src = e.target.result;
        };
        reader.readAsDataURL(blob);
      });
    }
    function base64ToArrayBuffer(code) {
      const parts = code.split(";base64,");
      const raw = window.atob(parts[1]);
      const rawLength = raw.length;
      const uInt8Array = new Uint8Array(rawLength);
      for (let i = 0; i < rawLength; ++i) {
        uInt8Array[i] = raw.charCodeAt(i);
      }
      return uInt8Array.buffer;
    }
    function isImageFile2(file) {
      return file.type.startsWith("image/");
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/ObsidianSettings.cjs
var require_ObsidianSettings = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/ObsidianSettings.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var ObsidianSettings_exports = {};
    __export2(ObsidianSettings_exports, {
      shouldUseRelativeLinks: () => shouldUseRelativeLinks,
      shouldUseWikilinks: () => shouldUseWikilinks
    });
    module2.exports = __toCommonJS2(ObsidianSettings_exports);
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function shouldUseWikilinks(app) {
      return !app.vault.getConfig("useMarkdownLinks");
    }
    function shouldUseRelativeLinks(app) {
      return app.vault.getConfig("newLinkFormat") === "relative";
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Link.cjs
var require_Link = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Link.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Link_exports = {};
    __export2(Link_exports, {
      editLinks: () => editLinks,
      extractLinkFile: () => extractLinkFile2,
      generateMarkdownLink: () => generateMarkdownLink2,
      getAlias: () => getAlias2,
      splitSubpath: () => splitSubpath2,
      updateLink: () => updateLink2,
      updateLinksInFile: () => updateLinksInFile2
    });
    module2.exports = __toCommonJS2(Link_exports);
    var import_obsidian6 = require("obsidian");
    var import_MetadataCache3 = require_MetadataCache();
    var import_Vault7 = require_Vault();
    var import_implementations2 = require_implementations();
    var import_Path8 = require_Path();
    var import_String = require_String();
    var import_TFile = require_TFile();
    var import_TAbstractFile5 = require_TAbstractFile();
    var import_Async4 = require_Async();
    var import_ObsidianSettings = require_ObsidianSettings();
    var __import_meta_url13 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
    var __process13 = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var SPECIAL_LINK_SYMBOLS_REGEXP = /[\\\x00\x08\x0B\x0C\x0E-\x1F ]/g;
    function splitSubpath2(link) {
      const SUBPATH_SEPARATOR = "#";
      const [linkPath = "", subpath] = (0, import_String.normalize)(link).split(SUBPATH_SEPARATOR);
      return {
        linkPath,
        subpath: subpath ? SUBPATH_SEPARATOR + subpath : void 0
      };
    }
    async function updateLinksInFile2(options) {
      const {
        app,
        pathOrFile,
        oldPathOrFile,
        renameMap,
        forceMarkdownLinks,
        embedOnlyLinks
      } = options;
      await editLinks(app, pathOrFile, (link) => {
        const isEmbedLink = link.original.startsWith("!");
        if (embedOnlyLinks !== void 0 && embedOnlyLinks !== isEmbedLink) {
          return;
        }
        return convertLink(app, link, pathOrFile, oldPathOrFile, renameMap, forceMarkdownLinks);
      });
    }
    function convertLink(app, link, source, oldPathOrFile, renameMap, forceMarkdownLinks) {
      oldPathOrFile ??= (0, import_TAbstractFile5.getPath)(source);
      return updateLink2({
        app,
        link,
        pathOrFile: extractLinkFile2(app, link, oldPathOrFile),
        oldPathOrFile,
        sourcePathOrFile: source,
        renameMap,
        forceMarkdownLinks
      });
    }
    function extractLinkFile2(app, link, oldPathOrFile) {
      const { linkPath } = splitSubpath2(link.link);
      return app.metadataCache.getFirstLinkpathDest(linkPath, (0, import_TAbstractFile5.getPath)(oldPathOrFile));
    }
    function updateLink2(options) {
      const {
        app,
        link,
        pathOrFile,
        oldPathOrFile,
        sourcePathOrFile: source,
        renameMap,
        forceMarkdownLinks
      } = options;
      if (!pathOrFile) {
        return link.original;
      }
      let file = (0, import_TFile.getFile)(app, pathOrFile);
      const sourcePath = (0, import_TAbstractFile5.getPath)(source);
      const oldPath = (0, import_TAbstractFile5.getPath)(oldPathOrFile);
      const isEmbed = link.original.startsWith("!");
      const isWikilink = link.original.includes("[[") && forceMarkdownLinks !== true;
      const { subpath } = splitSubpath2(link.link);
      const newPath = renameMap.get(file.path);
      const alias = getAlias2({
        app,
        displayText: link.displayText,
        file: pathOrFile,
        otherPaths: [oldPath, newPath],
        sourcePath
      });
      if (newPath) {
        file = (0, import_implementations2.createTFileInstance)(app.vault, newPath);
      }
      const newLink = generateMarkdownLink2({
        app,
        pathOrFile: file,
        sourcePathOrFile: sourcePath,
        subpath,
        alias,
        isEmbed,
        isWikilink
      });
      return newLink;
    }
    function getAlias2(options) {
      const {
        app,
        displayText,
        file: pathOrFile,
        otherPaths,
        sourcePath
      } = options;
      const file = (0, import_TFile.getFile)(app, pathOrFile);
      if (!displayText) {
        return void 0;
      }
      const cleanDisplayText = (0, import_obsidian6.normalizePath)(displayText.split(" > ")[0]).replace(/\.\//g, "");
      for (const path of [file.path, ...otherPaths]) {
        if (!path) {
          continue;
        }
        const extension = (0, import_Path8.extname)(path);
        const fileNameWithExtension = (0, import_Path8.basename)(path);
        const fileNameWithoutExtension = (0, import_Path8.basename)(path, extension);
        if (cleanDisplayText === path || cleanDisplayText === fileNameWithExtension || cleanDisplayText === fileNameWithoutExtension) {
          return void 0;
        }
      }
      for (const omitMdExtension of [true, false]) {
        const linkText = app.metadataCache.fileToLinktext(file, sourcePath, omitMdExtension);
        if (cleanDisplayText === linkText) {
          return void 0;
        }
      }
      return displayText;
    }
    function generateMarkdownLink2(options) {
      const { app } = options;
      const file = (0, import_TFile.getFile)(app, options.pathOrFile);
      const sourcePath = (0, import_TAbstractFile5.getPath)(options.sourcePathOrFile);
      const subpath = options.subpath ?? "";
      let alias = options.alias ?? "";
      const isEmbed = options.isEmbed ?? !(0, import_TAbstractFile5.isMarkdownFile)(file);
      const isWikilink = options.isWikilink ?? (0, import_ObsidianSettings.shouldUseWikilinks)(app);
      const forceRelativePath = options.forceRelativePath ?? (0, import_ObsidianSettings.shouldUseRelativeLinks)(app);
      let linkText = file.path === sourcePath && subpath ? subpath : forceRelativePath ? (0, import_Path8.relative)((0, import_Path8.dirname)(sourcePath), isWikilink ? (0, import_TAbstractFile5.trimMarkdownExtension)(file) : file.path) + subpath : app.metadataCache.fileToLinktext(file, sourcePath, isWikilink) + subpath;
      if (forceRelativePath && options.useLeadingDot && !linkText.startsWith(".") && !linkText.startsWith("#")) {
        linkText = "./" + linkText;
      }
      if (!isWikilink) {
        if (options.useAngleBrackets) {
          linkText = `<${linkText}>`;
        } else {
          linkText = linkText.replace(SPECIAL_LINK_SYMBOLS_REGEXP, function(specialLinkSymbol) {
            return encodeURIComponent(specialLinkSymbol);
          });
        }
        if (!isEmbed) {
          return `[${alias || file.basename}](${linkText})`;
        } else {
          return `![${alias}](${linkText})`;
        }
      } else {
        if (alias && alias.toLowerCase() === linkText.toLowerCase()) {
          linkText = alias;
          alias = "";
        }
        return (isEmbed ? "!" : "") + (alias ? `[[${linkText}|${alias}]]` : `[[${linkText}]]`);
      }
    }
    async function editLinks(app, pathOrFile, linkConverter, retryOptions = {}) {
      return await (0, import_Vault7.applyFileChanges)(app, pathOrFile, async () => {
        const cache = await (0, import_MetadataCache3.getCacheSafe)(app, pathOrFile);
        if (!cache) {
          return [];
        }
        const changes = [];
        for (const link of (0, import_MetadataCache3.getAllLinks)(cache)) {
          const newContent = await linkConverter(link);
          if (newContent === void 0) {
            continue;
          }
          changes.push({
            startIndex: link.position.start.offset,
            endIndex: link.position.end.offset,
            oldContent: link.original,
            newContent
          });
        }
        return changes;
      }, retryOptions);
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CustomAttachmentLocationPlugin
});
module.exports = __toCommonJS(main_exports);

// src/CustomAttachmentLocationPlugin.ts
var import_obsidian5 = require("obsidian");

// src/CustomAttachmentLocationPluginSettings.ts
var import_PluginSettings = __toESM(require_PluginSettings(), 1);
var __import_meta_url = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
var CustomAttachmentLocationPluginSettings = class _CustomAttachmentLocationPluginSettings {
  attachmentFolderPath = "./assets/${filename}";
  autoRenameFiles = false;
  autoRenameFolder = true;
  convertImagesToJpeg = false;
  convertImagesOnDragAndDrop = false;
  duplicateNameSeparator = " ";
  jpegQuality = 0.8;
  keepEmptyAttachmentFolders = false;
  pastedFileName = "file-${date:YYYYMMDDHHmmssSSS}";
  renameOnlyImages = true;
  renamePastedFilesWithKnownNames = false;
  renameAttachmentsOnDragAndDrop = false;
  replaceWhitespace = false;
  toLowerCase = false;
  static load(data) {
    const legacySettings = (0, import_PluginSettings.loadPluginSettings)(() => new LegacySettings(), data);
    let shouldSave = false;
    if (legacySettings.dateTimeFormat || legacySettings.pastedImageFileName) {
      const dateTimeFormat = legacySettings.dateTimeFormat || "YYYYMMDDHHmmssSSS";
      legacySettings.attachmentFolderPath = addDateTimeFormat(legacySettings.attachmentFolderPath, dateTimeFormat);
      legacySettings.pastedFileName = addDateTimeFormat(legacySettings.pastedFileName || legacySettings.pastedImageFileName || "file-${date}", dateTimeFormat);
      legacySettings.dateTimeFormat = "";
      legacySettings.pastedImageFileName = "";
      shouldSave = true;
    }
    const settings = (0, import_PluginSettings.loadPluginSettings)(() => new _CustomAttachmentLocationPluginSettings(), legacySettings);
    return { settings, shouldSave };
  }
};
function addDateTimeFormat(str, dateTimeFormat) {
  return str.replaceAll("${date}", `\${date:${dateTimeFormat}}`);
}
var LegacySettings = class extends CustomAttachmentLocationPluginSettings {
  dateTimeFormat = "";
  pastedImageFileName = "";
};

// src/CustomAttachmentLocationPluginSettingsTab.ts
var import_obsidian = require("obsidian");

// src/PathValidator.ts
var __import_meta_url2 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process2 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
var INVALID_FILENAME_PATH_CHARS_REG_EXP = /[\\/:*?"<>|]/;
var ONLY_DOTS_REG_EXP = /^\.+$/;
function validateFilename(filename) {
  filename = removeDateFormatting(filename);
  if (!filename) {
    return "File name is empty";
  }
  if (INVALID_FILENAME_PATH_CHARS_REG_EXP.test(filename)) {
    return `File name "${filename}" contains invalid symbols`;
  }
  if (ONLY_DOTS_REG_EXP.test(filename)) {
    return `File name "${filename}" contains only dots`;
  }
  if (filename[0] === ".") {
    return `Dot-files like "${filename}" are not allowed`;
  }
  return "";
}
function validatePath(path) {
  path = removeDateFormatting(path);
  if (path.startsWith("/")) {
    return "Path can't start with /";
  }
  if (path.endsWith("/")) {
    return "Path can't end with /";
  }
  const parts = path.split("/");
  for (const part of parts) {
    if (part === ".") {
      continue;
    }
    const partValidationError = validateFilename(part);
    if (partValidationError) {
      return partValidationError;
    }
  }
  return "";
}
function removeDateFormatting(str) {
  return str.replaceAll(/\$\{date:.+?\}/g, "${date}");
}

// src/CustomAttachmentLocationPluginSettingsTab.ts
var import_PluginSettingsTabBase = __toESM(require_PluginSettingsTabBase(), 1);
var import_DocumentFragment = __toESM(require_DocumentFragment(), 1);
var import_UIComponent = __toESM(require_UIComponent(), 1);
var __import_meta_url3 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process3 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
var CustomAttachmentLocationPluginSettingsTab = class extends import_PluginSettingsTabBase.PluginSettingsTabBase {
  display() {
    this.containerEl.empty();
    new import_obsidian.Setting(this.containerEl).setName("Location for New Attachments").setDesc(createFragment((f) => {
      f.appendText("Start with ");
      (0, import_DocumentFragment.appendCodeBlock)(f, ".");
      f.appendText(" to use relative path. Available variables: ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${filename}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${foldername}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${folderPath}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${date:format}");
      f.appendText(".");
      f.appendChild(createEl("br"));
      f.appendText("Don't use dot-folders like ");
      (0, import_DocumentFragment.appendCodeBlock)(f, ".attachments");
      f.appendText(", because Obsidian doesn't track them");
    })).addText(
      (text) => (0, import_UIComponent.bindUiComponent)(this.plugin, text, "attachmentFolderPath", {
        uiValueValidator(uiValue) {
          return validatePath(uiValue);
        },
        settingToUIValueConverter(pluginValue) {
          return pluginValue;
        },
        uiToSettingValueConverter(uiValue) {
          return (0, import_obsidian.normalizePath)(uiValue);
        }
      }).setPlaceholder("./assets/${filename}")
    );
    new import_obsidian.Setting(this.containerEl).setName("Pasted File Name").setDesc(createFragment((f) => {
      f.appendText("Available variables: ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${filename}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${foldername}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${date:format}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${originalCopiedFilename}");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${prompt}");
      f.appendText(".");
    })).addText(
      (text) => (0, import_UIComponent.bindUiComponent)(this.plugin, text, "pastedFileName", {
        uiValueValidator(uiValue) {
          return validatePath(uiValue);
        }
      }).setPlaceholder("file-${date:YYYYMMDDHHmmssSSS}")
    );
    new import_obsidian.Setting(this.containerEl).setName("Automatically rename attachment folder").setDesc(createFragment((f) => {
      f.appendText("When renaming md files, automatically rename attachment folder if folder name contains ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${filename}");
      f.appendText(".");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "autoRenameFolder"));
    new import_obsidian.Setting(this.containerEl).setName("Automatically rename attachment files").setDesc(createFragment((f) => {
      f.appendText("When renaming md files, automatically rename attachment files if file name contains ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "${filename}");
      f.appendText(".");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "autoRenameFiles"));
    new import_obsidian.Setting(this.containerEl).setName("Replace whitespace with hyphen").setDesc("Automatically replace whitespace in attachment folder and file name with hyphens.").addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "replaceWhitespace"));
    new import_obsidian.Setting(this.containerEl).setName("All lowercase names").setDesc("Automatically set all characters in folder name and pasted image name to be lowercase.").addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "toLowerCase"));
    new import_obsidian.Setting(this.containerEl).setName("Convert pasted images to JPEG").setDesc("Paste images from clipboard converting them to JPEG.").addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "convertImagesToJpeg"));
    new import_obsidian.Setting(this.containerEl).setName("JPEG Quality").setDesc("The smaller the quality, the greater the compression ratio.").addDropdown((dropDown) => (0, import_UIComponent.bindUiComponent)(this.plugin, dropDown, "jpegQuality", {
      settingToUIValueConverter: (value) => value.toString(),
      uiToSettingValueConverter: (value) => Number(value)
    }).addOptions(generateJpegQualityOptions()));
    new import_obsidian.Setting(this.containerEl).setName("Convert images on drag&drop").setDesc(createFragment((f) => {
      f.appendText("If enabled and ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "Convert pasted images to JPEG");
      f.appendText(" setting is enabled, images drag&dropped into the editor will be converted to JPEG.");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "convertImagesOnDragAndDrop"));
    new import_obsidian.Setting(this.containerEl).setName("Rename only images").setDesc(createFragment((f) => {
      f.appendText("If enabled, only image files will be renamed.");
      f.appendChild(createEl("br"));
      f.appendText("If disabled, all attachment files will be renamed.");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "renameOnlyImages"));
    new import_obsidian.Setting(this.containerEl).setName("Rename pasted files with known names").setDesc(createFragment((f) => {
      f.appendText("If enabled, pasted copied files with known names will be renamed.");
      f.appendChild(createEl("br"));
      f.appendText("If disabled, only clipboard image objects (e.g., screenshots) will be renamed.");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "renamePastedFilesWithKnownNames"));
    new import_obsidian.Setting(this.containerEl).setName("Rename attachments on drag&drop").setDesc(createFragment((f) => {
      f.appendText("If enabled, attachments dragged and dropped into the editor will be renamed according to the ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "Pasted File Name");
      f.appendText(" setting.");
    })).addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "renameAttachmentsOnDragAndDrop"));
    new import_obsidian.Setting(this.containerEl).setName("Duplicate name separator").setDesc(createFragment((f) => {
      f.appendText("When you are pasting/dragging a file with the same name as an existing file, this separator will be added to the file name.");
      f.appendChild(createEl("br"));
      f.appendText("E.g., when you are dragging file ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "existingFile.pdf");
      f.appendText(", it will be renamed to ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "existingFile 1.pdf");
      f.appendText(", ");
      (0, import_DocumentFragment.appendCodeBlock)(f, "existingFile 2.pdf");
      f.appendText(", etc, getting the first name available.");
    })).addText(
      (text) => (0, import_UIComponent.bindUiComponent)(this.plugin, text, "duplicateNameSeparator", {
        uiValueValidator(uiValue) {
          return uiValue === "" ? null : validateFilename(uiValue);
        }
      }).setPlaceholder(" ")
    );
    new import_obsidian.Setting(this.containerEl).setName("Keep empty attachment folders").setDesc("If enabled, empty attachment folders will be preserved, useful for source control purposes.").addToggle((toggle) => (0, import_UIComponent.bindUiComponent)(this.plugin, toggle, "keepEmptyAttachmentFolders"));
  }
};
function generateJpegQualityOptions() {
  const ans = {};
  for (let i = 1; i <= 10; i++) {
    const valueStr = (i / 10).toFixed(1);
    ans[valueStr] = valueStr;
  }
  return ans;
}

// src/CustomAttachmentLocationPlugin.ts
var import_Path7 = __toESM(require_Path(), 1);
var import_Async3 = __toESM(require_Async(), 1);

// src/AttachmentPath.ts
var import_moment = __toESM(require_moment(), 1);
var import_RegExp = __toESM(require_RegExp(), 1);
var import_obsidian2 = require("obsidian");
var import_Path2 = __toESM(require_Path(), 1);
var import_Prompt = __toESM(require_Prompt(), 1);

// src/Substitutions.ts
var import_Path = __toESM(require_Path(), 1);
var __import_meta_url4 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process4 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
function createSubstitutionsFromPath(path, originalCopiedFilename) {
  const folderPath = (0, import_Path.dirname)(path);
  return {
    filename: (0, import_Path.basename)(path, (0, import_Path.extname)(path)),
    foldername: (0, import_Path.basename)(folderPath),
    folderPath,
    originalCopiedFilename: originalCopiedFilename ?? ""
  };
}

// src/AttachmentPath.ts
var __import_meta_url5 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process5 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
function interpolateToDigitRegex(template, substitutions) {
  const dateRegExp = /\$\{date:(.*?)\}/g;
  let regExpString = template.replaceAll(dateRegExp, (_, p1) => {
    return `\\d{${p1.length}}`;
  });
  for (const [key, value] of Object.entries(substitutions)) {
    regExpString = regExpString.replaceAll(`\${${key}}`, (0, import_RegExp.escapeRegExp)(value));
  }
  return new RegExp(`^${regExpString}$`);
}
async function interpolateDateToString(plugin, template, substitutions) {
  const dateRegExp = /\$\{date:(.*?)\}/g;
  let newPath = template.replaceAll(dateRegExp, (_, dateFormat) => (0, import_moment.default)().format(dateFormat));
  for (const [key, value] of Object.entries(substitutions)) {
    newPath = newPath.replaceAll(`\${${key}}`, value);
  }
  if (substitutions.originalCopiedFilename) {
    if (newPath.includes("${prompt}")) {
      const newFileName = await (0, import_Prompt.prompt)({
        app: plugin.app,
        title: "Rename attachment file",
        defaultValue: substitutions.originalCopiedFilename,
        valueValidator: (value) => {
          return validateFilename(value);
        }
      }) ?? substitutions.originalCopiedFilename;
      newPath = newPath.replaceAll("${prompt}", newFileName);
    }
  }
  if (plugin.settingsCopy.toLowerCase) {
    newPath = newPath.toLowerCase();
  }
  if (plugin.settingsCopy.replaceWhitespace) {
    newPath = newPath.replace(/\s/g, "-");
    newPath = newPath.replace(/-{2,}/g, "-");
  }
  return newPath;
}
async function getEarliestAttachmentFolder(plugin, attachmentFolderTemplate, substitutions) {
  const app = plugin.app;
  const targetRegex = interpolateToDigitRegex(attachmentFolderTemplate, substitutions);
  const folders = app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian2.TFolder).filter((f) => targetRegex.test(f.path));
  const folderStats = [];
  for (const folder of folders) {
    const stat = await app.vault.adapter.stat((0, import_Path2.join)(app.vault.adapter.getBasePath(), folder.path));
    folderStats.push({
      path: folder.path,
      ctime: stat?.ctime ?? 0
    });
  }
  if (folderStats.length > 0) {
    return folderStats.sort((a, b) => a.ctime - b.ctime).map((f) => f.path)[0];
  } else {
    return interpolateDateToString(plugin, attachmentFolderTemplate, substitutions);
  }
}
async function getAttachmentFolderPath(plugin, substitutions) {
  return await getEarliestAttachmentFolder(plugin, plugin.settingsCopy.attachmentFolderPath, substitutions);
}
async function getAttachmentFolderFullPathForSubstitutions(plugin, substitutions) {
  let attachmentFolder = "";
  const useRelativePath = plugin.settingsCopy.attachmentFolderPath.startsWith("./");
  if (useRelativePath) {
    attachmentFolder = (0, import_Path2.join)(substitutions.folderPath, await getAttachmentFolderPath(plugin, substitutions));
  } else {
    attachmentFolder = await getAttachmentFolderPath(plugin, substitutions);
  }
  return (0, import_obsidian2.normalizePath)(attachmentFolder);
}
async function getAttachmentFolderFullPathForPath(plugin, path) {
  return await getAttachmentFolderFullPathForSubstitutions(plugin, createSubstitutionsFromPath(path));
}
async function getPastedFileName(plugin, substitutions) {
  return await interpolateDateToString(plugin, plugin.settingsCopy.pastedFileName, substitutions);
}
function makeFileName(fileName, extension) {
  return extension ? `${fileName}.${extension}` : fileName;
}

// node_modules/monkey-around/dist/index.mjs
var __import_meta_url6 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process6 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/CustomAttachmentLocationPlugin.ts
var import_Vault6 = __toESM(require_Vault(), 1);
var import_TAbstractFile4 = __toESM(require_TAbstractFile(), 1);

// src/PasteDropEvent.ts
var import_Path4 = __toESM(require_Path(), 1);
var import_Blob = __toESM(require_Blob(), 1);
var import_TAbstractFile = __toESM(require_TAbstractFile(), 1);
var import_Async = __toESM(require_Async(), 1);

// src/Vault.ts
var import_Path3 = __toESM(require_Path(), 1);
var import_Vault = __toESM(require_Vault(), 1);
var __import_meta_url7 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process7 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
async function createFolderSafeEx(plugin, path) {
  const result = await (0, import_Vault.createFolderSafe)(plugin.app, path);
  if (plugin.settingsCopy.keepEmptyAttachmentFolders) {
    const gitKeepPath = (0, import_Path3.join)(path, ".gitkeep");
    if (!await plugin.app.vault.adapter.exists(gitKeepPath)) {
      await plugin.app.vault.create(gitKeepPath, "");
    }
  }
  return result;
}

// src/PasteDropEvent.ts
var __import_meta_url8 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process8 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
function registerPasteDropEventHandlers(plugin) {
  const listener = (0, import_Async.convertAsyncToSync)(async (event) => handlePasteAndDrop(plugin, event));
  plugin.registerDomEvent(document, "paste", listener, { capture: true });
  plugin.registerDomEvent(document, "drop", listener, { capture: true });
}
async function handlePasteAndDrop(plugin, event) {
  const eventWrapper = event instanceof ClipboardEvent ? new PasteEventWrapper(event, plugin) : new DropEventWrapper(event, plugin);
  await eventWrapper.handle();
}
var EventWrapper = class {
  constructor(event, eventType, plugin) {
    this.event = event;
    this.eventType = eventType;
    this.plugin = plugin;
  }
  async handle() {
    let handledEvent = this.event;
    if (handledEvent.handled) {
      return;
    }
    const draggable = this.plugin.app.dragManager.draggable;
    const targetType = this.getTargetType();
    if (targetType === "Unsupported" /* Unsupported */) {
      return;
    }
    console.debug(`Handle ${targetType} ${this.eventType}`);
    const noteFile = this.plugin.app.workspace.getActiveFile();
    if (!(0, import_TAbstractFile.isNote)(noteFile)) {
      return;
    }
    const dataTransfer = this.getDataTransfer();
    if (!dataTransfer) {
      return;
    }
    if (!this.event.target) {
      return;
    }
    this.event.preventDefault();
    this.event.stopImmediatePropagation();
    const pastedEntries = Array.from(dataTransfer.items).map((item) => {
      const type = item.type;
      if (item.kind === "file") {
        const file = item.getAsFile();
        if (!file) {
          throw new Error("Could not get file from item");
        }
        return {
          file,
          type
        };
      } else if (item.kind === "string") {
        const textPromise = new Promise((resolve) => item.getAsString((text) => resolve(text)));
        return {
          textPromise,
          type
        };
      } else {
        throw new Error(`Unsupported item kind ${item.kind}`);
      }
    });
    const newDataTransfer = new DataTransfer();
    let hasFiles = false;
    for (const entry of pastedEntries) {
      if (entry.textPromise) {
        newDataTransfer.items.add(await entry.textPromise, entry.type);
      } else if (entry.file) {
        let extension = (0, import_Path4.extname)(entry.file.name).slice(1);
        const originalCopiedFileName = (0, import_Path4.basename)(entry.file.name, "." + extension);
        let fileArrayBuffer;
        if (this.shouldConvertImages() && (0, import_Blob.isImageFile)(entry.file)) {
          fileArrayBuffer = await (0, import_Blob.blobToJpegArrayBuffer)(entry.file, this.plugin.settingsCopy.jpegQuality);
          extension = "jpg";
        } else {
          fileArrayBuffer = await (0, import_Blob.blobToArrayBuffer)(entry.file);
        }
        const shouldRename = this.shouldRenameAttachments(entry.file);
        const filename = shouldRename ? await getPastedFileName(this.plugin, createSubstitutionsFromPath(noteFile.path, originalCopiedFileName)) : originalCopiedFileName;
        const filePropertyBag = { type: "application/octet-stream" };
        if (!shouldRename) {
          filePropertyBag.lastModified = entry.file.lastModified;
        }
        const renamedFile = new File([new Blob([fileArrayBuffer])], makeFileName(filename, extension), filePropertyBag);
        if (!shouldRename) {
          Object.defineProperty(renamedFile, "path", { value: entry.file.path });
        }
        newDataTransfer.items.add(renamedFile);
        hasFiles = true;
      }
    }
    if (hasFiles) {
      const attachmentsFolderPath = await getAttachmentFolderFullPathForPath(this.plugin, noteFile.path);
      await createFolderSafeEx(this.plugin, attachmentsFolderPath);
    }
    handledEvent = this.cloneWithNewDataTransfer(newDataTransfer);
    handledEvent.handled = true;
    this.plugin.app.dragManager.draggable = draggable;
    this.event.target.dispatchEvent(handledEvent);
  }
  getTargetType() {
    if (!(this.event.target instanceof HTMLElement)) {
      return "Unsupported" /* Unsupported */;
    }
    if (this.plugin.app.workspace.activeEditor?.metadataEditor?.contentEl.contains(this.event.target)) {
      return "Unsupported" /* Unsupported */;
    }
    if (this.plugin.app.workspace.activeEditor?.editor?.containerEl.contains(this.event.target)) {
      return "Note" /* Note */;
    }
    if (this.event.target.closest(".canvas-wrapper")) {
      return "Canvas" /* Canvas */;
    }
    const canvasView = this.plugin.app.workspace.getActiveFileView();
    if (this.event.target.matches("body") && canvasView?.getViewType() === "canvas" && canvasView.containerEl.closest(".mod-active")) {
      return "Canvas" /* Canvas */;
    }
    return "Unsupported" /* Unsupported */;
  }
};
var PasteEventWrapper = class extends EventWrapper {
  constructor(event, plugin) {
    super(event, "Paste", plugin);
    this.event = event;
  }
  getDataTransfer() {
    return this.event.clipboardData;
  }
  cloneWithNewDataTransfer(dataTransfer) {
    return new ClipboardEvent("paste", {
      clipboardData: dataTransfer,
      bubbles: this.event.bubbles,
      cancelable: this.event.cancelable,
      composed: this.event.composed
    });
  }
  shouldRenameAttachments(file) {
    if (this.plugin.settingsCopy.renameOnlyImages && !(0, import_Blob.isImageFile)(file)) {
      return false;
    }
    return file.path === "" || this.plugin.settingsCopy.renamePastedFilesWithKnownNames;
  }
  shouldConvertImages() {
    return this.plugin.settingsCopy.convertImagesToJpeg;
  }
};
var DropEventWrapper = class extends EventWrapper {
  constructor(event, plugin) {
    super(event, "Drop", plugin);
    this.event = event;
  }
  getDataTransfer() {
    return this.event.dataTransfer;
  }
  cloneWithNewDataTransfer(dataTransfer) {
    return new DragEvent("drop", {
      dataTransfer,
      bubbles: this.event.bubbles,
      cancelable: this.event.cancelable,
      composed: this.event.composed,
      clientX: this.event.clientX,
      clientY: this.event.clientY
    });
  }
  shouldRenameAttachments(file) {
    if (this.plugin.settingsCopy.renameOnlyImages && !(0, import_Blob.isImageFile)(file)) {
      return false;
    }
    return this.plugin.settingsCopy.renameAttachmentsOnDragAndDrop;
  }
  shouldConvertImages() {
    return this.plugin.settingsCopy.convertImagesToJpeg && this.plugin.settingsCopy.convertImagesOnDragAndDrop;
  }
};

// src/AttachmentCollector.ts
var import_obsidian3 = require("obsidian");
var import_MetadataCache = __toESM(require_MetadataCache(), 1);
var import_Vault3 = __toESM(require_Vault(), 1);
var import_TAbstractFile2 = __toESM(require_TAbstractFile(), 1);
var import_Async2 = __toESM(require_Async(), 1);
var import_JSON = __toESM(require_JSON(), 1);
var import_Link = __toESM(require_Link(), 1);
var import_Path5 = __toESM(require_Path(), 1);
var __import_meta_url9 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process9 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
function collectAttachmentsCurrentNote(plugin, checking) {
  const note = plugin.app.workspace.getActiveFile();
  if (!(0, import_TAbstractFile2.isNote)(note)) {
    return false;
  }
  if (!checking) {
    (0, import_Async2.invokeAsyncSafely)(collectAttachments(plugin, note));
  }
  return true;
}
function collectAttachmentsCurrentFolder(plugin, checking) {
  const note = plugin.app.workspace.getActiveFile();
  if (!(0, import_TAbstractFile2.isNote)(note)) {
    return false;
  }
  if (!checking) {
    (0, import_Async2.invokeAsyncSafely)(collectAttachmentsInFolder(plugin, note.parent));
  }
  return true;
}
function collectAttachmentsEntireVault(plugin) {
  (0, import_Async2.invokeAsyncSafely)(collectAttachmentsInFolder(plugin, plugin.app.vault.getRoot()));
}
async function collectAttachments(plugin, note, oldPath, attachmentFilter) {
  const app = plugin.app;
  oldPath ??= note.path;
  attachmentFilter ??= () => true;
  console.debug(`Collect attachments in note: ${note.path}`);
  const attachmentsMap = /* @__PURE__ */ new Map();
  const isCanvas = note.extension.toLowerCase() === "canvas";
  await (0, import_Vault3.applyFileChanges)(app, note, async () => {
    const cache = await (0, import_MetadataCache.getCacheSafe)(app, note);
    if (!cache) {
      return [];
    }
    const links = isCanvas ? await getCanvasLinks(app, note) : (0, import_MetadataCache.getAllLinks)(cache);
    const changes = [];
    for (const link of links) {
      const attachmentMoveResult = await prepareAttachmentToMove(plugin, link, note.path, oldPath);
      if (!attachmentMoveResult) {
        continue;
      }
      if (!attachmentFilter(attachmentMoveResult.oldAttachmentPath)) {
        continue;
      }
      attachmentsMap.set(attachmentMoveResult.oldAttachmentPath, attachmentMoveResult.newAttachmentPath);
      if (!isCanvas) {
        changes.push({
          startIndex: link.position.start.offset,
          endIndex: link.position.end.offset,
          oldContent: link.original,
          newContent: attachmentMoveResult.newAttachmentLink
        });
      }
    }
    return changes;
  });
  if (isCanvas) {
    await (0, import_Vault3.processWithRetry)(app, note, (content) => {
      const canvasData = JSON.parse(content);
      for (const node of canvasData.nodes) {
        if (node.type !== "file") {
          continue;
        }
        const newPath = attachmentsMap.get(node.file);
        if (!newPath) {
          continue;
        }
        node.file = newPath;
      }
      return (0, import_JSON.toJson)(canvasData);
    });
  }
  const notice = new import_obsidian3.Notice(`Collecting ${attachmentsMap.size} attachments for ${note.path}`);
  await (0, import_MetadataCache.getCacheSafe)(app, note);
  for (const [oldPath2, newPath] of attachmentsMap.entries()) {
    const oldAttachmentFile = app.vault.getFileByPath(oldPath2);
    if (!oldAttachmentFile) {
      continue;
    }
    const oldAttachmentFolder = oldAttachmentFile.parent;
    const backlinks = await (0, import_MetadataCache.getBacklinksForFileSafe)(app, oldAttachmentFile);
    await createFolderSafeEx(plugin, (0, import_Path5.dirname)(newPath));
    if (backlinks.count() === 0) {
      await app.vault.rename(oldAttachmentFile, newPath);
      await (0, import_Vault3.removeEmptyFolderHierarchy)(app, oldAttachmentFolder);
    } else {
      await app.vault.copy(oldAttachmentFile, newPath);
    }
  }
  notice.hide();
}
async function prepareAttachmentToMove(plugin, link, newNotePath, oldNotePath) {
  const app = plugin.app;
  const { linkPath, subpath } = splitSubpath(link.link);
  let oldAttachmentFile = app.metadataCache.getFirstLinkpathDest(linkPath, oldNotePath);
  if (!oldAttachmentFile) {
    return null;
  }
  if ((0, import_TAbstractFile2.isNote)(oldAttachmentFile)) {
    return null;
  }
  oldAttachmentFile = oldAttachmentFile;
  const oldAttachmentPath = oldAttachmentFile.path;
  const oldAttachmentName = oldAttachmentFile.name;
  const oldNoteBaseName = (0, import_Path5.basename)(oldNotePath, (0, import_Path5.extname)(oldNotePath));
  const newNoteBaseName = (0, import_Path5.basename)(newNotePath, (0, import_Path5.extname)(newNotePath));
  const newAttachmentName = plugin.settingsCopy.autoRenameFiles ? oldAttachmentName.replaceAll(oldNoteBaseName, newNoteBaseName) : oldAttachmentName;
  const newAttachmentFolderPath = await getAttachmentFolderFullPathForPath(plugin, newNotePath);
  const newAttachmentPath = (0, import_Path5.join)(newAttachmentFolderPath, newAttachmentName);
  if (oldAttachmentPath === newAttachmentPath) {
    return null;
  }
  const shouldRemoveNewAttachmentFolder = await createFolderSafeEx(plugin, (0, import_Path5.dirname)(newAttachmentPath));
  const newAttachmentFile = await app.vault.create(newAttachmentPath, "");
  const newAttachmentLink = (0, import_Link.generateMarkdownLink)({
    app,
    pathOrFile: newAttachmentFile,
    sourcePathOrFile: newNotePath,
    subpath,
    alias: (0, import_Link.getAlias)({
      app,
      displayText: link.displayText,
      file: newAttachmentFile,
      otherPaths: [oldAttachmentPath],
      sourcePath: newNotePath
    }),
    isEmbed: link.original.startsWith("!"),
    isWikilink: link.original.includes("[[")
  });
  await app.vault.delete(newAttachmentFile);
  if (shouldRemoveNewAttachmentFolder) {
    await (0, import_Vault3.removeFolderSafe)(app, (0, import_Path5.dirname)(newAttachmentPath));
  }
  return {
    oldAttachmentPath,
    newAttachmentPath,
    newAttachmentLink
  };
}
async function collectAttachmentsInFolder(plugin, folder) {
  console.debug(`Collect attachments in folder: ${folder.path}`);
  const files = [];
  import_obsidian3.Vault.recurseChildren(folder, (child) => {
    if ((0, import_TAbstractFile2.isNote)(child)) {
      files.push(child);
    }
  });
  files.sort((a, b) => a.path.localeCompare(b.path));
  const notice = new import_obsidian3.Notice("", 0);
  let i = 0;
  for (const file of files) {
    i++;
    const message = `Collecting attachments # ${i} / ${files.length} - ${file.path}`;
    notice.setMessage(message);
    await collectAttachments(plugin, file);
  }
  notice.hide();
}
function splitSubpath(link) {
  const SUBPATH_SEPARATOR = "#";
  const [linkPath = "", subpath] = link.split(SUBPATH_SEPARATOR);
  return {
    linkPath,
    subpath: subpath ? SUBPATH_SEPARATOR + subpath : void 0
  };
}
async function getCanvasLinks(app, file) {
  const canvasData = await app.vault.readJson(file.path);
  const files = canvasData.nodes.filter((node) => node.type === "file").map((node) => node.file);
  return files.map((file2) => ({
    link: file2,
    original: file2,
    position: {
      start: { col: 0, line: 0, loc: 0, offset: 0 },
      end: { col: 0, line: 0, loc: 0, offset: 0 }
    }
  }));
}

// src/RenameDeleteHandler.ts
var import_obsidian4 = require("obsidian");
var import_Path6 = __toESM(require_Path(), 1);
var import_Vault5 = __toESM(require_Vault(), 1);
var import_TAbstractFile3 = __toESM(require_TAbstractFile(), 1);
var import_MetadataCache2 = __toESM(require_MetadataCache(), 1);
var import_JSON2 = __toESM(require_JSON(), 1);
var import_Link2 = __toESM(require_Link(), 1);
var import_implementations = __toESM(require_implementations(), 1);
var __import_meta_url10 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process10 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
var renamingPaths = /* @__PURE__ */ new Set();
async function handleRename(plugin, file, oldPath) {
  if (renamingPaths.has(oldPath)) {
    return;
  }
  console.debug("Handle Rename");
  if (!(file instanceof import_obsidian4.TFile)) {
    return;
  }
  const app = plugin.app;
  const updateAllLinks = app.fileManager.updateAllLinks;
  try {
    plugin.app.fileManager.updateAllLinks = async () => {
    };
    const renameMap = /* @__PURE__ */ new Map();
    await fillRenameMap(plugin, file, oldPath, renameMap);
    for (const oldPath2 of renameMap.keys()) {
      renamingPaths.add(oldPath2);
    }
    for (const [oldPath2, newPath2] of renameMap.entries()) {
      await processRename(plugin, oldPath2, newPath2, renameMap);
    }
  } finally {
    renamingPaths.delete(oldPath);
    plugin.app.fileManager.updateAllLinks = updateAllLinks;
  }
}
async function handleDelete(plugin, file) {
  console.debug("Handle Delete");
  if (!(0, import_TAbstractFile3.isNote)(file)) {
    return;
  }
  if (renamingPaths.has(file.path)) {
    return;
  }
  const attachmentsFolderPath = await getAttachmentFolderFullPathForPath(plugin, file.path);
  await (0, import_Vault5.removeFolderSafe)(plugin.app, attachmentsFolderPath, file.path);
}
async function fillRenameMap(plugin, file, oldPath, renameMap) {
  const app = plugin.app;
  renameMap.set(oldPath, file.path);
  if (!(0, import_TAbstractFile3.isNote)(file)) {
    return;
  }
  const oldAttachmentFolderPath = await getAttachmentFolderFullPathForPath(plugin, oldPath);
  const newAttachmentFolderPath = await getAttachmentFolderFullPathForPath(plugin, file.path);
  const dummyOldAttachmentFolderPath = await getAttachmentFolderFullPathForPath(plugin, (0, import_Path6.join)((0, import_Path6.dirname)(oldPath), "DUMMY_FILE.md"));
  const oldAttachmentFolder = plugin.app.vault.getFolderByPath(oldAttachmentFolderPath);
  if (!oldAttachmentFolder) {
    return;
  }
  if (oldAttachmentFolderPath === newAttachmentFolderPath) {
    return;
  }
  const children = [];
  if (oldAttachmentFolderPath === dummyOldAttachmentFolderPath) {
    const cache = await (0, import_MetadataCache2.getCacheSafe)(app, file);
    if (!cache) {
      return;
    }
    for (const link of (0, import_MetadataCache2.getAllLinks)(cache)) {
      const attachmentFile = (0, import_Link2.extractLinkFile)(app, link, oldPath);
      if (!attachmentFile) {
        continue;
      }
      if (attachmentFile.path.startsWith(oldAttachmentFolderPath)) {
        const backlinks = await (0, import_MetadataCache2.getBacklinksForFileSafe)(app, attachmentFile);
        if (backlinks.keys().length === 1) {
          children.push(attachmentFile);
        }
      }
    }
  } else {
    import_obsidian4.Vault.recurseChildren(oldAttachmentFolder, (child) => {
      if (child instanceof import_obsidian4.TFile) {
        children.push(child);
      }
    });
  }
  const newNoteName = file.basename;
  const oldNoteName = (0, import_Path6.basename)(oldPath, (0, import_Path6.extname)(oldPath));
  for (let child of children) {
    if ((0, import_TAbstractFile3.isNote)(child)) {
      continue;
    }
    child = child;
    const relativePath = (0, import_Path6.relative)(oldAttachmentFolderPath, child.path);
    const newChildName = plugin.settingsCopy.autoRenameFiles ? child.basename.replaceAll(oldNoteName, newNoteName) : child.basename;
    const newDir = (0, import_Path6.join)(newAttachmentFolderPath, (0, import_Path6.dirname)(relativePath));
    let newChildPath = (0, import_Path6.join)(newDir, newChildName + "." + child.extension);
    if (child.path !== newChildPath) {
      newChildPath = plugin.app.vault.getAvailablePath((0, import_Path6.join)(newDir, newChildName), child.extension);
      renameMap.set(child.path, newChildPath);
    }
  }
}
async function processRename(plugin, oldPath, newPath, renameMap) {
  const app = plugin.app;
  let oldFile = null;
  try {
    oldFile = app.vault.getFileByPath(oldPath);
    let newFile = app.vault.getFileByPath(newPath);
    if (oldFile) {
      await (0, import_Vault5.createFolderSafe)(app, (0, import_Path6.dirname)(newPath));
      const oldFolder = oldFile.parent;
      try {
        if (newFile) {
          try {
            await app.vault.delete(newFile);
          } catch (e) {
            if (app.vault.getAbstractFileByPath(newPath)) {
              throw e;
            }
          }
        }
        await app.vault.rename(oldFile, newPath);
      } catch (e) {
        if (!app.vault.getAbstractFileByPath(newPath) || app.vault.getAbstractFileByPath(oldPath)) {
          throw e;
        }
      }
      await (0, import_Vault5.removeEmptyFolderHierarchy)(app, oldFolder);
    }
    oldFile = (0, import_implementations.createTFileInstance)(app.vault, oldPath);
    newFile = app.vault.getFileByPath(newPath);
    if (!oldFile.deleted || !newFile) {
      throw new Error(`Could not rename ${oldPath} to ${newPath}`);
    }
    const backlinks = await getBacklinks(plugin.app, oldFile, newFile);
    for (const parentNotePath of backlinks.keys()) {
      let parentNote = app.vault.getFileByPath(parentNotePath);
      if (!parentNote) {
        const newParentNotePath = renameMap.get(parentNotePath);
        if (newParentNotePath) {
          parentNote = app.vault.getFileByPath(newParentNotePath);
        }
      }
      if (!parentNote) {
        console.warn(`Parent note not found: ${parentNotePath}`);
        continue;
      }
      await (0, import_Vault5.applyFileChanges)(app, parentNote, async () => {
        const links = (await getBacklinks(plugin.app, oldFile, newFile)).get(parentNotePath) ?? [];
        const changes = [];
        for (const link of links) {
          changes.push({
            startIndex: link.position.start.offset,
            endIndex: link.position.end.offset,
            oldContent: link.original,
            newContent: (0, import_Link2.updateLink)({
              app,
              link,
              pathOrFile: newFile,
              oldPathOrFile: oldPath,
              sourcePathOrFile: parentNote,
              renameMap
            })
          });
        }
        return changes;
      });
    }
    if ((0, import_TAbstractFile3.isCanvasFile)(newFile)) {
      await (0, import_Vault5.processWithRetry)(app, newFile, (content) => {
        const canvasData = JSON.parse(content);
        for (const node of canvasData.nodes) {
          if (node.type !== "file") {
            continue;
          }
          const newPath2 = renameMap.get(node.file);
          if (!newPath2) {
            continue;
          }
          node.file = newPath2;
        }
        return (0, import_JSON2.toJson)(canvasData);
      });
    } else if ((0, import_TAbstractFile3.isMarkdownFile)(newFile)) {
      await (0, import_Link2.updateLinksInFile)({
        app,
        pathOrFile: newFile,
        oldPathOrFile: oldPath,
        renameMap
      });
    }
  } finally {
    renamingPaths.delete(oldPath);
  }
}
async function getBacklinks(app, oldFile, newFile) {
  const backlinks = /* @__PURE__ */ new Map();
  const oldLinks = await (0, import_MetadataCache2.getBacklinksForFileSafe)(app, oldFile);
  for (const path of oldLinks.keys()) {
    backlinks.set(path, oldLinks.get(path));
  }
  if (!newFile) {
    return backlinks;
  }
  const newLinks = await (0, import_MetadataCache2.getBacklinksForFileSafe)(app, newFile);
  for (const path of newLinks.keys()) {
    const links = backlinks.get(path) ?? [];
    links.push(...newLinks.get(path));
    backlinks.set(path, links);
  }
  return backlinks;
}

// src/CustomAttachmentLocationPlugin.ts
var import_PluginBase = __toESM(require_PluginBase(), 1);
var __import_meta_url11 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process11 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
var CustomAttachmentLocationPlugin = class extends import_PluginBase.PluginBase {
  createDefaultPluginSettings() {
    return new CustomAttachmentLocationPluginSettings();
  }
  createPluginSettingsTab() {
    return new CustomAttachmentLocationPluginSettingsTab(this);
  }
  onloadComplete() {
    this.registerEvent(this.app.vault.on("delete", (file) => (0, import_Async3.invokeAsyncSafely)(handleDelete(this, file))));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => (0, import_Async3.invokeAsyncSafely)(handleRename(this, file, oldPath))));
    registerPasteDropEventHandlers(this);
    this.addCommand({
      id: "collect-attachments-current-note",
      name: "Collect attachments in current note",
      checkCallback: (checking) => collectAttachmentsCurrentNote(this, checking)
    });
    this.addCommand({
      id: "collect-attachments-current-folder",
      name: "Collect attachments in current folder",
      checkCallback: (checking) => collectAttachmentsCurrentFolder(this, checking)
    });
    this.addCommand({
      id: "collect-attachments-entire-vault",
      name: "Collect attachments in entire vault",
      callback: () => collectAttachmentsEntireVault(this)
    });
    this.registerEvent(this.app.workspace.on("file-menu", this.handleFileMenu.bind(this)));
  }
  onLayoutReady() {
    this.register(around(this.app.vault, {
      getAvailablePathForAttachments: (originalFn) => async (filename, extension, file) => this.getAvailablePathForAttachments(filename, extension, file, originalFn),
      getAvailablePath: () => (filename, extension) => this.getAvailablePath(filename, extension)
    }));
  }
  async parseSettings(data) {
    const { settings, shouldSave } = CustomAttachmentLocationPluginSettings.load(data);
    if (shouldSave) {
      await this.saveSettings(settings);
    }
    return settings;
  }
  async getAvailablePathForAttachments(filename, extension, file, originalFn) {
    if (!(file instanceof import_obsidian5.TFile)) {
      return await originalFn.call(this.app.vault, filename, extension, file);
    }
    if (!(0, import_TAbstractFile4.isNote)(file)) {
      return await originalFn.call(this.app.vault, filename, extension, file);
    }
    const attachmentFolderFullPath = await getAttachmentFolderFullPathForPath(this, file.path);
    await (0, import_Vault6.createFolderSafe)(this.app, attachmentFolderFullPath);
    return this.app.vault.getAvailablePath((0, import_Path7.join)(attachmentFolderFullPath, filename), extension);
  }
  getAvailablePath(filename, extension) {
    let suffixNum = 0;
    while (true) {
      const path = makeFileName(suffixNum == 0 ? filename : `${filename}${this.settings.duplicateNameSeparator}${suffixNum}`, extension);
      if (!this.app.vault.getAbstractFileByPathInsensitive(path)) {
        return path;
      }
      suffixNum++;
    }
  }
  handleFileMenu(menu, file) {
    if (!(file instanceof import_obsidian5.TFolder)) {
      return;
    }
    menu.addItem((item) => {
      item.setTitle("Collect attachments in folder").setIcon("download").onClick(() => collectAttachmentsInFolder(this, file));
    });
  }
};

// src/main.ts
var __import_meta_url12 = globalThis["import.meta.url"] ?? (() => require("node:url").pathToFileURL(__filename))();
var __process12 = globalThis["process"] ?? {
  "cwd": () => "/",
  "env": {},
  "platform": "android"
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
